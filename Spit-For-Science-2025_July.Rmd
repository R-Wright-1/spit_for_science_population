---
title: "Spit for Science Sick Kids 2025"
output: html_notebook
---

```{R, results='hide', fig.keep='all', message=FALSE}
# library(philr)
library(tidyr)
packageVersion("maaslin3")
# library(stats)
library(broom)
# library(ALDEx2)
# library(radEmu)
# library(maaslin3)
library(vegan)
# library(ANCOMBC)
# library(LOCOM)
library(phyloseq)
library(ape)
```

```{R, results='hide', fig.keep='all', message=FALSE}
#install.packages("reticulate", force = TRUE)
library(reticulate)
#py_config()
#py_uninstall("matplotlib")
#use_python('/Users/robynwright/anaconda3/envs/r-environment/bin/python')
py_require("Biopython", exclude_newer="2025-05-02")
# py_require("Biopython")
py_require("pandas")
py_require("matplotlib")
py_require("scipy")
py_require("numpy")
py_require("scikit-learn")
py_require("statsmodels")
py_require("scikit-bio")
py_require("ete3")
py_require("openpyxl")
#Sys.setenv(UV_OFFLINE=1)
```

```{python}
# import numpy as np
# np.__version__
from datetime import datetime
import pandas as pd
import math
import matplotlib.pyplot as plt
from matplotlib.patches import Ellipse, Patch, Rectangle, Polygon
import matplotlib.transforms as transforms
import matplotlib.image as mpimg
import matplotlib as mpl
import matplotlib.cm as cm
from matplotlib.lines import Line2D
from matplotlib.offsetbox import AnchoredText
from mpl_toolkits.axes_grid1.inset_locator import inset_axes
from skbio.diversity import get_alpha_diversity_metrics, get_beta_diversity_metrics, alpha_diversity, beta_diversity
from skbio import read
from skbio.tree import TreeNode
from skbio.stats import ordination
import numpy as np
from numpy.polynomial import Polynomial
import os
import random
#import kmedoids
# from deicode.preprocessing import rclr
#from skbio.stats.composition import clr
#from sklearn.metrics import plot_roc_curve, roc_curve, accuracy_score, roc_auc_score, confusion_matrix
from scipy.stats import mannwhitneyu, ttest_ind, pearsonr, spearmanr, randint, skew, kurtosis
from scipy import stats
from scipy.spatial import distance
from scipy.cluster import hierarchy
import scipy.spatial.distance as ssd
from scipy.optimize import curve_fit
from sklearn import preprocessing
from sklearn.metrics import accuracy_score, roc_auc_score
from sklearn.metrics import mean_squared_error, r2_score
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from sklearn.model_selection import train_test_split, RandomizedSearchCV
import statsmodels.api as sm
from statsmodels.formula.api import ols
lowess = sm.nonparametric.lowess
from Bio import Phylo, SeqIO
import pickle
from ete3 import Tree

folder_all = '/Users/robynwright/Dropbox/Langille_Lab_postdoc/Current_projects/SfS_SickKids/'
folder_atpath = '/Users/robynwright/Dropbox/Langille_Lab_postdoc/Current_projects/SfS_SickKids/atlantic_PATH_reprocess/'
folder_initial = '/Users/robynwright/Dropbox/Langille_Lab_postdoc/Current_projects/SfS_SickKids/analysis_all_samples/'
folder = '/Users/robynwright/Dropbox/Langille_Lab_postdoc/Current_projects/SfS_SickKids/analysis_2025/'
exports = folder_initial+'QIIME2/deblur_output_exported/'
colors_gender = {1:'#F4D03F', 2:'#C0392B', 'Male':'#F4D03F', 'Female':'#C0392B', 3:'#16a085', 'Trans/gender-diverse':'#16a085'}
colors_ethnicity = {'South Asian':'#16A085', 'East Asian':'#8E44AD', 'White':'#2980B9', 1:'#8E44AD', 2:'#16A085', 3:'#2980B9', 'SA':'#16A085', 'EA':'#8E44AD', 'W':'#2980B9'}
colors_diag = {'none':'#A569BD', 'diagnosis':'#45B39D', 'controls':'#A569BD', 'cases':'#45B39D', 0:'#A569BD', 1:'#45B39D'}
colors_age = {'group1':'#A60DD3', 'group2':'#D840BC', 'group_3':'#E67E22', 'group_4':'#F4D03F', 'Young':'#A60DD3', 'Middle':'#D840BC', 'Old':'#E67E22'}
colors_condition = {'no_reported_condition':'#5dade2', 'physical_condition':'#48c9b0', 'mental_condition':'#f4d03f', 'mental_and_physical':'#dc7633', 1:'#5dade2', 2:'#48c9b0', 3:'#f4d03f', 4:'#dc7633', 'None':'#5dade2', 'Phys.':'#48c9b0', 'Ment.':'#f4d03f', 'Both':'#dc7633'}
colors_antibiotics = {'never':'#2e4053', 'in_the_last_month':'#f4d03f', 'no':'#2e4053', 'yes':'#f4d03f', 'N':'#2e4053', 'Y':'#f4d03f', 'No':'#2e4053', 'In the last month':'#f4d03f'}
colors_gta = {0:'#2e4053', 1:'#800000'}
colors_distance = {'Control_Control':'k', 'Case_Case':'k', 'Case_Control':'#7D3C98'}
colors_gender_ethnicity = {'South Asian-Male':'#e67e22', 'South Asian-Female':'#f1c40f', 'East Asian-Male':'#229954', 'East Asian-Female':'#1f618d', 'White-Male':'#6c3483', 'White-Female':'#a93226'}
```

Confidence ellipse:
```{python}
def confidence_ellipse(x, y, ax, n_std=2.0, facecolor='none', **kwargs):
    x = np.array(x)
    y = np.array(y)
    if x.size != y.size:
        raise ValueError("x and y must be the same size")
    cov = np.cov(x, y)
    pearson = cov[0, 1]/np.sqrt(cov[0, 0] * cov[1, 1])
    # Using a special case to obtain the eigenvalues of this
    # two-dimensionl dataset.
    ell_radius_x = np.sqrt(1 + pearson)
    ell_radius_y = np.sqrt(1 - pearson)
    ellipse = Ellipse((0, 0), width=ell_radius_x * 2, height=ell_radius_y * 2,
                      facecolor=facecolor, **kwargs)
    # Calculating the stdandard deviation of x from
    # the squareroot of the variance and multiplying
    # with the given number of standard deviations.
    scale_x = np.sqrt(cov[0, 0]) * n_std
    mean_x = np.mean(x)
    # calculating the stdandard deviation of y ...
    scale_y = np.sqrt(cov[1, 1]) * n_std
    mean_y = np.mean(y)
    transf = transforms.Affine2D() \
        .rotate_deg(45) \
        .scale(scale_x, scale_y) \
        .translate(mean_x, mean_y)
    ellipse.set_transform(transf + ax.transData)
    return ax.add_patch(ellipse)
```

Draw tree:
```{python}
def draw_tree(tree, orient_tree='horizontal', vert_orient='down', axes=None, label_func=str, span=355, plot_labels=True, end_same=True, fs=10):
    # Arrays that store lines for the plot of clades
    horizontal_linecollections = []
    vertical_linecollections = []
    def get_x_positions(tree):
        """Create a mapping of each clade to its horizontal position.
        Dict of {clade: x-coord}
        """
        depths = tree.depths()
        # If there are no branch lengths, assume unit branch lengths
        if not max(depths.values()):
            depths = tree.depths(unit_branch_lengths=True)
        return depths
    def format_branch_label(clade):
                return None
    def get_y_positions(tree):
        """Create a mapping of each clade to its vertical position.
        Dict of {clade: y-coord}.
        Coordinates are negative, and integers for tips.
        """
        maxheight = tree.count_terminals()
        # Rows are defined by the tips
        heights = {tip: maxheight - i for i, tip in enumerate(reversed(tree.get_terminals()))}
        # Internal nodes: place at midpoint of children
        def calc_row(clade):
            for subclade in clade:
                if subclade not in heights:
                    calc_row(subclade)
            # Closure over heights
            heights[clade] = (
                heights[clade.clades[0]] + heights[clade.clades[-1]]
            ) / 2.0
        if tree.root.clades:
            calc_row(tree.root)
        return heights
    x_posns = get_x_positions(tree)
    y_posns = get_y_positions(tree)
    if axes is None:
        fig = plt.figure()
        if orient_tree == 'circular':
            axes = fig.add_subplot(1, 1, 1, orientation='polar')
        else:
            axes = fig.add_subplot(1, 1, 1)
    elif not isinstance(axes, plt.matplotlib.axes.Axes):
        raise ValueError("Invalid argument for axes: %s" % axes)
    leaves = [['Label', 'x loc', 'y loc', 'rotation', 'va', 'ha']]
    def draw_clade_lines(orientation="horizontal",y_here=0,x_start=0,x_here=0,y_bot=0,y_top=0,color="black",lw="10", ls='-'):
        """Create a line.
        Graphical formatting of the lines representing clades in the plot can be
        customized by altering this function.
        """
        if orientation == "horizontal":
            axes.hlines(y_here, x_start, x_here, color=color, lw=lw, linestyle=ls)
        elif orientation == "vertical":
            axes.vlines(x_here, y_bot, y_top, color=color, linestyle=ls)
    def draw_clade(clade, x_start, color, lw, orient_tree='horizontal', vert_orient='up'):
        """Recursively draw a tree, down from the given clade."""
        x_here = x_posns[clade]
        y_here = y_posns[clade]
        xmax = max(x_posns.values())+max(x_posns.values())/30
        # phyloXML-only graphics annotations
        if hasattr(clade, "color") and clade.color is not None:
            color = clade.color.to_hex()
        if hasattr(clade, "width") and clade.width is not None:
            lw = clade.width * plt.rcParams["lines.linewidth"]
        if orient_tree == 'horizontal':
            # Draw a horizontal line from start to here
            draw_clade_lines(orientation='horizontal',y_here=y_here,x_start=x_start,x_here=x_here,color=color,lw=lw)
            if clade.name != None and end_same:
                if 'g__' in clade.name:
                    draw_clade_lines(orientation='horizontal',y_here=y_here,x_start=xmax,x_here=x_here,color=color,lw=lw, ls='-.')
            # Add node/taxon labels
            if clade.name not in (None, clade.__class__.__name__):
                label = label_func(clade.name)
                if end_same: xplc = xmax
                else: xplc = x_here
                if plot_labels: axes.text(xplc, y_here, " %s" % label, verticalalignment="center", horizontalalignment='left', color='k', fontsize=fs)
                leaves.append([label, xplc, y_here, 0, 'center', 'left']) 
            if clade.clades:
                # Draw a vertical line connecting all children
                y_top = y_posns[clade.clades[0]]
                y_bot = y_posns[clade.clades[-1]]
                # Only apply widths to horizontal lines, like Archaeopteryx
                draw_clade_lines(orientation='vertical',x_here=x_here,y_bot=y_bot,y_top=y_top,color=color,lw=lw)
                # Draw descendents
                for child in clade:
                    draw_clade(child, x_here, color, lw)
        elif orient_tree == 'vertical':
                draw_clade_lines(orientation='vertical', x_here=y_here, y_bot=x_start, y_top=x_here,color=color,lw=lw)
                if clade.name != None and end_same and '__' not in clade.name:
                    draw_clade_lines(orientation='vertical',x_here=y_here, y_bot=xmax, y_top=x_here,color=color,lw=lw, ls='-.')
                if clade.name not in (None, clade.__class__.__name__):
                    label = label_func(clade.name)
                    if end_same: xplc = xmax
                    else: xplc = x_here
                    if vert_orient == 'up':
                        if plot_labels: axes.text(y_here, xplc,  " %s" % label, verticalalignment='bottom', horizontalalignment='center', color='k', rotation=90, fontsize=fs)
                        leaves.append([label, y_here, xplc, 90, 'bottom', 'center']) 
                    elif vert_orient == 'down':
                        if plot_labels: axes.text(y_here, xplc,  " %s" % label, verticalalignment='top', horizontalalignment='center', color='k', rotation=90, fontsize=fs)
                        leaves.append([label, y_here, xplc, 90, 'top', 'center']) 
                if clade.clades:
                    y_top = y_posns[clade.clades[0]]
                    y_bot = y_posns[clade.clades[-1]]
                    draw_clade_lines(orientation='horizontal', y_here=x_here, x_start=y_bot, x_here=y_top, color=color,lw=lw)
                    for child in clade:
                        draw_clade(child, x_here, color, lw, orient_tree='vertical', vert_orient=vert_orient)
    def draw_clade_polar(clade, color, lw, x_start=0.1, y_start=0, span=360):
        ymax = max(y_posns.values())
        yang = span/ymax
        xmax = max(x_posns.values())+max(x_posns.values())/30
        x_here = x_posns[clade]
        y_here = y_posns[clade]
        rad = span*np.pi/180
        rad = rad/ymax
        if y_start == 0:
            y_start = rad*y_start
        y_here = rad*y_here
        if x_here != 0: 
            axes.plot([y_start, y_here], [x_start, x_here], color=color, lw=lw)
            if clade.name != None and end_same and '__' not in clade.name:
                axes.plot([y_start, y_here], [x_here, xmax], color=color, lw=lw, linestyle='-.')
        if clade.name not in (None, clade.__class__.__name__):
            label = label_func(clade.name)
            rot = y_here*(180/np.pi)
            if end_same: xplc = xmax
            else: xplc = x_here
            if rot <= 90: va, ha = 'center', 'left'
            elif rot <= 180: va, ha, rot = 'center', 'right', rot-180
            elif rot <= 270: va, ha, rot = 'center', 'right', rot-180
            else: va, ha = 'center', 'left'
            if plot_labels: axes.text(y_here, xplc, label, color='k', rotation=rot, rotation_mode='anchor', va=va, ha=ha, fontsize=fs)
            leaves.append([label, y_here, xplc, rot, va, ha])
        if clade.clades:
            y_top = y_posns[clade.clades[0]]
            y_bot = y_posns[clade.clades[-1]]
            y_top = y_top*yang*np.pi/180
            y_bot = y_bot*yang*np.pi/180
            curve = [[y_bot, y_top], [x_here, x_here]]
            x = np.linspace(curve[0][0], curve[0][1], 500)
            y = interp1d(curve[0], curve[1])(x)
            axes.plot(x, y, color=color, lw=lw)
            ymin, ymax = min(x), max(x)
            ydiff = ymax-ymin
            count = [1 for child in clade]
            count = sum(count)-2
            locs = [ymin]
            for a in range(count):
                locs.append(ydiff/(count+1)+ymin)
            locs.append(ymax)
            count = 0
            for child in clade:
                if child.name != None: 
                    y_start = y_posns[child]*rad
                else:
                    y_start = locs[count]
                draw_clade_polar(child, color, lw, x_start=x_here, y_start=y_start, span=span)
                count += 1
    plt.sca(axes)
    if orient_tree in ['horizontal', 'vertical']:
        draw_clade(tree.root, 0, "k", plt.rcParams["lines.linewidth"], orient_tree=orient_tree, vert_orient=vert_orient)
        if orient_tree == 'horizontal':
            xmax = max(x_posns.values())
            axes.set_xlim(-0.05 * xmax, 1.25 * xmax)
            # Also invert the y-axis (origin at the top)
            # Add a small vertical margin, but avoid including 0 and N+1 on the y axis
            axes.set_ylim(max(y_posns.values()) + 0.8, 0.2)
        elif orient_tree == 'vertical':
            axes.set_xlim(max(y_posns.values()) + 0.8, 0.2)
            xmax = max(x_posns.values())
            if vert_orient == 'up':
                axes.set_ylim(-0.05 * xmax, 1.25 * xmax)
            elif vert_orient == 'down':
                axes.set_ylim(1.25 * xmax, -0.05 * xmax)
        axes.set_xticks([]), axes.set_yticks([])
    elif orient_tree == 'circular':
        print('Note that if you provided an axes for this then it must be polar orientation or it will probably look very strange')
        x_start = 0
        y_start = 0
        draw_clade_polar(tree.root, "k", plt.rcParams["lines.linewidth"], x_start=x_start, y_start=y_start, span=span)
        axes.set_ylim([0, max(x_posns.values())])
        axes.yaxis.grid(False)
        axes.set_xticks([])
        axes.set_yticklabels([])
    return leaves
```

# Put all metadata together and remove excluded participants and filter alpha/beta diversity

Get metadata from most recent files (March 2025, April 2025 and June 2025), remove exclusions.

Files:
SFS2- Data Pull - UPDATED November 2024- For Robyn.xlsx - saved as .csv
metadata_microbiome_missinginfo.csv
Marginalization data for Robyn March 2025.csv
Excluded Participants Spit 2.xlsx - saved as .csv
sfs2_diet-09jan2025.csv
Individual level factors for Robyn - April 29, 2025.xlsx - saved as .csv
mental_and_medical 2 - MB for Robyn_2.xlsx - saved as .csv

```{R}
s2pheno = readRDS(paste(py$folder_all, 'S2pheno_2025-11-06.RDS', sep=''))
write.csv(s2pheno, file=paste(py$folder_all, "S2pheno_2025-11-06.csv", sep=""))
```

```{python}
all_md = pd.read_csv(folder_all+'SFS2- Data Pull - UPDATED November 2024- For Robyn.csv', index_col=0, header=0)

#drop any participants that need to be excluded
exclusions = pd.read_csv(folder_all+'Excluded Participants Spit 2.csv', index_col=0, header=0)
excluded_in_md = []
for row in exclusions.index.values:
  if row in all_md.index.values:
    excluded_in_md.append(row)
    
all_md_rename = {}
for sn in all_md.index.values:
  tag = sn[:3]
  sn_up = sn.replace(tag, tag.upper())
  if sn == sn_up: continue
  all_md_rename[sn] = sn_up

all_md = all_md.rename(index=all_md_rename)

#none of the excluded participants are in the metadata anyway!

#add in marginalisation data
marg = pd.read_csv(folder_all+'Marginalization data for Robyn March 2025.csv', index_col=0, header=0)
marg_rename = {}
for sn in marg.index.values:
  tag = sn[:3]
  sn_up = sn.replace(tag, tag.upper())
  if sn == sn_up: continue
  marg_rename[sn] = sn_up

marg = marg.rename(index=marg_rename)

all_md['cur_msd_mat'] = ''
all_md['cur_msd_soc'] = ''

for row in all_md.index.values:
  if row in marg.index.values:
    all_md.loc[row, ['cur_msd_mat', 'cur_msd_soc']] = marg.loc[row, ['cur_msd_mat', 'cur_msd_soc']]
    
ind_marg = pd.read_csv(folder_all+'Individual level factors for Robyn - April 29, 2025.csv', index_col=0, header=0)
marg_rename = {}
for sn in ind_marg.index.values:
  tag = sn[:3]
  sn_up = sn.replace(tag, tag.upper())
  if sn == sn_up: continue
  marg_rename[sn] = sn_up

ind_marg = ind_marg.rename(index=marg_rename)
all_md['houseincome'] = ''
all_md['edu_parent1'] = ''
all_md['parent2'] = ''
all_md['edu_parent2'] = ''

for row in all_md.index.values:
  if row in ind_marg.index.values:
    all_md.loc[row, ['houseincome', 'edu_parent1', 'parent2', 'edu_parent2']] = ind_marg.loc[row, ['houseincome', 'edu_parent1', 'parent2', 'edu_parent2']]
  if all_md.loc[row, 'houseincome'] in [7, 999]: all_md.loc[row, 'houseincome'] = ''
  if all_md.loc[row, 'parent2'] in [999]: all_md.loc[row, 'parent2'] = ''
  if all_md.loc[row, 'edu_parent1'] in ['NA', 12]: all_md.loc[row, 'edu_parent1'] = ''
  if all_md.loc[row, 'edu_parent2'] in ['NA', 12]: all_md.loc[row, 'edu_parent2'] = ''

#add in HEFI
diet = pd.read_csv(folder_all+'sfs2_diet-09jan2025.csv', index_col=0, header=0)
keeping_diet = set(list(pd.read_csv(folder_all+'Participants_to_Keep_s2dietcut.csv', index_col=0, header=0).index.values))

all_md['HEFI'] = ''
for row in all_md.index.values:
  if row in diet.index.values and row in keeping_diet:
    all_md.loc[row, 'HEFI'] = diet.loc[row, 'HEFI']

#get missing ethnicity/gender
missing_data = pd.read_csv(folder_all+'metadata_microbiome_missinginfo.csv', index_col=0, header=0)

dropping = []
count_trans, count_other = 0, 0
for row in missing_data.index.values:
  if missing_data.loc[row, 'Reason'] in ['Mixed ethnicity', 'Partially missing ethnicity']:
    all_md.loc[row, 'ethnicity'] = missing_data.loc[row, 'Main Race/Ethnicity Group']
  else:
    if missing_data.loc[row, 'gender_gp'] in [5, 999]:
      dropping.append(row)
    elif missing_data.loc[row, 'gender_gp'] == 6:
      all_md.loc[row, 'gender'] = 3 #1
      count_trans += 1
    elif missing_data.loc[row, 'gender_gp'] == 7:
      all_md.loc[row, 'gender'] = 3 #2
      count_trans += 1
    else:
      all_md.loc[row, 'gender'] = 3
      count_other += 1

all_md = all_md.drop(dropping, axis=0)

#recode antibiotics and strict diet    
all_md = all_md.rename(columns={'dsq3':'antibiotics', 'dsq1':'strict_diet'})
for row in all_md.index.values:
  if all_md.loc[row, 'strict_diet'] == 0:
    all_md.loc[row, 'strict_diet'] = 'vegetarian'
  elif all_md.loc[row, 'strict_diet'] == 1:
    all_md.loc[row, 'strict_diet'] = 'vegan'
  elif all_md.loc[row, 'strict_diet'] == 2:
    all_md.loc[row, 'strict_diet'] = 'omnivore'
  if all_md.loc[row, 'antibiotics'] == 0:
    all_md.loc[row, 'antibiotics'] = 'no'
  elif all_md.loc[row, 'antibiotics'] in [1, 2, 3, 4, 5, 6, 7, 8]:
    all_md.loc[row, 'antibiotics'] = 'in_the_last_month'
    
#add in cut_gta information
gta = pd.read_csv(folder_all+'GTA data for Robyn.csv', index_col=0, header=0)
gta_rename = {}
for sn in gta.index.values:
  tag = sn[:3]
  sn_up = sn.replace(tag, tag.upper())
  if sn == sn_up: continue
  gta_rename[sn] = sn_up
  
gta = gta.rename(index=gta_rename)
gta_ind = [ind for ind in all_md.index.values if ind in gta.index.values]
all_md['cur_gta'] = gta.loc[gta_ind, 'cur_gta']
    
all_md.to_csv(folder+'files/metadata_all_participants.csv')
```

Calculate skewness for HEFI and diet richness:
```{python}
all_md = pd.read_csv(folder+'files/metadata_all_participants.csv', index_col=0, header=0)

other_diet = ['strict_diet', 'dsq2', 'antibiotics', 'dsq4', 'dsq5', 'dsq6', 'dsq7', 'dsq8', 'dsq9', 'dsq10', 'dsq11', 'dsq12', 'dsq13', 'dsq14', 'dsq15', 'dsq16', 'dsq17', 'dsq18', 'dsq19', 'dsq20', 'dsq21', 'dsq22', 'dsq23']
all_diet = ['strict_diet', 'dsq2', 'antibiotics', 'dsq4', 'dsq5', 'dsq6', 'dsq7', 'dsq8', 'dsq9', 'dsq10', 'dsq11', 'dsq12', 'dsq13', 'dsq14', 'dsq15', 'dsq16', 'dsq17', 'dsq18', 'dsq19', 'dsq20', 'dsq21', 'dsq22', 'dsq23', 'diet_richness_daily', 'diet_richness_weekly', 'diet_richness_monthly', 'HEFI']

for participant in all_md.index.values:
  if all_md.loc[participant, 'HEFI'] == '' or np.isnan(all_md.loc[participant, 'HEFI']):
    all_md.loc[participant, other_diet] = np.nan

#get diet richness
diet_metrics_only = ['dsq4','dsq5','dsq6','dsq7','dsq8','dsq10','dsq11','dsq13','dsq14','dsq15','dsq16','dsq17','dsq18','dsq19','dsq20','dsq21','dsq22','dsq23']
md_diet = all_md.copy(deep=True).loc[:, diet_metrics_only].dropna(axis=0)

md_diet_month = md_diet.copy(deep=True)
md_diet_week = md_diet.copy(deep=True)
md_diet_day = md_diet.copy(deep=True)

md_diet_month[md_diet_month >= 1] = 1
md_diet_week[md_diet_week < 3] = 0
md_diet_week[md_diet_week >= 3] = 1
md_diet_day[md_diet_day < 7] = 0
md_diet_day[md_diet_day >= 7] = 1
md_diet_month['diet_richness_monthly'] = md_diet_month.sum(axis=1)
md_diet_week['diet_richness_weekly'] = md_diet_week.sum(axis=1)
md_diet_day['diet_richness_daily'] = md_diet_day.sum(axis=1)

all_md['diet_richness_monthly'] = np.nan
all_md['diet_richness_weekly'] = np.nan
all_md['diet_richness_daily'] = np.nan
for row in all_md.index.values:
  if row in md_diet.index.values:
    all_md.loc[row, ['diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily']] = md_diet_month.loc[row, 'diet_richness_monthly'], md_diet_week.loc[row, 'diet_richness_weekly'], md_diet_day.loc[row, 'diet_richness_daily']

variables = ['diet_richness_daily', 'diet_richness_weekly', 'diet_richness_monthly', 'HEFI']
for var in variables:
  vals_var = list(all_md[var].values)
  vals_var = [x for x in vals_var if not np.isnan(x)]
  skew_val = skew(vals_var)
  kurt_val = kurtosis(vals_var)
  res = stats.normaltest(vals_var)
  print(var, skew_val, kurt_val, res.pvalue)

diet_data = all_md.copy(deep=True).loc[:, variables].dropna(axis=0)
dropping = []

variables = ['diet_richness_weekly', 'HEFI']

#none are normally distributed, so we will need to use IQR/MAD
for var in variables:
  mad_num, iqr_num = 0, 0
  vals_var = list(diet_data[var].values)
  q3 = np.quantile(vals_var, 0.75)
  med = np.median(vals_var)
  mean = np.mean(vals_var)
  stdev = np.std(vals_var)
  mad = stats.median_abs_deviation(vals_var)
  q1 = np.quantile(vals_var, 0.25)
  iqr = abs(q3-q1)
  ma = q3+(1.5*iqr)
  mi = q1-(1.5*iqr)
  #zscores = [(0.6745*(abs(x-med))/mad) for x in vals_var]
  #zscores = [(x-mean)/stdev for x in vals_var]
  zscores = [abs(x-med) for x in vals_var]
  median_of_z = np.median(zscores)
  # print(var, mad, median_of_z)
  tukey_lower = med-4.45*median_of_z
  tukey_upper = med+4.45*median_of_z
  # print(var, mad, tukey_lower, tukey_upper)
  # print(mi, tukey_lower, ma, tukey_upper)
  for r in range(len(diet_data.index.values)):
    participant = diet_data.index.values[r]
    val = diet_data.loc[participant, var]
    if val > tukey_upper and val > ma:
      dropping.append(participant)
    elif val < tukey_lower and val < mi:
      dropping.append(participant)
    # if val > ma:
    #   dropping.append(participant)
    #   iqr_num += 1
    # elif val < mi:
    #   dropping.append(participant)
    #   iqr_num += 1

# print(len(set(dropping)), len(dropping))
# twice = []
# for drop in dropping:
#   if dropping.count(drop) > 1:
#     twice.append(drop)

# dropping = set(dropping)
# for row in dropping:
#   all_md.loc[row, all_diet] = np.nan

all_md.to_csv(folder+'files/metadata_all_participants_diet_richness.csv')
```

Now get the min 2000 sequences file from previously, check we don't have, filter the metadata to only include these, and get the physical/mental health information:
```{python}
all_md = pd.read_csv(folder+'files/metadata_all_participants_diet_richness.csv', index_col=0, header=0)
ft = pd.read_csv(folder_initial+'files/feature-table_duplicates_dropped_min2000.csv', index_col=0, header=0)

md_samples = set(all_md.index.values)
ft_samples = set(ft.columns)

overlap = [sample for sample in md_samples if sample in ft_samples]

ft = ft.loc[:, overlap]
all_md = all_md.loc[overlap, :]

#get physical and mental condition
mental_conditions = ['dx_adhd', 'dx_anx', 'dx_asd', 'dx_bp', 'dx_dep', 'dx_id', 'dx_ld', 'dx_ocd', 'dx_odd', 'dx_schizo', 'dx_spcd', 'dx_subuse', 'dx_tics', 'dx_eatdis']
physical_conditions = ['dx_allergies', 'dx_asthma', 'dx_autoimm', 'dx_cp', 'dx_epi_seiz', 'dx_genetic', 'dx_migraine2', 'dx_hearing', 'dx_visual', 'dx_mobility', 'dx_headinj', 'dx_fasd', 'dx_other_meddis']
health = pd.read_csv(folder_all+'mental_and_medical 2 - MB for Robyn_2.csv', index_col=0, header=0)

health = health.loc[ft.columns, :]

#drop all from initial metadata
dropping = ['dx_adhd', 'dx_ocd', 'dx_asd', 'dx_dep', 'dx_anx', 'dx_eatdis', 'dx_bp', 'dx_id', 'dx_ld', 'dx_odd', 'dx_schizo', 'dx_spcd', 'dx_subuse', 'dx_tics', 'dx_schizo_bp', 'dx_allergies', 'dx_asthma', 'dx_autoimm', 'autoimm_info', 'dx_cp', 'dx_epi_seiz', 'dx_genetic', 'genetic_dis_info___1', 'genetic_dis_info___2', 'genetic_dis_info___3', 'genetic_dis_info___4', 'genetic_dis_info___5', 'genetic_dis_info___6', 'genetic_dis_info___7', 'genetic_dis_other', 'dx_migraine2', 'dx_hearing', 'dx_visual', 'dx_mobility', 'swan_gender_tscores', 'swan_ia_gender_tscores', 'swan_hi_gender_tscores', 'swan_tscores', 'swan_ia_tscores', 'swan_hi_tscores', 'tocs21_gender_tscores', 'tocs21_tscores', 'rcads_anx_tscore_official', 'rcads_dep_tscore_official', 'rcads_tot_tscore_official', 'tides_gender_study_tscores', 'tides_study_tscores', 'aq_gender_study_tscores', 'aq_study_tscores', 'aq_nopat_gender_study_tscores', 'aq_nopat_study_tscores', 'rcads_gender_study_tscores', 'rcads_study_tscores', 'rcads_anx_gender_study_tscores', 'rcads_anx_study_tscores', 'rcads_dep_gender_study_tscores', 'rcads_dep_study_tscores']

all_md  = all_md.drop(dropping, axis=1)

#now just get whether they have a diagnosis or not
all_md['physical_condition'] = ''
all_md['mental_condition'] = ''

for row in all_md.index.values:
  if health.loc[row, 'MH Dx'] == 'Yes':
    all_md.loc[row, 'mental_condition'] = 1
  else:
    all_md.loc[row, 'mental_condition'] = 0
  md_part = health.loc[row, physical_conditions].dropna().values
  if len(md_part) == 0:
    all_md.loc[row, 'physical_condition'] = 0
  else:
    all_md.loc[row, 'physical_condition'] = max(md_part)
    
all_md['physical_mental_condition'] = all_md['physical_condition']+all_md['mental_condition']

for row in all_md.index.values:
  if all_md.loc[row, 'physical_mental_condition'] == 2:
    all_md.loc[row, 'physical_mental_condition'] = 'mental_and_physical'
  elif all_md.loc[row, 'physical_mental_condition'] == 0:
    all_md.loc[row, 'physical_mental_condition'] = 'no_reported_condition'
  elif all_md.loc[row, 'physical_mental_condition'] == 1:
    if all_md.loc[row, 'physical_condition'] == 1:
      all_md.loc[row, 'physical_mental_condition'] = 'physical_condition'
    else:
      all_md.loc[row, 'physical_mental_condition'] = 'mental_condition'
  else:
    print(row)

ft.to_csv(folder+'files/feature-table_min2000_with_metadata.csv')
all_md.to_csv(folder+'files/metadata_microbiome_participants.csv')

all_md_full_md = all_md.loc[:, ['diet_richness_daily', 'HEFI']].dropna(axis=0)
all_md_diet = all_md.loc[all_md_full_md.index.values, :]

all_md_diet.to_csv(folder+'files/metadata_microbiome_participants_full_diet.csv')
```

Double check participants with latest S2pheno release:
```{python}
s2pheno = pd.read_csv(folder_all+'S2pheno_2025-11-06.csv', index_col=1, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
env_variables = ['cur_msd_mat', 'cur_msd_soc', 'cur_gta', 'cur_ior', 'cur_gmn_mean', 'cur_pm25_mean', 'cur_omarg_hh', 'cur_omarg_mat', 'cur_omarg_labour', 'cur_omarg_race', 'birth_gta', 'birth_ior', 'birth_gmn_mean', 'birth_pm25_mean', 'birth_omarg_hh', 'birth_omarg_mat', 'birth_omarg_labour', 'birth_omarg_race', 'birth_msd_mat', 'birth_msd_soc', 'utero_gta', 'utero_ior', 'utero_gmn_mean', 'utero_pm25_mean', 'utero_omarg_hh', 'utero_omarg_mat', 'utero_omarg_labour', 'utero_omarg_race', 'utero_msd_mat', 'utero_msd_soc', 'sch_gta', 'sch_ior', 'sch_gmn_mean', 'sch_pm25_mean', 'sch_omarg_hh', 'sch_omarg_mat', 'sch_omarg_labour', 'sch_omarg_race', 'sch_msd_mat', 'sch_msd_soc']
#add no2 to this if it gets added later

rename = {}
for row in s2pheno.index.values:
  if 'TAG' not in row:
    rename[row] = row.replace('t', 'T').replace('a', 'A').replace('g', 'G')

s2pheno = s2pheno.rename(index=rename)
s2pheno = s2pheno.loc[md.index.values, :]
s2pheno.to_csv(folder+'files/S2pheno_2025-11-06_microbiome_participants.csv')
md.loc[:, env_variables] = s2pheno.loc[:, env_variables]

md.to_csv(folder+'files/metadata_microbiome_participants_s2pheno.csv')

all_md_diet = pd.read_csv(folder+'files/metadata_microbiome_participants_full_diet.csv', index_col=0, header=0)
env_vars = ['cur_msd_mat', 'cur_msd_soc', 'cur_gta', 'cur_ior', 'cur_gmn_mean', 'cur_pm25_mean']
all_md_diet[env_vars] = ''
for row in all_md_diet.index.values:
  all_md_diet.loc[row, env_vars] = md.loc[row, env_vars]

all_md_diet.to_csv(folder+'files/metadata_microbiome_participants_full_diet_s2pheno.csv')
```

All environmental variables:
```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants_s2pheno.csv', index_col=0, header=0)
env_variables = ['gta', 'ior', 'gmn_mean', 'pm25_mean', 'omarg_hh', 'omarg_mat', 'omarg_labour', 'omarg_race', 'msd_mat', 'msd_soc']
env_variables_red = ['gta', 'ior', 'gmn_mean', 'pm25_mean', 'msd_mat', 'msd_soc']
times = ['cur', 'utero', 'sch']

basic_vars = ["family_id", "gender", "age", "ethnicity", "physical_mental_condition"]

all_env_variables = []
for time in times:
  for ev in env_variables_red:
    all_env_variables.append(time+'_'+ev)

md = md.loc[:, basic_vars+all_env_variables]
md = md.dropna()
md.to_csv(folder+'files/metadata_microbiome_participants_s2pheno_all_env.csv')

md = pd.read_csv(folder+'files/metadata_microbiome_participants_s2pheno.csv', index_col=0, header=0)
md = md.loc[:, basic_vars+['cur_'+v for v in env_variables_red]+['sch_'+v for v in env_variables_red if v != 'no2_mean']]
md = md.dropna()
md.to_csv(folder+'files/metadata_microbiome_participants_s2pheno_current_and_school_env.csv')

md = pd.read_csv(folder+'files/metadata_microbiome_participants_s2pheno.csv', index_col=0, header=0)
md = md.loc[:, basic_vars+['cur_'+v for v in env_variables]]
md = md.dropna()
md.to_csv(folder+'files/metadata_microbiome_participants_s2pheno_current_env_with_omarg.csv')

md = pd.read_csv(folder+'files/metadata_microbiome_participants_s2pheno.csv', index_col=0, header=0)
md = md.loc[:, basic_vars+['cur_'+v for v in env_variables_red]]
md = md.dropna()
md.to_csv(folder+'files/metadata_microbiome_participants_s2pheno_current_env.csv')
```

Filter to random child per family:
```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
families = set(list(md['family_id'].values))
part_family = list(md['family_id'].values)

participants = []
for family in families:
  this_family = md[md['family_id'] == family]
  if part_family.count(family) == 1:
    participants.append(this_family.index.values[0])
  else:
    ids = list(this_family.index.values)
    random_id = random.choice(ids)
    participants.append(random_id)

md_red = md.loc[participants, :]
md_red.to_csv(folder+'files/metadata_microbiome_participants_single_child_from_family.csv')
```

Filter to only families with two children:
```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
families = set(list(md['family_id'].values))
part_family = list(md['family_id'].values)

participants = []
for family in families:
  this_family = md[md['family_id'] == family]
  if part_family.count(family) == 2:
    participants.extend(this_family.index.values)

md_red = md.loc[participants, :]
md_red.to_csv(folder+'files/metadata_microbiome_participants_two_child_families.csv')

family_ids = list(md_red['family_id'].values)
random.shuffle(family_ids)

print(family_ids[:10])
print(list(md_red['family_id'].values)[:10])

md_red['family_id'] = family_ids
md_red.to_csv(folder+'files/metadata_microbiome_participants_two_child_families_shuffled_family_id.csv')
```

Filter to only families with two children:
```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
families = set(list(md['family_id'].values))
part_family = list(md['family_id'].values)

participants = []
for family in families:
  this_family = md[md['family_id'] == family]
  if part_family.count(family) >= 2:
    participants.extend(this_family.index.values)

print(len(participants))

md_red = md.loc[participants, :]
md_red.to_csv(folder+'files/metadata_microbiome_participants_no_individual_family.csv')

family_ids = list(md_red['family_id'].values)
random.shuffle(family_ids)

print(family_ids[:10])
print(list(md_red['family_id'].values)[:10])

md_red['family_id'] = family_ids
md_red.to_csv(folder+'files/metadata_microbiome_participants_no_individual_shuffled_family_id.csv')
```

Now filter all of the alpha and beta diversity tables to include only these:
```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
samples = list(set(md.index.values))

for ad in ['alpha_chao1.csv', 'alpha_faith_pd.csv', 'alpha_observed_otus.csv', 'alpha_shannon.csv', 'alpha_simpson_e.csv', 'alpha_simpson.csv']:
  this_alpha = pd.read_csv(folder_initial+'QIIME2/processing/alpha_diversity/'+ad, index_col=0, header=0)
  this_alpha = this_alpha.loc[samples, :]
  this_alpha.to_csv(folder+'files/alpha_diversity/'+ad)

beta_dist = pd.read_csv(folder_initial+'QIIME2/processing/phylo_rpca/distance-matrix.tsv', index_col=0, header=0, sep='\t')
beta_dist = beta_dist.loc[samples, samples]
beta_dist.to_csv(folder+'files/beta_diversity/phylo_rpca_distance.csv')

ordin = pd.read_csv(folder_initial+'QIIME2/processing/phylo_rpca/ordination_pca.csv', index_col=0, header=0)
ordin = ordin.loc[samples, :]
ordin.to_csv(folder+'files/beta_diversity/phylo_rpca_ordination_pca.csv')
```

Redo taxonomy:
```{python}
tax = pd.read_csv(folder_initial+"QIIME2/deblur_output_exported/taxonomy.csv", index_col=0, header=0)
ft = pd.read_csv(folder+'files/feature-table_min2000_with_metadata.csv', index_col=0, header=0)
tax = tax.loc[ft.index.values, :]

tax['ASV'] = ''
count = 1
for row in tax.index.values:
  this_tax = tax.loc[row, ['Kingdom', 'Phylum', 'Class', 'Order', 'Family', 'Genus', 'Species']].values
  lowest = ''
  for level in this_tax:
    if isinstance(level, str):
      lowest = level
  for r in range(len(this_tax)):
    if not isinstance(this_tax[r], str):
      this_tax[r] = 'Unclassified '+lowest
  tax.loc[row, ['Kingdom', 'Phylum', 'Class', 'Order', 'Family', 'Genus', 'Species']] = this_tax
  tax.loc[row, 'ASV'] = 'ASV'+str(count).zfill(4)
  count += 1
  
tax.to_csv(folder+'files/taxonomy.csv')
```

Group to genus level:
```{R}
asv_table <- read.csv(paste(py$folder, "files/feature-table_min2000_with_metadata.csv", sep=""))
taxonomy <- read.csv(paste(py$folder, "files/taxonomy.csv", sep=""))
taxonomy <- taxonomy[,-9]
phy_tree <- read_tree(paste(py$folder_initial, "QIIME2/deblur_output_exported/tree.nwk", sep=''))

asv_table_num = data.matrix(asv_table[,2:4813]) 
rownames(asv_table_num) = asv_table[,1] 
asv_table = as.matrix(asv_table_num) 

taxmat <- taxonomy[,-1] #remove the OTU ID column from the taxonomy table
rownames(taxmat) <- taxonomy[,1] #and now give the taxonomy table the OTU IDs as row names

ASV = otu_table(asv_table, taxa_are_rows = TRUE)
TAX = tax_table(taxmat)
taxa_names(TAX) <- taxonomy[,1]
physeq = phyloseq(ASV,phy_tree,TAX)

physeq_genus = tax_glom(physeq, taxrank="ta6")

tree_genus = phy_tree(physeq_genus)
write.tree(tree_genus, paste(py$folder, 'files/tree_genus.nwk', sep=''))

tab_genus = otu_table(physeq_genus)
write.csv(tab_genus, paste(py$folder, 'files/feature_table_genus.csv', sep=''))
```

Filter representative sequences to only those included (for PICRUSt2 - NOT USED):
```{python}
ft_seqs = set(list(pd.read_csv(folder+"files/feature-table_min2000_with_metadata.csv", index_col=0, header=0).index.values))
seqs = folder_initial+'QIIME2/deblur_output_exported/dna-sequences.fasta'

keeping_seqs = []
for record in SeqIO.parse(seqs, "fasta"):
  if record.id in ft_seqs:
    keeping_seqs.append(record)

SeqIO.write(keeping_seqs, folder+"files/dna_sequences.fasta", "fasta")
```

Put together feature tables for supplementary:
```{python}
ft = pd.read_csv(folder+"files/feature-table_min2000_with_metadata.csv", index_col=0, header=0)
tax = pd.read_csv(folder+"files/taxonomy.csv", index_col=0, header=0)

full_tax = {}
for row in tax.index.values:
  this_tax = list(tax.loc[row, :].values)
  this_tax = ';'.join(this_tax)
  full_tax[row] = this_tax

ft['Taxonomy'] = ''
for row in ft.index.values:
  ft.loc[row, 'Taxonomy'] = full_tax[row]
  
#get prevalence, sum reads and relative abundance
sums = ft.copy(deep=True).drop('Taxonomy', axis=1)
sums['Prevalence'] = ''
sums['Sum reads'] = ''
sums['Mean relative abundance'] = ''

ft_prev = ft.copy(deep=True).drop('Taxonomy', axis=1)
ft_prev[ft_prev > 0] = 1
sums['Prevalence'] = ft_prev.mean(axis=1)
sums['Sum reads'] = ft.copy(deep=True).drop('Taxonomy', axis=1).sum(axis=1)
ft_relabun = ft.copy(deep=True).drop('Taxonomy', axis=1)
ft_relabun = ft_relabun.divide(ft_relabun.sum(axis=0), axis=1).multiply(100)
sums['Mean relative abundance'] = ft_relabun.mean(axis=1)

ft['Prevalence'] = sums['Prevalence']
ft['Sum reads'] = sums['Sum reads']
ft['Mean relative abundance'] = sums['Mean relative abundance']

ft.to_csv(folder+'files/supplementary_feature_table_with_tax.csv')

ft_genus = pd.read_csv(folder+"files/feature_table_genus.csv", index_col=0, header=0)

full_tax = {}
for row in tax.index.values:
  this_tax = list(tax.loc[row, ['Kingdom', 'Phylum', 'Class', 'Order', 'Family', 'Genus']].values)
  this_tax = ';'.join(this_tax)
  full_tax[row] = this_tax

ft_genus['Taxonomy'] = ''
for row in ft_genus.index.values:
  ft_genus.loc[row, 'Taxonomy'] = full_tax[row]
  
#get prevalence, sum reads and relative abundance
sums = ft_genus.copy(deep=True).drop('Taxonomy', axis=1)
sums['Prevalence'] = ''
sums['Sum reads'] = ''
sums['Mean relative abundance'] = ''

ft_prev = ft_genus.copy(deep=True).drop('Taxonomy', axis=1)
ft_prev[ft_prev > 0] = 1
sums['Prevalence'] = ft_prev.mean(axis=1)
sums['Sum reads'] = ft_genus.copy(deep=True).drop('Taxonomy', axis=1).sum(axis=1)
ft_relabun = ft_genus.copy(deep=True).drop('Taxonomy', axis=1)
ft_relabun = ft_relabun.divide(ft_relabun.sum(axis=0), axis=1).multiply(100)
sums['Mean relative abundance'] = ft_relabun.mean(axis=1)

ft_genus['Prevalence'] = sums['Prevalence']
ft_genus['Sum reads'] = sums['Sum reads']
ft_genus['Mean relative abundance'] = sums['Mean relative abundance']

ft_genus.to_csv(folder+'files/supplementary_feature_table_genus_with_tax.csv')

```

# Get basic variables info

```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
print('Number of families: ', len(set(md['family_id'].values)))
families = set(md['family_id'].values)
children_counts = []
for family in families:
  children_counts.append(list(md['family_id'].values).count(family))

for a in range(1,6):
  print('Families with '+str(a)+' children: '+str(children_counts.count(a)))
  
print('\n')

print('Median age: ', np.median(md['age'].values))
print('Mean age: ', np.mean(md['age'].values))
print('Age range: ', min(md['age'].values), '-', max(md['age'].values))

print('\n')

print('Males: ', len(md[md['gender'] == 1]))
print('Females: ', len(md[md['gender'] == 2]))
print('Trans/gender-diverse: ', len(md[md['gender'] == 3]))

print('\n')

print('East Asian: ', len(md[md['ethnicity'] == 'East Asian']))
print('South Asian: ', len(md[md['ethnicity'] == 'South Asian']))
print('White: ', len(md[md['ethnicity'] == 'White']))

print('\n')

print('No reported condition: ', len(md[md['physical_mental_condition'] == 'no_reported_condition']))
print('Physical condition: ', len(md[md['physical_mental_condition'] == 'physical_condition']))
print('Mental condition: ', len(md[md['physical_mental_condition'] == 'mental_condition']))
print('Physical and Mental condition: ', len(md[md['physical_mental_condition'] == 'mental_and_physical']))

print('\n')

hefi_vals = [val for val in list(md['HEFI'].values) if not np.isnan(val)]
print('Participants with HEFI information: ', len(hefi_vals))
print('Median HEFI: ', np.median(hefi_vals))
print('Mean HEFI: ', np.mean(hefi_vals))
print('HEFI range: ', min(hefi_vals), '-', max(hefi_vals))

print('\n')

diet_richness_weekly_vals = [val for val in list(md['diet_richness_weekly'].values) if not np.isnan(val)]
print('Participants with diet_richness_weekly information: ', len(diet_richness_weekly_vals))
print('Median diet_richness_weekly: ', np.median(diet_richness_weekly_vals))
print('Mean diet_richness_weekly: ', np.mean(diet_richness_weekly_vals))
print('diet_richness_weekly range: ', min(diet_richness_weekly_vals), '-', max(diet_richness_weekly_vals))

print('\n')

antibiotics_vals = [val for val in list(md['antibiotics'].values) if not np.isnan(val)]
print('Participants with antibiotics information: ', len(diet_richness_weekly_vals))
print('no: ', len(md[md['antibiotics'] == 'no']))
print('in_the_last_month: ', len(md[md['antibiotics'] == 'in_the_last_month']))

print('\n')

cur_msd_mat_vals = [val for val in list(md['cur_msd_mat'].values) if not np.isnan(val)]
print('Participants with cur_msd_mat information: ', len(cur_msd_mat_vals))
print('Median cur_msd_mat: ', np.median(cur_msd_mat_vals))
print('Mean cur_msd_mat: ', np.mean(cur_msd_mat_vals))
print('cur_msd_mat range: ', min(cur_msd_mat_vals), '-', max(cur_msd_mat_vals))

print('\n')

cur_msd_soc_vals = [val for val in list(md['cur_msd_soc'].values) if not np.isnan(val)]
print('Participants with cur_msd_soc information: ', len(cur_msd_soc_vals))
print('Median cur_msd_soc: ', np.median(cur_msd_soc_vals))
print('Mean cur_msd_soc: ', np.mean(cur_msd_soc_vals))
print('cur_msd_soc range: ', min(cur_msd_soc_vals), '-', max(cur_msd_soc_vals))

print('\n')

print('Information on second parent')
print('Yes: ', len(md[md['parent2'] == 1]))
print('No: ', len(md[md['parent2'] == 0]))

print('\n')

print('Household income')
print('1 (Less than $20,000): ', len(md[md['houseincome'] == 1]))
print('2 ($20,000 to $49,999): ', len(md[md['houseincome'] == 2]))
print('3 ($50,000 to $79,999): ', len(md[md['houseincome'] == 3]))
print('4 ($80,000 to $99,999): ', len(md[md['houseincome'] == 4]))
print('5 ($100,000 to $199,999): ', len(md[md['houseincome'] == 5]))
print('6 (Over $200,000): ', len(md[md['houseincome'] == 6]))

print('\n')

print(md.columns)

next = True
```

# Beta diversity stats

```{R, eval=FALSE}
#vulcan
#conda activate r-phyloseq
#cd SickKids_SfS/analysis_2025
library(vegan)
dm = read.csv("files/beta_diversity/phylo_rpca_distance.csv")
dm_df = as.data.frame(dm)
rownames(dm_df) = dm_df[,1]
dm_df = dm_df[,2:4813]
#dm_df = as.dist(dm_df)

md = read.csv('files/metadata_microbiome_participants_s2pheno.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

md$gender = as.character(md$gender)
md$parent2 = as.character(md$parent2)
md$family_id = as.character(md$family_id)

variables = c("family_id", "gender", "age", "ethnicity", "physical_mental_condition", "cur_msd_soc", "cur_msd_mat", "HEFI", "antibiotics", 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', "strict_diet", "dsq2", "dsq4", "dsq5", "dsq6", "dsq7", "dsq8", "dsq9", "dsq10", "dsq11", "dsq12", "dsq13", "dsq14", "dsq15", "dsq16", "dsq17", "dsq18", "dsq19", "dsq20", "dsq21", "dsq22", "dsq23", "houseincome", "edu_parent1", "parent2", "edu_parent2")
env_variables = c('cur_gta', 'cur_rural', 'cur_ior', 'cur_gmn_max', 'cur_amn_max', 'cur_amn_mean', 'cur_no2_mean', 'cur_pm25_mean', 'cur_omarg_hh', 'cur_omarg_mat', 'cur_omarg_labour', 'cur_omarg_race', 'cur_msd_mat', 'cur_msd_soc', 'birth_gta', 'birth_rural', 'birth_ior', 'birth_gmn_max', 'birth_amn_max', 'birth_amn_mean', 'birth_pm25_mean', 'birth_omarg_hh', 'birth_omarg_mat', 'birth_omarg_labour', 'birth_omarg_race', 'birth_msd_mat', 'birth_msd_soc', 'utero_gta', 'utero_rural', 'utero_ior', 'utero_gmn_max', 'utero_amn_max', 'utero_amn_mean', 'utero_pm25_mean', 'utero_omarg_hh', 'utero_omarg_mat', 'utero_omarg_labour', 'utero_omarg_race', 'utero_msd_mat', 'utero_msd_soc', 'sch_gta', 'sch_rural', 'sch_ior', 'sch_gmn_max', 'sch_amn_max', 'sch_amn_mean', 'sch_pm25_mean', 'sch_omarg_hh', 'sch_omarg_mat', 'sch_omarg_labour', 'sch_omarg_race', 'sch_msd_mat', 'sch_msd_soc')
variables = variables

for (v in 1:length(variables)) {
  print(variables[v])
  variable = variables[v]
  md_red = md[!is.na(md[,variables[v]]),]
  dm_df_red = dm_df[rownames(md_red), rownames(md_red)]
  this_permanova <- adonis2(dm_df_red ~ md_red[,variable], dm_df_red, parallel=12, by="terms", permutations=999, na.action=na.exclude)
  print(this_permanova)
  write.csv(this_permanova, paste("files/beta_stats/permanova_univariate_", variable, ".csv", sep=""))
}

# permanova_basic_added_terms <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition, data=dm_df, parallel=24, by="terms", permutations=999)
# write.csv(permanova_basic_added_terms, 'files/beta_stats/permanova_basic_added_terms.csv')
# 
# permanova_basic_added_null <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition, data=dm_df, parallel=24, by=NULL, permutations=999)
# write.csv(permanova_basic_added_null, 'files/beta_stats/permanova_basic_added_null.csv')
#these two were both tested but unused!

permanova_basic_added_margin <- adonis2(dm_df ~ md$family_id + md$gender + md$age + md$ethnicity + md$physical_mental_condition, data=dm_df, parallel=48, by="margin", permutations=999)
write.csv(permanova_basic_added_margin, 'files/beta_stats/permanova_basic_added_margin.csv')

permanova_basic_added_margin <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition + md$family_id, data=dm_df, parallel=48, by="margin", permutations=999)
write.csv(permanova_basic_added_margin, 'files/beta_stats/permanova_basic_added_margin_flip.csv')

permanova_basic_added_margin <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition, data=dm_df, parallel=48, by="margin", permutations=999, strata=md$family_id)
write.csv(permanova_basic_added_margin, 'files/beta_stats/permanova_basic_added_margin_strata.csv')

permanova_deprivation_added_margin <- adonis2(dm_df ~ md$family_id + md$gender + md$age + md$ethnicity + md$physical_mental_condition + md$cur_msd_mat + md$cur_msd_soc, data=dm_df, parallel=48, by="margin", permutations=999, na.action=na.exclude)
write.csv(permanova_deprivation_added_margin, 'files/beta_stats/permanova_deprivation_added_margin.csv')

md_dep = md[, c("gender", "age", "ethnicity", "physical_mental_condition", "cur_msd_mat", "cur_msd_soc", "family_id")]
md_dep = md_dep[complete.cases(md_dep),]

new_list <- c()
for (i in 1:length(rownames(md_dep))) {
  if (rownames(md_dep)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md_dep)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md_dep = md_dep[new_list,]

permanova_deprivation_added_margin <- adonis2(dm_df ~ md_dep$gender + md_dep$age + md_dep$ethnicity + md_dep$physical_mental_condition + md_dep$cur_msd_mat + md_dep$cur_msd_soc, data=dm_df, strata=md_dep$family_id, parallel=48, by="margin", permutations=999, na.action=na.exclude)
write.csv(permanova_deprivation_added_margin, 'files/beta_stats/permanova_deprivation_added_margin_strata.csv')

#####

#single child from family only

dm_df = as.data.frame(dm)
rownames(dm_df) = dm_df[,1]
dm_df = dm_df[,2:4813]

md = read.csv('files/metadata_microbiome_participants_single_child_from_family.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

md$gender = as.character(md$gender)

permanova_basic_added_margin <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition, data=dm_df, parallel=48, by="margin", permutations=999)
write.csv(permanova_basic_added_margin, 'files/beta_stats/permanova_basic_added_margin_single_child_from_family.csv')

#####

#two child families

dm_df = as.data.frame(dm)
rownames(dm_df) = dm_df[,1]
dm_df = dm_df[,2:4813]

md = read.csv('files/metadata_microbiome_participants_two_child_families.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

md$gender = as.character(md$gender)
md$family_id = as.character(md$family_id)

permanova_basic_added_margin <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition + md$family_id, data=dm_df, parallel=48, by="margin", permutations=999)
write.csv(permanova_basic_added_margin, 'files/beta_stats/permanova_basic_added_margin_two_child_families.csv')

#two child families with shuffled family ID

dm_df = as.data.frame(dm)
rownames(dm_df) = dm_df[,1]
dm_df = dm_df[,2:4813]

md = read.csv('files/metadata_microbiome_participants_two_child_families_shuffled_family_id.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

md$gender = as.character(md$gender)
md$family_id = as.character(md$family_id)

permanova_basic_added_margin <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition + md$family_id, data=dm_df, parallel=48, by="margin", permutations=999)
write.csv(permanova_basic_added_margin, 'files/beta_stats/permanova_basic_added_margin_two_child_families_shuffled_family_id.csv')

#####

#families (no individuals)

dm_df = as.data.frame(dm)
rownames(dm_df) = dm_df[,1]
dm_df = dm_df[,2:4813]

md = read.csv('files/metadata_microbiome_participants_no_individual_family.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

md$gender = as.character(md$gender)
md$family_id = as.character(md$family_id)

permanova_basic_added_margin <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition + md$family_id, data=dm_df, parallel=48, by="margin", permutations=999)
write.csv(permanova_basic_added_margin, 'files/beta_stats/permanova_basic_added_margin_no_individual_family.csv')

#families with shuffled family ID (no individuals)

dm_df = as.data.frame(dm)
rownames(dm_df) = dm_df[,1]
dm_df = dm_df[,2:4813]

md = read.csv('files/metadata_microbiome_participants_no_individual_shuffled_family_id.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

md$gender = as.character(md$gender)
md$family_id = as.character(md$family_id)

permanova_basic_added_margin <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition + md$family_id, data=dm_df, parallel=48, by="margin", permutations=999)
write.csv(permanova_basic_added_margin, 'files/beta_stats/permanova_basic_added_margin_no_individual_shuffled_family_id.csv')

#####

# diet data
dm = read.csv("files/beta_diversity/phylo_rpca_distance.csv")
dm_df = as.data.frame(dm)
rownames(dm_df) = dm_df[,1]
dm_df = dm_df[,2:4813]

md = read.csv('files/metadata_microbiome_participants_full_diet_s2pheno.csv')
rownames(md) = md[,1]

md$gender = as.character(md$gender)
md$parent2 = as.character(md$parent2)
md$family_id = as.character(md$family_id)

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df_diet = dm_df[new_list, new_list]
md = md[new_list,]
md_diet = md

#reduced n
permanova_basic_added_margin <- adonis2(dm_df_diet ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition, data=dm_df, parallel=12, by="margin", permutations=999, strata=md$family_id)
write.csv(permanova_basic_added_margin, 'files/beta_stats/permanova_basic_added_margin_red_participants_diet_data_strata.csv')

md_diet_red = md_diet[, c("family_id", "gender", "age", "ethnicity", "physical_mental_condition", "HEFI", "antibiotics", 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', "strict_diet", "dsq2", "dsq4", "dsq5", "dsq6", "dsq7", "dsq8", "dsq9", "dsq10", "dsq11", "dsq12", "dsq13", "dsq14", "dsq15", "dsq16", "dsq17", "dsq18", "dsq19", "dsq20", "dsq21", "dsq22", "dsq23")]
md_diet_red = md_diet_red[complete.cases(md_diet_red),]

permanova_diet_added_margin <- adonis2(dm_df_diet ~ md_diet_red$gender + md_diet_red$age + md_diet_red$ethnicity + md_diet_red$physical_mental_condition + md_diet_red$HEFI + md_diet_red$antibiotics + md_diet_red$diet_richness_monthly + md_diet_red$diet_richness_weekly + md_diet_red$diet_richness_daily + md_diet_red$strict_diet + md_diet_red$dsq2 + md_diet_red$dsq4 + md_diet_red$dsq5 + md_diet_red$dsq6 + md_diet_red$dsq7 + md_diet_red$dsq8 + md_diet_red$dsq9 + md_diet_red$dsq10 + md_diet_red$dsq11 + md_diet_red$dsq12 + md_diet_red$dsq13 + md_diet_red$dsq14 + md_diet_red$dsq15 + md_diet_red$dsq16 + md_diet_red$dsq17 + md_diet_red$dsq18 + md_diet_red$dsq19 + md_diet_red$dsq20 + md_diet_red$dsq21 + md_diet_red$dsq22 + md_diet_red$dsq23, data=dm_df_diet, parallel=12, by="margin", permutations=999, strata=md_diet_red$family_id)
write.csv(permanova_diet_added_margin, 'files/beta_stats/permanova_diet_added_margin_strata.csv')

permanova_diet_ethnicity_added_margin <- adonis2(dm_df_diet ~ md_diet_red$gender + md_diet_red$age + md_diet_red$ethnicity + md_diet_red$physical_mental_condition + md_diet_red$HEFI + md_diet_red$antibiotics + md_diet_red$diet_richness_monthly + md_diet_red$diet_richness_weekly + md_diet_red$diet_richness_daily + md_diet_red$strict_diet + md_diet_red$dsq2 + md_diet_red$dsq4 + md_diet_red$dsq5 + md_diet_red$dsq6 + md_diet_red$dsq7 + md_diet_red$dsq8 + md_diet_red$dsq9 + md_diet_red$dsq10 + md_diet_red$dsq11 + md_diet_red$dsq12 + md_diet_red$dsq13 + md_diet_red$dsq14 + md_diet_red$dsq15 + md_diet_red$dsq16 + md_diet_red$dsq17 + md_diet_red$dsq18 + md_diet_red$dsq19 + md_diet_red$dsq20 + md_diet_red$dsq21 + md_diet_red$dsq22 + md_diet_red$dsq23 + md_diet_red$HEFI:md_diet_red$ethnicity + md_diet_red$diet_richness_weekly:md_diet_red$ethnicity + md_diet_red$strict_diet:md_diet_red$ethnicity + md_diet_red$dsq2:md_diet_red$ethnicity + md_diet_red$dsq4:md_diet_red$ethnicity + md_diet_red$dsq5:md_diet_red$ethnicity + md_diet_red$dsq6:md_diet_red$ethnicity + md_diet_red$dsq7:md_diet_red$ethnicity + md_diet_red$dsq8:md_diet_red$ethnicity + md_diet_red$dsq9:md_diet_red$ethnicity + md_diet_red$dsq10:md_diet_red$ethnicity + md_diet_red$dsq11:md_diet_red$ethnicity + md_diet_red$dsq12:md_diet_red$ethnicity + md_diet_red$dsq13:md_diet_red$ethnicity + md_diet_red$dsq14:md_diet_red$ethnicity + md_diet_red$dsq15:md_diet_red$ethnicity + md_diet_red$dsq16:md_diet_red$ethnicity + md_diet_red$dsq17:md_diet_red$ethnicity + md_diet_red$dsq18:md_diet_red$ethnicity + md_diet_red$dsq19:md_diet_red$ethnicity + md_diet_red$dsq20:md_diet_red$ethnicity + md_diet_red$dsq21:md_diet_red$ethnicity + md_diet_red$dsq22:md_diet_red$ethnicity + md_diet_red$dsq23:md_diet_red$ethnicity, data=dm_df_diet, parallel=48, by="margin", permutations=999, strata=md_diet_red$family_id)
write.csv(permanova_diet_ethnicity_added_margin, 'files/beta_stats/permanova_diet_ethnicity_added_margin_strata.csv')

md_diet_red_all = md_diet[, c("family_id", "gender", "age", "ethnicity", "physical_mental_condition", "cur_msd_mat", "cur_msd_soc", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "HEFI", "antibiotics", 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', "strict_diet", "dsq2", "dsq4", "dsq5", "dsq6", "dsq7", "dsq8", "dsq9", "dsq10", "dsq11", "dsq12", "dsq13", "dsq14", "dsq15", "dsq16", "dsq17", "dsq18", "dsq19", "dsq20", "dsq21", "dsq22", "dsq23")]
md_diet_red = md_diet_red_all[complete.cases(md_diet_red_all),]

dm_df_diet = dm_df[rownames(md_diet_red), rownames(md_diet_red)]

permanova_all_added_margin <- adonis2(dm_df_diet ~ md_diet_red$gender + md_diet_red$age + md_diet_red$ethnicity + md_diet_red$physical_mental_condition + md_diet_red$cur_msd_mat + md_diet_red$cur_msd_soc + md_diet_red$cur_gta + md_diet_red$cur_ior + md_diet_red$cur_gmn_mean + md_diet_red$cur_pm25_mean + md_diet_red$HEFI + md_diet_red$antibiotics + md_diet_red$diet_richness_monthly + md_diet_red$diet_richness_weekly + md_diet_red$diet_richness_daily + md_diet_red$strict_diet + md_diet_red$dsq2 + md_diet_red$dsq4 + md_diet_red$dsq5 + md_diet_red$dsq6 + md_diet_red$dsq7 + md_diet_red$dsq8 + md_diet_red$dsq9 + md_diet_red$dsq10 + md_diet_red$dsq11 + md_diet_red$dsq12 + md_diet_red$dsq13 + md_diet_red$dsq14 + md_diet_red$dsq15 + md_diet_red$dsq16 + md_diet_red$dsq17 + md_diet_red$dsq18 + md_diet_red$dsq19 + md_diet_red$dsq20 + md_diet_red$dsq21 + md_diet_red$dsq22 + md_diet_red$dsq23, data=dm_df_diet, parallel=12, by="margin", permutations=999, na.action=na.exclude, strata=md_diet_red$family_id)
write.csv(permanova_all_added_margin, 'files/beta_stats/permanova_all_added_margin_strata.csv')

md_no_ab = md_diet_red
md_no_ab <- md_no_ab[md_no_ab$antibiotics != "in_the_last_month", ]
dm_df_no_ab = dm_df[rownames(md_no_ab), rownames(md_no_ab)]

permanova_all_added_margin_no_antibiotics <- adonis2(dm_df_no_ab ~ md_no_ab$gender + md_no_ab$age + md_no_ab$ethnicity + md_no_ab$physical_mental_condition + md_no_ab$cur_msd_mat + md_no_ab$cur_msd_soc +  md_no_ab$cur_gta + md_no_ab$cur_ior + md_no_ab$cur_gmn_mean + md_no_ab$cur_pm25_mean + md_no_ab$HEFI + md_no_ab$diet_richness_monthly + md_no_ab$diet_richness_weekly + md_no_ab$diet_richness_daily + md_no_ab$strict_diet + md_no_ab$dsq2 + md_no_ab$dsq4 + md_no_ab$dsq5 + md_no_ab$dsq6 + md_no_ab$dsq7 + md_no_ab$dsq8 + md_no_ab$dsq9 + md_no_ab$dsq10 + md_no_ab$dsq11 + md_no_ab$dsq12 + md_no_ab$dsq13 + md_no_ab$dsq14 + md_no_ab$dsq15 + md_no_ab$dsq16 + md_no_ab$dsq17 + md_no_ab$dsq18 + md_no_ab$dsq19 + md_no_ab$dsq20 + md_no_ab$dsq21 + md_no_ab$dsq22 + md_no_ab$dsq23, data=dm_df_no_ab, parallel=12, by="margin", permutations=999, na.action=na.exclude, strata=md_no_ab$family_id)
write.csv(permanova_all_added_margin_no_antibiotics, 'files/beta_stats/permanova_all_added_margin_no_antibiotics_strata.csv')

##### environmental variables

dm = read.csv("files/beta_diversity/phylo_rpca_distance.csv")
dm_df = as.data.frame(dm)
rownames(dm_df) = dm_df[,1]
dm_df = dm_df[,2:4813]
#dm_df = as.dist(dm_df)

md = read.csv('files/metadata_microbiome_participants_s2pheno_current_env.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

md$gender = as.character(md$gender)
md$family_id = as.character(md$family_id)

variables = c('cur_gmn_mean')
variables = c('cur_gta', 'cur_ior', 'cur_gmn_mean', 'cur_pm25_mean', 'cur_msd_mat', 'cur_msd_soc')

for (v in 1:length(variables)) {
  print(variables[v])
  variable = variables[v]
  md_red = md[!is.na(md[,variables[v]]),]
  dm_df_red = dm_df[rownames(md_red), rownames(md_red)]
  this_permanova <- adonis2(dm_df_red ~ md_red[,variable], dm_df_red, parallel=12, by="terms", permutations=999, na.action=na.exclude)
  print(this_permanova)
  write.csv(this_permanova, paste("files/beta_stats/permanova_univariate_", variable, ".csv", sep=""))
}

permanova_all_added_margin_cur_env <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition + md$cur_gta + md$cur_ior + md$cur_gmn_mean + md$cur_pm25_mean + md$cur_msd_mat + md$cur_msd_soc, data=dm_df, parallel=48, by="margin", permutations=999, na.action=na.exclude, strata=md$family_id)
print(permanova_all_added_margin_cur_env)
write.csv(permanova_all_added_margin_cur_env, 'files/beta_stats/permanova_all_added_margin_cur_env_strata.csv')

md = read.csv('files/metadata_microbiome_participants_s2pheno_current_env_with_omarg.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

md$gender = as.character(md$gender)
md$family_id = as.character(md$family_id)

variables = c('cur_omarg_mat', 'cur_omarg_labour', 'cur_omarg_race', 'cur_omarg_hh')

for (v in 1:length(variables)) {
  print(variables[v])
  variable = variables[v]
  md_red = md[!is.na(md[,variables[v]]),]
  dm_df_red = dm_df[rownames(md_red), rownames(md_red)]
  this_permanova <- adonis2(dm_df_red ~ md_red[,variable], dm_df_red, parallel=12, by="terms", permutations=999, na.action=na.exclude)
  print(this_permanova)
  write.csv(this_permanova, paste("files/beta_stats/permanova_univariate_", variable, ".csv", sep=""))
}

permanova_all_added_margin_cur_env <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition + md$cur_gta + md$cur_ior + md$cur_gmn_mean + md$cur_pm25_mean + md$cur_omarg_hh +  md$cur_omarg_mat + md$cur_omarg_labour + md$cur_omarg_race, data=dm_df, parallel=48, by="margin", permutations=999, na.action=na.exclude, strata=md$family_id)
write.csv(permanova_all_added_margin_cur_env, 'files/beta_stats/permanova_all_added_margin_cur_env_with_omarg_strata.csv')

dm = read.csv("files/beta_diversity/phylo_rpca_distance.csv")
dm_df = as.data.frame(dm)
rownames(dm_df) = dm_df[,1]
dm_df = dm_df[,2:4813]

md = read.csv('files/metadata_microbiome_participants_s2pheno_current_and_school_env.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

md$gender = as.character(md$gender)
md$family_id = as.character(md$family_id)

variables = c('sch_gta', 'sch_ior', 'sch_gmn_mean', 'sch_pm25_mean', 'sch_msd_mat', 'sch_msd_soc')

for (v in 1:length(variables)) {
  print(variables[v])
  variable = variables[v]
  md_red = md[!is.na(md[,variables[v]]),]
  dm_df_red = dm_df[rownames(md_red), rownames(md_red)]
  this_permanova <- adonis2(dm_df_red ~ md_red[,variable], dm_df_red, parallel=12, by="terms", permutations=999, na.action=na.exclude)
  print(this_permanova)
  write.csv(this_permanova, paste("files/beta_stats/permanova_univariate_", variable, ".csv", sep=""))
}

permanova_all_added_margin_cur_sch_env <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition + md$cur_gta + md$cur_ior + md$cur_gmn_mean + md$cur_pm25_mean + md$cur_msd_mat + md$cur_msd_soc + md$sch_gta + md$sch_ior + md$sch_gmn_mean + md$sch_pm25_mean + md$sch_msd_mat + md$sch_msd_soc, data=dm_df, parallel=24, by="margin", permutations=999, na.action=na.exclude, strata=md$family_id)
print(permanova_all_added_margin_cur_sch_env)
write.csv(permanova_all_added_margin_cur_sch_env, 'files/beta_stats/permanova_all_added_margin_cur_sch_env_strata.csv')

md = read.csv('files/metadata_microbiome_participants_s2pheno_all_env.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

md$gender = as.character(md$gender)
md$family_id = as.character(md$family_id)

variables = c('utero_gta', 'utero_ior', 'utero_gmn_mean', 'utero_pm25_mean', 'utero_msd_mat', 'utero_msd_soc')

for (v in 1:length(variables)) {
  print(variables[v])
  variable = variables[v]
  md_red = md[!is.na(md[,variables[v]]),]
  dm_df_red = dm_df[rownames(md_red), rownames(md_red)]
  this_permanova <- adonis2(dm_df_red ~ md_red[,variable], dm_df_red, parallel=12, by="terms", permutations=999, na.action=na.exclude)
  print(this_permanova)
  write.csv(this_permanova, paste("files/beta_stats/permanova_univariate_", variable, ".csv", sep=""))
}

permanova_all_added_margin_all_env <- adonis2(dm_df ~ md$gender + md$age + md$ethnicity + md$physical_mental_condition + md$cur_gta + md$cur_ior + md$cur_gmn_mean + md$cur_pm25_mean + md$cur_msd_mat + md$cur_msd_soc + md$sch_gta + md$sch_ior + md$sch_gmn_mean + md$sch_pm25_mean + md$sch_msd_mat + md$sch_msd_soc + md$utero_gta + md$utero_ior + md$utero_gmn_mean + md$utero_pm25_mean + md$utero_msd_mat + md$utero_msd_soc, data=dm_df, parallel=48, by="margin", permutations=999, na.action=na.exclude, strata=md$family_id)
print(permanova_all_added_margin_all_env)
write.csv(permanova_all_added_margin_all_env, 'files/beta_stats/permanova_all_added_margin_all_env_strata.csv')
```

Copied all of these across to my laptop.

Now summarise:
```{python}
variables = ["family_id", "family_id_shuffled", "gender", "age", "ethnicity", "physical_mental_condition", "cur_msd_soc", "cur_msd_mat", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "cur_omarg_hh", "cur_omarg_mat", "cur_omarg_labour", "cur_omarg_race", "houseincome", "parent2", "HEFI", "antibiotics", 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', "strict_diet", "dsq2", "dsq4", "dsq5", "dsq6", "dsq7", "dsq8", "dsq9", "dsq10", "dsq11", "dsq12", "dsq13", "dsq14", "dsq15", "dsq16", "dsq17", "dsq18", "dsq19", "dsq20", "dsq21", "dsq22", "dsq23", "sch_msd_soc", "sch_msd_mat", "sch_gta", "sch_ior", "sch_gmn_mean", "sch_pm25_mean", "utero_msd_soc", "utero_msd_mat", "utero_gta", "utero_ior", "utero_gmn_mean", "utero_pm25_mean"]

all_vals = {}
for v in range(len(variables)):
  try:
    this_df = pd.read_csv(folder+'files/beta_stats/permanova_univariate_'+variables[v]+'.csv', index_col=0, header=0)
    all_vals[variables[v]] = [this_df.iloc[0,2], this_df.iloc[0,4]]
  except:
    all_vals[variables[v]] = ['NA', 'NA']

for name in ['basic', 'basic_with_id', 'basic_single_child', 'basic_no_individual', 'basic_no_individual_shuffled', 'basic_two_child_family', 'basic_two_child_family_shuffled', 'deprivation', 'diet', 'diet_red', 'all', 'no_antibiotics', 'cur_env', 'cur_env_with_omarg', 'cur_sch_env', 'all_env']:
  if name == 'basic_with_id':
    this_df = pd.read_csv(folder+'files/beta_stats/permanova_basic_added_margin.csv', index_col=0, header=0)
  elif name == 'basic_single_child':
    this_df = pd.read_csv(folder+'files/beta_stats/permanova_basic_added_margin_single_child_from_family.csv', index_col=0, header=0)
  elif name == 'basic_two_child_family':
    this_df = pd.read_csv(folder+'files/beta_stats/permanova_basic_added_margin_two_child_families.csv', index_col=0, header=0)
  elif name == 'basic_two_child_family_shuffled':
    this_df = pd.read_csv(folder+'files/beta_stats/permanova_basic_added_margin_two_child_families_shuffled_family_id.csv', index_col=0, header=0)
  elif name == 'basic_no_individual':
    this_df = pd.read_csv(folder+'files/beta_stats/permanova_basic_added_margin_no_individual_family.csv', index_col=0, header=0)
  elif name == 'basic_no_individual_shuffled':
    this_df = pd.read_csv(folder+'files/beta_stats/permanova_basic_added_margin_no_individual_shuffled_family_id.csv', index_col=0, header=0)
  elif name == 'no_antibiotics':
    this_df = pd.read_csv(folder+'files/beta_stats/permanova_all_added_margin_no_antibiotics_strata.csv', index_col=0, header=0)
  elif name == 'diet_red':
    this_df = pd.read_csv(folder+'files/beta_stats/permanova_basic_added_margin_red_participants_diet_data_strata.csv', index_col=0, header=0)
  elif name in ['cur_env', 'cur_env_with_omarg', 'cur_sch_env', 'all_env']:
    this_df = pd.read_csv(folder+'files/beta_stats/permanova_all_added_margin_'+name+'_strata.csv', index_col=0, header=0)
  else:
    this_df = pd.read_csv(folder+'files/beta_stats/permanova_'+name+'_added_margin_strata.csv', index_col=0, header=0)
  rename = {}
  for row in this_df.index.values:
    if name in ['basic_two_child_family_shuffled', 'basic_no_individual_shuffled']:
      rename[row] = row.replace('md$', '').replace('md_diet$', '').replace('md_diet_red$', '').replace('md_no_ab$', '').replace('md_dep$', '').replace('family_id', 'family_id_shuffled')
    else:
      rename[row] = row.replace('md$', '').replace('md_diet$', '').replace('md_diet_red$', '').replace('md_no_ab$', '').replace('md_dep$', '')
  this_df = this_df.rename(index=rename)
  for variable in variables:
    try:
      all_vals[variable].append(this_df.loc[variable, 'R2'])
      all_vals[variable].append(this_df.loc[variable, 'Pr(>F)'])
    except:
      all_vals[variable].append('NA')
      all_vals[variable].append('NA')
      
all_vals_df = pd.DataFrame(all_vals, index=['Univariate R2', 'Univariate p', 'Basic strata R2', 'Basic strata p', 'Basic with family ID R2', 'Basic with family ID p', 'Basic single child R2', 'Basic single child p', 'Basic no individual child families R2', 'Basic no individual child families p', 'Basic no individual child families ID shuffled R2', 'Basic no individual child families ID shuffled p', 'Basic two child families R2', 'Basic two child families p', 'Basic two child families ID shuffled R2', 'Basic two child families ID shuffled p', 'Deprivation R2', 'Deprivation p', 'Diet R2', 'Diet p', 'Diet reduced basic R2', 'Diet reduced basic p', 'All R2', 'All p', 'No antibiotics R2', 'No antibiotics p', 'Environment R2', 'Environment p', 'Environment OMARG R2', 'Environment OMARG p', 'Environment current school R2', 'Environment current school p', 'Environment all R2', 'Environment all p'])
all_vals_df = all_vals_df.transpose()
all_vals_df.to_csv(folder+'files/beta_stats/permanova_summary.csv')
```

# Alpha diversity stats

Prepare files for stats:
```{python}
metrics = ['chao1','faith_pd','observed_otus','shannon','simpson','simpson_e']
md = pd.read_csv(folder+'files/metadata_microbiome_participants_s2pheno.csv', index_col=0, header=0)
alpha_dfs = []

for metric in metrics:
  alpha = pd.read_csv(folder+'files/alpha_diversity/alpha_'+metric+'.csv', index_col=0, header=0).loc[:, ['Mean']].rename(columns={'Mean':'Diversity'})
  md_red = md.copy(deep=True).loc[alpha.index, ["family_id", "gender", "age", "ethnicity", "physical_mental_condition", "cur_msd_soc", "cur_msd_mat", "houseincome", "parent2", "HEFI", "antibiotics", 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', "strict_diet", "dsq2", "dsq4", "dsq5", "dsq6", "dsq7", "dsq8", "dsq9", "dsq10", "dsq11", "dsq12", "dsq13", "dsq14", "dsq15", "dsq16", "dsq17", "dsq18", "dsq19", "dsq20", "dsq21", "dsq22", "dsq23", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "cur_omarg_hh", "cur_omarg_mat", "cur_omarg_labour", "cur_omarg_race", "sch_msd_soc", "sch_msd_mat", "sch_gta", "sch_ior", "sch_gmn_mean", "sch_pm25_mean", "utero_msd_soc", "utero_msd_mat", "utero_gta", "utero_ior", "utero_gmn_mean", "utero_pm25_mean"]]
  md_red['Diversity'] = alpha.loc[md_red.index.values, 'Diversity']
  alpha_dfs.append(md_red)
  md_red.to_csv(folder+'intermediate/stats_testing_'+metric+'.csv')
  
  md_no_ab = md_red[md_red['antibiotics'] == 'no']
  md_no_ab.to_csv(folder+'intermediate/stats_testing_'+metric+'_no_antibiotics.csv')

finished = True
```

R stats tests:
```{R}
metrics = c('chao1','faith_pd','observed_otus','shannon','simpson','simpson_e')

variables = c("family_id", "gender", "age", "ethnicity", "physical_mental_condition", "cur_msd_soc", "cur_msd_mat", "houseincome", "parent2", "HEFI", "antibiotics", 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', "strict_diet", "dsq2", "dsq4", "dsq5", "dsq6", "dsq7", "dsq8", "dsq9", "dsq10", "dsq11", "dsq12", "dsq13", "dsq14", "dsq15", "dsq16", "dsq17", "dsq18", "dsq19", "dsq20", "dsq21", "dsq22", "dsq23", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "cur_omarg_hh", "cur_omarg_mat", "cur_omarg_labour", "cur_omarg_race", "sch_msd_soc", "sch_msd_mat", "sch_gta", "sch_ior", "sch_gmn_mean", "sch_pm25_mean", "utero_msd_soc", "utero_msd_mat", "utero_gta", "utero_ior", "utero_gmn_mean", "utero_pm25_mean")
variables = c("sch_msd_soc", "sch_msd_mat", "sch_gta", "sch_ior", "sch_gmn_mean", "sch_pm25_mean", "utero_msd_soc", "utero_msd_mat", "utero_gta", "utero_ior", "utero_gmn_mean", "utero_pm25_mean")

for (i in 1:length(metrics)) {
    print(metrics[i])
    # table = alpha_dfs[[i]]
    table = read.csv(paste(py$folder, "intermediate/stats_testing_", metrics[i], ".csv", sep=""))
    table_no_ab = read.csv(paste(py$folder, "intermediate/stats_testing_", metrics[i], "_no_antibiotics.csv", sep=""))
    table$gender = as.character(table$gender)
    table$family_id = as.character(table$family_id)
    table_no_ab$gender = as.character(table_no_ab$gender)
    table_no_ab$family_id = as.character(table_no_ab$family_id)
    for (v in 1:length(variables)) {
      variable = variables[v]
      formula <- as.formula(paste("Diversity ~", variable))
      mod = aov(formula, data=table)
      aov_summary <- summary(mod)
      aov_table <- as.data.frame(aov_summary[[1]])
      write.csv(aov_table, file=paste(py$folder, "files/alpha_stats/", metrics[i], "_univariate_", variable, ".csv", sep=""), row.names = TRUE)
      if (variables[v] %in% c("gender", "ethnicity", "strict_diet")) {
        posthoc_res = TukeyHSD(mod, variable)
        posthoc_res = as.data.frame(posthoc_res[[1]])
        write.csv(posthoc_res, file=paste(py$folder, "files/alpha_stats/", metrics[i], "_univariate_", variable, "_posthoc.csv", sep=""), row.names = TRUE)
      }
    }
#     basic = aov(Diversity ~ gender + age + ethnicity + physical_mental_condition + Error(family_id), data=table)
#     # aov_summary <- summary(basic)
#     # aov_table <- as.data.frame(aov_summary[[1]])
#     # write.csv(aov_table, file=paste(py$folder, "files/alpha_stats/", metrics[i], "_basic.csv", sep=""), row.names = TRUE)
#     tidy_aov_df <- tidy(basic)
#     write.csv(tidy_aov_df, file=paste(py$folder, "files/alpha_stats/", metrics[i], "_basic.csv", sep=""), row.names = TRUE)
#     basic = aov(Diversity ~ gender + age + ethnicity + physical_mental_condition, data=table)
#     posthoc_ethnicity = TukeyHSD(basic, "ethnicity")
#     posthoc_gender = TukeyHSD(basic, "gender")
#     posthoc_ethnicity <- as.data.frame(posthoc_ethnicity$ethnicity)
#     posthoc_gender <- as.data.frame(posthoc_gender$gender)
#     write.csv(posthoc_ethnicity, file=paste(py$folder, "files/alpha_stats/", metrics[i], "_basic_posthoc_ethnicity.csv", sep=""), row.names = TRUE)
#     write.csv(posthoc_gender, file=paste(py$folder, "files/alpha_stats/", metrics[i], "_basic_posthoc_gender.csv", sep=""), row.names = TRUE)
#     
# ?aov
#     
    # dep_red = table[, c("Diversity", "gender", "age", "ethnicity", "physical_mental_condition", "cur_msd_soc", "cur_msd_mat", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "family_id")]
    # dep_red = table[complete.cases(dep_red),]
    # deprivation = aov(Diversity ~ gender + age + ethnicity + physical_mental_condition + cur_msd_soc + cur_msd_mat + cur_gta + cur_ior + cur_gmn_mean + cur_pm25_mean + Error(family_id), data=dep_red)
    # # aov_summary <- summary(deprivation)
    # # aov_table <- as.data.frame(aov_summary[[1]])
    # tidy_aov_df <- tidy(deprivation)
    # write.csv(tidy_aov_df, file=paste(py$folder, "files/alpha_stats/", metrics[i], "_deprivation.csv", sep=""), row.names = TRUE)
    
    dep_red_all = table[, c("Diversity", "gender", "age", "ethnicity", "physical_mental_condition", "cur_msd_soc", "cur_msd_mat", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "sch_msd_soc", "sch_msd_mat", "sch_gta", "sch_ior", "sch_gmn_mean", "sch_pm25_mean", "utero_msd_soc", "utero_msd_mat", "utero_gta", "utero_ior", "utero_gmn_mean", "utero_pm25_mean", "family_id")]
    dep_red_all = table[complete.cases(dep_red_all),]
    deprivation_all = aov(Diversity ~ gender + age + ethnicity + physical_mental_condition + cur_msd_soc + cur_msd_mat + cur_gta + cur_ior + cur_gmn_mean + cur_pm25_mean + sch_msd_soc + sch_msd_mat + sch_gta + sch_ior + sch_gmn_mean + sch_pm25_mean + utero_msd_soc + utero_msd_mat + utero_gta + utero_ior + utero_gmn_mean + utero_pm25_mean + Error(family_id), data=dep_red_all)
    # aov_summary <- summary(deprivation)
    # aov_table <- as.data.frame(aov_summary[[1]])
    tidy_aov_df <- tidy(deprivation_all)
    write.csv(tidy_aov_df, file=paste(py$folder, "files/alpha_stats/", metrics[i], "_deprivation_all.csv", sep=""), row.names = TRUE)
    
    # dep_omarg_red = table[, c("Diversity", "gender", "age", "ethnicity", "physical_mental_condition", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "cur_omarg_hh", "cur_omarg_mat", "cur_omarg_labour", "cur_omarg_race", "family_id")]
    # dep_omarg_red = table[complete.cases(dep_omarg_red),]
    # deprivation_omarg = aov(Diversity ~ gender + age + ethnicity + physical_mental_condition + cur_omarg_hh + cur_omarg_mat + cur_omarg_labour + cur_omarg_race + cur_gta + cur_ior + cur_gmn_mean + cur_pm25_mean + Error(family_id), data=dep_omarg_red)
    # # aov_summary <- summary(deprivation)
    # # aov_table <- as.data.frame(aov_summary[[1]])
    # tidy_aov_df <- tidy(deprivation_omarg)
    # write.csv(tidy_aov_df, file=paste(py$folder, "files/alpha_stats/", metrics[i], "_deprivation_omarg.csv", sep=""), row.names = TRUE)
    
    # diet_red = table[, c("Diversity", "gender", "age", "ethnicity", "physical_mental_condition", "family_id", "HEFI", "antibiotics", 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', "strict_diet", "dsq2", "dsq4", "dsq5", "dsq6", "dsq7", "dsq8", "dsq9", "dsq10", "dsq11", "dsq12", "dsq13", "dsq14", "dsq15", "dsq16", "dsq17", "dsq18", "dsq19", "dsq20", "dsq21", "dsq22", "dsq23")]
    # diet_red = table[complete.cases(diet_red),]
    # diet = aov(Diversity ~ gender + age + ethnicity + physical_mental_condition + HEFI + antibiotics + diet_richness_monthly + diet_richness_weekly + diet_richness_daily + strict_diet + dsq2 + dsq4 + dsq5 + dsq6 + dsq7 + dsq8 + dsq9 + dsq10 + dsq11 + dsq12 + dsq13 + dsq14 + dsq15 + dsq16 + dsq17 + dsq18 + dsq19 + dsq20 + dsq21 + dsq22 + dsq23 + Error(family_id), data=diet_red)
    # # aov_summary <- summary(diet)
    # # aov_table <- as.data.frame(aov_summary[[1]])
    # tidy_aov_df <- tidy(diet)
    # write.csv(tidy_aov_df, file=paste(py$folder, "files/alpha_stats/", metrics[i], "_diet.csv", sep=""), row.names = TRUE)
    
    # all_red = table[, c("Diversity", "gender", "age", "ethnicity", "physical_mental_condition", "family_id", "cur_msd_soc", "cur_msd_mat", "HEFI", "antibiotics", 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', "strict_diet", "dsq2", "dsq4", "dsq5", "dsq6", "dsq7", "dsq8", "dsq9", "dsq10", "dsq11", "dsq12", "dsq13", "dsq14", "dsq15", "dsq16", "dsq17", "dsq18", "dsq19", "dsq20", "dsq21", "dsq22", "dsq23", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean")]
    # all_red = table[complete.cases(all_red),]
    # all = aov(Diversity ~ gender + age + ethnicity + physical_mental_condition + cur_msd_soc + cur_msd_mat + cur_gta + cur_ior + cur_gmn_mean + cur_pm25_mean + HEFI + antibiotics + diet_richness_monthly + diet_richness_weekly + diet_richness_daily + strict_diet + dsq2 + dsq4 + dsq5 + dsq6 + dsq7 + dsq8 + dsq9 + dsq10 + dsq11 + dsq12 + dsq13 + dsq14 + dsq15 + dsq16 + dsq17 + dsq18 + dsq19 + dsq20 + dsq21 + dsq22 + dsq23 + Error(family_id), data=all_red)
    # # aov_summary <- summary(all)
    # # aov_table <- as.data.frame(aov_summary[[1]])
    # tidy_aov_df <- tidy(all)
    # write.csv(tidy_aov_df, file=paste(py$folder, "files/alpha_stats/", metrics[i], "_all.csv", sep=""), row.names = TRUE)
    
    # all_no_ab_red = table_no_ab[, c("Diversity", "gender", "age", "ethnicity", "physical_mental_condition", "family_id", "cur_msd_soc", "cur_msd_mat", "HEFI", 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', "strict_diet", "dsq2", "dsq4", "dsq5", "dsq6", "dsq7", "dsq8", "dsq9", "dsq10", "dsq11", "dsq12", "dsq13", "dsq14", "dsq15", "dsq16", "dsq17", "dsq18", "dsq19", "dsq20", "dsq21", "dsq22", "dsq23", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean")]
    # all_no_ab_red = table_no_ab[complete.cases(all_no_ab_red),]
    # all_no_ab = aov(Diversity ~ gender + age + ethnicity + physical_mental_condition + cur_msd_soc + cur_msd_mat + cur_gta + cur_ior + cur_gmn_mean + cur_pm25_mean + HEFI + diet_richness_monthly + diet_richness_weekly + diet_richness_daily + strict_diet + dsq2 + dsq4 + dsq5 + dsq6 + dsq7 + dsq8 + dsq9 + dsq10 + dsq11 + dsq12 + dsq13 + dsq14 + dsq15 + dsq16 + dsq17 + dsq18 + dsq19 + dsq20 + dsq21 + dsq22 + dsq23 + Error(family_id), data=all_no_ab_red)
    # # aov_summary <- summary(all_no_ab)
    # # aov_table <- as.data.frame(aov_summary[[1]])
    # tidy_aov_df <- tidy(all_no_ab)
    # write.csv(tidy_aov_df, file=paste(py$folder, "files/alpha_stats/", metrics[i], "_all_no_antibiotics.csv", sep=""), row.names = TRUE)

}
```

Collate results:
```{python}
metrics = ['chao1','faith_pd','observed_otus','shannon','simpson','simpson_e']
variables = [ "gender", "age", "ethnicity", "physical_mental_condition", "cur_msd_soc", "cur_msd_mat", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "cur_omarg_hh", "cur_omarg_mat", "cur_omarg_labour", "cur_omarg_race", "houseincome", "parent2", "HEFI", "antibiotics", 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', "strict_diet", "dsq2", "dsq4", "dsq5", "dsq6", "dsq7", "dsq8", "dsq9", "dsq10", "dsq11", "dsq12", "dsq13", "dsq14", "dsq15", "dsq16", "dsq17", "dsq18", "dsq19", "dsq20", "dsq21", "dsq22", "dsq23", "sch_msd_soc", "sch_msd_mat", "sch_gta", "sch_ior", "sch_gmn_mean", "sch_pm25_mean", "utero_msd_soc", "utero_msd_mat", "utero_gta", "utero_ior", "utero_gmn_mean", "utero_pm25_mean"]

for i in range(len(metrics)):
  #if i > 0: continue
  all_vals = {}
  for v in range(len(variables)):
    # if v > 0: continue
    this_df = pd.read_csv(folder+'files/alpha_stats/'+metrics[i]+'_univariate_'+variables[v]+'.csv', index_col=0, header=0) 
    all_vals[variables[v]] = [this_df.iloc[0,3], this_df.iloc[0,4]]
  for name in ['basic', 'deprivation', 'deprivation_omarg', 'deprivation_all', 'diet', 'all', 'all_no_antibiotics']:
    this_df = pd.read_csv(folder+'files/alpha_stats/'+metrics[i]+'_'+name+'.csv', index_col=0, header=0)
    this_df = this_df[this_df['stratum'] == 'family_id']
    this_df = this_df.set_index('term')
    rename = {}
    for row in this_df.index.values:
      rename[row] = row.rstrip()
    this_df = this_df.rename(index=rename)
    for variable in variables:
      try:
        all_vals[variable].append(this_df.loc[variable, 'statistic'])
        all_vals[variable].append(this_df.loc[variable, 'p.value'])
      except:
        all_vals[variable].append('NA')
        all_vals[variable].append('NA')
  all_vals_df = pd.DataFrame(all_vals, index=['Univariate F', 'Univariate p', 'Basic F', 'Basic p', 'Environment F', 'Environment p', 'Environment OMARG F', 'Environment OMARG p', 'Environment all F', 'Environment all p', 'Diet F', 'Diet p', 'All F', 'All p', 'All no antibiotics F', 'All no antibiotics p'])
  all_vals_df = all_vals_df.transpose()
  all_vals_df.to_csv(folder+'files/alpha_stats/'+metrics[i]+'_summary.csv')
  
```

# Diet stats

## ANOVA tests with each diet variable

```{R}
md = read.csv(paste(py$folder, 'files/metadata_microbiome_participants_full_diet.csv', sep=''))

md$gender = as.character(md$gender)
md$family_id = as.character(md$family_id)

variables = c("HEFI", 'diet_richness_weekly', "dsq2", "dsq4", "dsq5", "dsq6", "dsq7", "dsq8", "dsq9", "dsq10", "dsq11", "dsq12", "dsq13", "dsq14", "dsq15", "dsq16", "dsq17", "dsq18", "dsq19", "dsq20", "dsq21", "dsq22", "dsq23")

for (i in 1:length(variables)) {
    variable = variables[i]
    formula <- as.formula(paste(variable, "~ gender + age + ethnicity + physical_mental_condition + Error(family_id)"))
    basic = aov(formula, data=md)
    # aov_summary <- summary(basic)
    # aov_table <- as.data.frame(aov_summary[[1]])
    tidy_aov_df <- tidy(basic)
    write.csv(tidy_aov_df, file=paste(py$folder, "files/alpha_stats/diet_", variables[i], ".csv", sep=""), row.names = TRUE)
    
}

?TukeyHSD
print(basic)


```

Summarise:
```{python}
variables = ["HEFI", 'diet_richness_weekly', "dsq2", "dsq4", "dsq5", "dsq6", "dsq7", "dsq8", "dsq9", "dsq10", "dsq11", "dsq12", "dsq13", "dsq14", "dsq15", "dsq16", "dsq17", "dsq18", "dsq19", "dsq20", "dsq21", "dsq22", "dsq23"]

all_vals = []
for variable in variables:
  diet_stats = pd.read_csv(folder+'files/alpha_stats/diet_'+variable+'.csv', index_col=0, header=0)
  diet_stats = diet_stats[diet_stats['stratum'] == 'family_id']
  diet_stats = diet_stats.set_index('term')
  all_vals.append(diet_stats.loc[:, ['statistic', 'p.value']].rename(columns={'statistic':variable+' F', 'p.value':variable+' p'}))

all_vals = pd.concat(all_vals).fillna(value=0)
all_vals = all_vals.groupby(by=all_vals.index, axis=0).sum()
#all_vals = all_vals.loc[['ethnicity', 'age', 'gender', 'physical_mental_condition'], :]
columns = {}
for col in all_vals.index.values:
  columns[col] = col.rstrip()
all_vals = all_vals.rename(index=columns)
all_vals = all_vals.drop('Residuals', axis=0)
all_vals.to_csv(folder+'files/alpha_stats/diet_summary.csv')
```

# Differential abundance

Copied across genus table to vulcan.

Read in data:
```{R, eval=FALSE}
#conda activate r-4.4.1 # - Maaslin3
#conda activate r-phyloseq # - ALDEx2
ft = read.csv("files/feature_table_genus.csv", header= TRUE, row.names = 1, stringsAsFactors = FALSE)
md = read.csv("files/metadata_microbiome_participants.csv", header= TRUE, row.names = 1, stringsAsFactors = FALSE)
# ft = read.csv(paste(py$folder, "files/feature_table_genus.csv", sep=""), header= TRUE, row.names = 1, stringsAsFactors = FALSE)
# md = read.csv(paste(py$folder, "files/metadata_microbiome_participants.csv", sep=""), header= TRUE, row.names = 1, stringsAsFactors = FALSE)

md$gender <- factor(md$gender,
                 levels = c(1, 2, 3),
                 labels = c("Male", "Female", "Other"))
md$physical_mental_condition <- relevel(as.factor(md$physical_mental_condition), ref = "no_reported_condition")
md$ethnicity <- factor(md$ethnicity, levels=c("White", "South Asian", "East Asian"))
md$family_id = as.character(md$family_id)
```

Run MaAsLin3:
```{R}
library(maaslin3)

md = md[colnames(ft),]

sample_sums = colSums(ft)
md$read_depth = sample_sums

md$antibiotics <- factor(md$antibiotics, levels=c("no", "in_the_last_month"))
md$strict_diet <- factor(md$strict_diet, levels=c("omnivore", "vegan", "vegetarian"))

set.seed(1)

fit_out <- maaslin3(input_data = ft,
                    input_metadata = md,
                    output = 'differential_abundance/maaslin3_basic_added',
                    formula = '~ group(gender) + age + group(ethnicity) + physical_mental_condition + read_depth',
                    strata_effects = 'family_id',
                    normalization = 'TSS',
                    transform = 'LOG',
                    augment = TRUE,
                    standardize = TRUE,
                    max_significance = 0.1,
                    median_comparison_abundance = TRUE,
                    median_comparison_prevalence = TRUE,
                    max_pngs = 250,
                    cores = 12)

fit_out <- maaslin3(input_data = ft,
                    input_metadata = md,
                    output = 'differential_abundance/maaslin3_deprivation_added',
                    formula = '~ group(gender) + age + group(ethnicity) + physical_mental_condition + cur_msd_soc + cur_msd_mat + read_depth',
                    strata_effects = 'family_id',
                    normalization = 'TSS',
                    transform = 'LOG',
                    augment = TRUE,
                    standardize = TRUE,
                    max_significance = 0.1,
                    median_comparison_abundance = TRUE,
                    median_comparison_prevalence = TRUE,
                    max_pngs = 250,
                    cores = 12)

fit_out <- maaslin3(input_data = ft,
                    input_metadata = md,
                    output = 'differential_abundance/maaslin3_diet_added',
                    formula = '~ group(gender) + age + group(ethnicity) + physical_mental_condition + HEFI + antibiotics + diet_richness_monthly + diet_richness_weekly + diet_richness_daily + group(strict_diet) + dsq2 + dsq4 + dsq5 + dsq6 + dsq7 + dsq8 + dsq9 + dsq10 + dsq11 + dsq12 + dsq13 + dsq14 + dsq15 + dsq16 + dsq17 + dsq18 + dsq19 + dsq20 + dsq21 + dsq22 + dsq23 + read_depth',
                    strata_effects = 'family_id',
                    normalization = 'TSS',
                    transform = 'LOG',
                    augment = TRUE,
                    standardize = TRUE,
                    max_significance = 0.1,
                    median_comparison_abundance = TRUE,
                    median_comparison_prevalence = TRUE,
                    max_pngs = 250,
                    cores = 12)

variables = c('HEFI', 'antibiotics', 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', 'cur_msd_soc', 'cur_msd_mat', 'strict_diet', 'dsq2', 'dsq4', 'dsq5', 'dsq6', 'dsq7', 'dsq8', 'dsq9', 'dsq10', 'dsq11', 'dsq12', 'dsq13', 'dsq14', 'dsq15', 'dsq16', 'dsq17', 'dsq18', 'dsq19', 'dsq20', 'dsq21', 'dsq22', 'dsq23')

#'HEFI', 'antibiotics', 
#'#need to do reference variable for antibiotics
#'#Please provide the reference for the variable 'antibiotics' which includes more than 2 levels: , in_the_last_month, no. Alternatively, set the variable as
                        # a factor beforehand.

for (v in 1:length(variables)) {
  print(variables[v])
  md_red = md[!is.na(md[,variables[v]]),]
  print(length(rownames(md_red)))
  group = variables[v]
  if (group == 'strict_diet') {
    group = 'group(strict_diet)'
  }
  fit_out <- maaslin3(input_data = ft,
                    input_metadata = md_red,
                    output = paste('differential_abundance/maaslin3_', variables[v], '_added', sep=""),
                    formula = paste('~ group(gender) + age + group(ethnicity) + physical_mental_condition + ', group, ' + read_depth', sep=""),
                    strata_effects = 'family_id',
                    normalization = 'TSS',
                    transform = 'LOG',
                    augment = TRUE,
                    standardize = TRUE,
                    max_significance = 0.1,
                    median_comparison_abundance = TRUE,
                    median_comparison_prevalence = TRUE,
                    max_pngs = 250,
                    cores = 12)
}

md = read.csv("files/metadata_microbiome_participants_s2pheno_current_env.csv", header= TRUE, row.names = 1, stringsAsFactors = FALSE)

md$gender <- factor(md$gender,
                 levels = c(1, 2, 3),
                 labels = c("Male", "Female", "Other"))
md$physical_mental_condition <- relevel(as.factor(md$physical_mental_condition), ref = "no_reported_condition")
md$ethnicity <- factor(md$ethnicity, levels=c("White", "South Asian", "East Asian"))
md$family_id = as.character(md$family_id)

ft = ft[, rownames(md)]

sample_sums = colSums(ft)
md$read_depth = sample_sums

variables = c('cur_msd_soc', 'cur_msd_mat', 'cur_gta', 'cur_ior', 'cur_gmn_mean', 'cur_pm25_mean')

for (v in 1:length(variables)) {
  print(variables[v])
  md_red = md[!is.na(md[,variables[v]]),]
  print(length(rownames(md_red)))
  group = variables[v]
  if (group == 'strict_diet') {
    group = 'group(strict_diet)'
  }
  fit_out <- maaslin3(input_data = ft,
                    input_metadata = md_red,
                    output = paste('differential_abundance/maaslin3_', variables[v], '_added', sep=""),
                    formula = paste('~ group(gender) + age + group(ethnicity) + physical_mental_condition + ', group, ' + read_depth', sep=""),
                    strata_effects = 'family_id',
                    normalization = 'TSS',
                    transform = 'LOG',
                    augment = TRUE,
                    standardize = TRUE,
                    max_significance = 0.1,
                    median_comparison_abundance = TRUE,
                    median_comparison_prevalence = TRUE,
                    max_pngs = 250,
                    cores = 48)
}

ft = read.csv("files/feature_table_genus.csv", header= TRUE, row.names = 1, stringsAsFactors = FALSE)
md = read.csv("files/metadata_microbiome_participants_s2pheno.csv", header= TRUE, row.names = 1, stringsAsFactors = FALSE)

md$gender <- factor(md$gender,
                 levels = c(1, 2, 3),
                 labels = c("Male", "Female", "Other"))
md$physical_mental_condition <- relevel(as.factor(md$physical_mental_condition), ref = "no_reported_condition")
md$ethnicity <- factor(md$ethnicity, levels=c("White", "South Asian", "East Asian"))
md$family_id = as.character(md$family_id)

ft = ft[, rownames(md)]

sample_sums = colSums(ft)
md$read_depth = sample_sums

variables = c('cur_omarg_hh', 'cur_omarg_mat', 'cur_omarg_labour', 'cur_omarg_race', 'sch_msd_soc', 'sch_msd_mat', 'sch_gta', 'sch_ior')
variables = c('sch_gmn_mean', 'sch_pm25_mean', 'utero_msd_soc', 'utero_msd_mat', 'utero_gta', 'utero_ior', 'utero_gmn_mean', 'utero_pm25_mean')

for (v in 1:length(variables)) {
  print(variables[v])
  md_red = md[!is.na(md[,variables[v]]),]
  print(length(rownames(md_red)))
  group = variables[v]
  if (group == 'strict_diet') {
    group = 'group(strict_diet)'
  }
  fit_out <- maaslin3(input_data = ft,
                    input_metadata = md_red,
                    output = paste('differential_abundance/maaslin3_', variables[v], '_added', sep=""),
                    formula = paste('~ group(gender) + age + group(ethnicity) + physical_mental_condition + ', group, ' + read_depth', sep=""),
                    strata_effects = 'family_id',
                    normalization = 'TSS',
                    transform = 'LOG',
                    augment = TRUE,
                    standardize = TRUE,
                    max_significance = 0.1,
                    median_comparison_abundance = TRUE,
                    median_comparison_prevalence = TRUE,
                    max_pngs = 250,
                    cores = 48)
}

```

Combine differential abundance results:
```{python}
variables = ['age', 'gender', 'ethnicity', 'physical_mental_condition', 'cur_msd_soc', 'cur_msd_mat', 'HEFI', 'antibiotics', 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', 'strict_diet', 'dsq2', 'dsq4', 'dsq5', 'dsq6', 'dsq7', 'dsq8', 'dsq9', 'dsq10', 'dsq11', 'dsq12', 'dsq13', 'dsq14', 'dsq15', 'dsq16', 'dsq17', 'dsq18', 'dsq19', 'dsq20', 'dsq21', 'dsq22', 'dsq23']
naming = ['basic', 'basic', 'basic', 'basic']

tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
rename_tax = {}
for row in tax.index.values:
  rename_tax[row] = tax.loc[row, 'Genus']
  
#note to self that this is taking the results from maaslin3_basic_added for each of the first 4 metadata variables (age, gender, ethnicity and physical_mental_condition) and from the separate folders for all others. 

# now just using Maaslin3
for v in range(len(variables)):
  if variables[v] == 'physical_mental_condition': 
    maaslin = pd.read_csv(folder+'differential_abundance/maaslin3_'+naming[v]+'_added/all_results.tsv', index_col=0, header=0, sep='\t')
    maaslin = maaslin[maaslin['metadata'] == variables[v]]
    for group in ['physical_condition', 'mental_condition', 'mental_and_physical']:
      maaslin_val = maaslin[maaslin['value'] == group]
      maaslin_val = maaslin_val.loc[:, ['coef', 'qval_individual', 'qval_joint', 'model']]
      maaslin_abundance = maaslin_val[maaslin_val['model'] == 'abundance']
      maaslin_prevalence = maaslin_val[maaslin_val['model'] == 'prevalence']
      maaslin_abundance = maaslin_abundance.rename(columns={'coef':'maaslin_coef_abun', 'qval_individual':'maaslin_qval_abun', 'qval_joint':'maaslin_qval_joint'}).loc[:, ['maaslin_coef_abun', 'maaslin_qval_abun', 'maaslin_qval_joint']]
      maaslin_prevalence = maaslin_prevalence.rename(columns={'coef':'maaslin_coef_prev', 'qval_individual':'maaslin_qval_prev'}).loc[:, ['maaslin_coef_prev', 'maaslin_qval_prev']]
      maaslin_val = maaslin_abundance.join(maaslin_prevalence)
      maaslin_val = maaslin_val.rename(index=rename_tax)
      maaslin_val.to_csv(folder+'differential_abundance/'+variables[v]+'_'+group+'_maaslin.csv')
  if v < 4:
    maaslin = pd.read_csv(folder+'differential_abundance/maaslin3_'+naming[v]+'_added/all_results.tsv', index_col=0, header=0, sep='\t')
  else:
    maaslin = pd.read_csv(folder+'differential_abundance/maaslin3_'+variables[v]+'_added/all_results.tsv', index_col=0, header=0, sep='\t')
  maaslin = maaslin[maaslin['metadata'] == variables[v]]
  maaslin = maaslin.loc[:, ['coef', 'qval_individual', 'qval_joint', 'model']]
  maaslin_abundance = maaslin[maaslin['model'] == 'abundance']
  maaslin_prevalence = maaslin[maaslin['model'] == 'prevalence']
  maaslin_abundance = maaslin_abundance.rename(columns={'coef':'maaslin_coef_abun', 'qval_individual':'maaslin_qval_abun', 'qval_joint':'maaslin_qval_joint'}).loc[:, ['maaslin_coef_abun', 'maaslin_qval_abun', 'maaslin_qval_joint']]
  maaslin_prevalence = maaslin_prevalence.rename(columns={'coef':'maaslin_coef_prev', 'qval_individual':'maaslin_qval_prev'}).loc[:, ['maaslin_coef_prev', 'maaslin_qval_prev']]
  maaslin = maaslin_abundance.join(maaslin_prevalence)
  maaslin = maaslin.rename(index=rename_tax)
  maaslin.to_csv(folder+'differential_abundance/'+variables[v]+'_maaslin.csv')
  
```

Combine all DA:
```{python}
variables = ['age', 'gender', 'ethnicity', 'physical_mental_condition', 'cur_msd_soc', 'cur_msd_mat', 'HEFI', 'antibiotics', 'diet_richness_monthly', 'diet_richness_weekly', 'diet_richness_daily', 'strict_diet', 'dsq2', 'dsq4', 'dsq5', 'dsq6', 'dsq7', 'dsq8', 'dsq9', 'dsq10', 'dsq11', 'dsq12', 'dsq13', 'dsq14', 'dsq15', 'dsq16', 'dsq17', 'dsq18', 'dsq19', 'dsq20', 'dsq21', 'dsq22', 'dsq23']

for variable in variables:
  da = pd.read_csv(folder+'differential_abundance/'+variable+'_maaslin.csv', index_col=0, header=0)
  col_rename = {}
  for col in ['maaslin_coef_abun', 'maaslin_qval_abun', 'maaslin_qval_joint', 'maaslin_coef_prev', 'maaslin_qval_prev']:
    col_rename[col] = variable+' '+col
  da = da.rename(columns=col_rename)
  da = da[~da.index.duplicated()]
  if variable == 'age':
    all_df = da.copy(deep=True)
  else:
    all_df = all_df.join(da)

all_df.to_csv(folder+'differential_abundance/all_da_combined_maaslin.csv')
```

Combine marginalisation DA:
```{python}
metrics1 = ["cur_msd_soc", "cur_msd_mat", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean"]
metrics2 = ["cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "cur_omarg_hh", "cur_omarg_mat", "cur_omarg_labour", "cur_omarg_race"]
metrics3 = ["cur_msd_soc", "cur_msd_mat", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "sch_msd_soc", "sch_msd_mat", "sch_gta", "sch_ior", "sch_gmn_mean", "sch_pm25_mean", "utero_msd_soc", "utero_msd_mat", "utero_gta", "utero_ior", "utero_gmn_mean", "utero_pm25_mean"]
sig_da = []
all_da = []
tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
genus = {}
for row in tax.index.values:
  genus[row] = tax.loc[row, 'Genus']

# metrics, save_name = metrics1, 'maaslin3_env_marg_summary.csv'
# metrics, save_name = metrics2, 'maaslin3_env_omarg_summary.csv'
metrics, save_name = metrics3, 'maaslin3_env_all_summary.csv'

for metric in metrics:
  da_df = pd.read_csv(folder+'differential_abundance/maaslin3_'+metric+'_added/significant_results.tsv', index_col=0, header=0, sep='\t')
  da_df = da_df[da_df['metadata'] == metric]
  da_df = da_df[da_df['model'] == 'abundance']
  da_df = da_df[da_df['qval_individual'] <= 0.1]
  da_df = da_df.rename(index=genus)
  for row in da_df.index.values:
    all_da.append(row)
    sig_da.append([row, metric, da_df.loc[row, 'coef']])

sig_da = pd.DataFrame(sig_da, columns=['Genus', 'Metric', 'Coefficient'])
all_da = list(set(all_da))

count = 0
for metric in metrics:
  da_df = pd.read_csv(folder+'differential_abundance/maaslin3_'+metric+'_added/all_results.tsv', index_col=0, header=0, sep='\t')
  da_df = da_df[da_df['metadata'] == metric]
  da_df = da_df[da_df['model'] == 'abundance']
  da_df = da_df.rename(index=genus)
  da_df = da_df.loc[all_da, ['coef', 'qval_individual']]
  if count == 0:
    table_da = da_df.copy(deep=True).rename(columns={'coef':metric+' coef', 'qval_individual':metric+' qval'})
  else:
    table_da[metric+' coef'] = da_df['coef']
    table_da[metric+' qval'] = da_df['qval_individual']
  count += 1

table_da.to_csv(folder+'differential_abundance/'+save_name)
```

# Overall plot

Entire plot:
```{python}
prop_explain = [0.6386125734929017, 0.3023029246310683, 0.05908450187603021]
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_ordination_pca.csv', index_col=0, header=0)
metrics = ['gender', 'age', 'ethnicity', 'HEFI', 'cur_msd_mat', 'cur_msd_soc', 'antibiotics', 'physical_mental_condition']
permanova = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)

permanova_first = permanova.loc[['gender', 'age', 'ethnicity', 'physical_mental_condition'], :]
permanova_first = permanova_first.sort_values(by=['Univariate R2'], ascending=True)
permanova_second = permanova.loc[[ 'HEFI', 'cur_msd_mat', 'cur_msd_soc', 'antibiotics'], :]
permanova_second = permanova_second.sort_values(by=['Univariate R2'], ascending=True)

rename = {'gender':'Gender', 'ethnicity':'Ethnicity', 'antibiotics':'Antibiotics', 'cur_msd_mat':'Material deprivation', 'cur_msd_soc':'Social deprivation', 'physical_mental_condition':'Physical/mental condition', 'age':'Age', 'diet_richness_weekly':'Diet variety score (weekly)', 'HEFI':'Healthy Eating Index'}

fig = plt.figure(figsize=(15,20))
ax_permanova_1 = plt.subplot2grid((20,10),(0,0), colspan=2, rowspan=3)
ax_permanova_2 = plt.subplot2grid((20,10),(3,0), colspan=2, rowspan=3)
ax_alpha_stats_1 = plt.subplot2grid((20,10),(0,2), colspan=1, rowspan=3)
ax_alpha_stats_2 = plt.subplot2grid((20,10),(3,2), colspan=1, rowspan=3)
ax_metadata_1 = plt.subplot2grid((20,10),(0,3), colspan=7, rowspan=3)
ax_metadata_2 = plt.subplot2grid((20,10),(3,3), colspan=7, rowspan=3)
ax_pca1 = plt.subplot2grid((20,10),(7,0), colspan=5, rowspan=6)
ax_pca2 = plt.subplot2grid((20,10),(7,5), colspan=5, rowspan=6)
ax_age_pc1 = plt.subplot2grid((20,9),(14,0), colspan=4, rowspan=2)
ax_age_pc2 = plt.subplot2grid((20,9),(14,5), colspan=4, rowspan=2)
#ax_age_pc3 = plt.subplot2grid((20,11),(14,8), colspan=3, rowspan=2)
ax_age_alpha1 = plt.subplot2grid((20,11),(17,0), colspan=3, rowspan=2)
ax_age_alpha2 = plt.subplot2grid((20,11),(17,4), colspan=3, rowspan=2)
ax_age_alpha3 = plt.subplot2grid((20,11),(17,8), colspan=3, rowspan=2)
#
#plot permanova values
plt.sca(ax_permanova_1)
labels = []
for l in range(len(permanova_first.index.values)):
  label = permanova_first.index.values[l]
  r2, p = permanova_first.loc[label, 'Univariate R2'], permanova_first.loc[label, 'Univariate p']
  if p <= 0.05: bar_col = '#008B90'
  else: bar_col = 'w'
  ba = ax_permanova_1.barh(l+0.45, width=r2, height=0.4, color=bar_col, edgecolor='#008B90')
  if round(r2, 4) >= 0.004: tx = ax_permanova_1.text(r2/2, l+0.45, str(round(r2, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova_1.text(r2+0.0001, l+0.45, str(round(r2, 4)), color='k', ha='left', va='center')

  r2_mul, p_mul = permanova_first.loc[label, 'Basic strata R2'], permanova_first.loc[label, 'Basic strata p']
  if p_mul <= 0.05: bar_col_mul = '#bb8fce'
  else: bar_col_mul = 'w'
  ba = ax_permanova_1.barh(l, width=r2_mul, height=0.4, color=bar_col_mul, edgecolor='#bb8fce')
  if round(r2_mul, 4) >= 0.004: tx = ax_permanova_1.text(r2_mul/2, l, str(round(r2_mul, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova_1.text(r2_mul+0.0001, l, str(round(r2_mul, 4)), color='k', ha='left', va='center')

  count_vals = md[md[label].notnull()].shape[0]
  new_label = label
  for orig in rename:
    new_label = new_label.replace(orig, rename[orig])
  labels.append(new_label+'\n($n$='+str(count_vals)+')')

yl = plt.yticks([x+0.225 for x in range(permanova_first.shape[0])], labels), plt.ylim([-0.3, l+0.8])
ti = plt.title('A', fontweight='bold', loc='left'), plt.title('Contribution to\nvariation', fontweight='bold')
xt = plt.xticks([])

plt.sca(ax_permanova_2)
labels = []
for l in range(len(permanova_second.index.values)):
  label = permanova_second.index.values[l]
  r2, p = permanova_second.loc[label, 'Univariate R2'], permanova_second.loc[label, 'Univariate p']
  if p <= 0.05: bar_col = '#008B90'
  else: bar_col = 'w'
  ba = ax_permanova_2.barh(l+0.45, width=r2, height=0.4, color=bar_col, edgecolor='#008B90')
  if r2 >= 0.004: tx = ax_permanova_2.text(r2/2, l+0.45, str(round(r2, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova_2.text(r2+0.0001, l+0.45, str(round(r2, 4)), color='k', ha='left', va='center')

  if label in ['antibiotics', 'HEFI', 'diet_richness_weekly']: name = 'Diet'
  else: name = 'Deprivation'
  r2_mul, p_mul = permanova_second.loc[label, name+' R2'], permanova_second.loc[label, name+' p']
  if p_mul <= 0.05: bar_col_mul = '#bb8fce'
  else: bar_col_mul = 'w'
  ba = ax_permanova_2.barh(l, width=r2_mul, height=0.4, color=bar_col_mul, edgecolor='#bb8fce')
  if r2_mul >= 0.004: tx = ax_permanova_2.text(r2_mul/2, l, str(round(r2_mul, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova_2.text(r2_mul+0.0001, l, str(round(r2_mul, 4)), color='k', ha='left', va='center')

  count_vals = md[md[label].notnull()].shape[0]
  new_label = label
  for orig in rename:
    new_label = new_label.replace(orig, rename[orig])
  labels.append(new_label+'\n($n$='+str(count_vals)+')')

xl = plt.xlim(ax_permanova_1.get_xlim())
yl = plt.yticks([x+0.225 for x in range(permanova_second.shape[0])], labels), plt.ylim([-0.3, l+0.8])
ti = plt.xlabel('PERMANOVA R$^{2}$', fontweight='bold')

colors_r2, names_r2 = ['#008B90', '#bb8fce'], ['Univariate', 'Multivariate']
handles_r2 = [Line2D([0], [0], marker='s', color='w', label=names_r2[r], markerfacecolor=colors_r2[r], markersize=12) for r in range(len(names_r2))]
colors_r2_sig, names_r2_sig = ['k', 'w'], ['(PERM)ANOVA $p$0.05', 'Not significant']
handles_r2_sig = [Line2D([0], [0], marker='s', color='w', label=names_r2_sig[r], markerfacecolor=colors_r2_sig[r], markeredgecolor='k', markersize=12) for r in range(len(names_r2_sig))]
leg = ax_permanova_2.legend(handles=handles_r2+handles_r2_sig, loc='upper right', bbox_to_anchor=(-0.09,0.06))

#plot alpha stats
alpha_stats1 = pd.read_csv(folder+'files/alpha_stats/faith_pd_summary.csv', index_col=0, header=0)
alpha_stats2 = pd.read_csv(folder+'files/alpha_stats/simpson_e_summary.csv', index_col=0, header=0)
alpha_stats3 = pd.read_csv(folder+'files/alpha_stats/simpson_summary.csv', index_col=0, header=0)
for r in range(len(permanova_first.index.values)):
  row = permanova_first.index.values[r]
  this_alpha = [alpha_stats1.loc[row, 'Univariate p'], alpha_stats2.loc[row, 'Univariate p'], alpha_stats3.loc[row, 'Univariate p']]
  this_alpha_2 = [alpha_stats1.loc[row, 'Basic p'], alpha_stats2.loc[row, 'Basic p'], alpha_stats3.loc[row, 'Basic p']]
  this_alpha = ['#008B90' if a <= 0.05 else 'w' for a in this_alpha]
  this_alpha_2 = ['#bb8fce' if a <= 0.05 else 'w' for a in this_alpha_2]
  for a in [0, 1, 2]:
    pl = ax_alpha_stats_1.fill([a, a, a+1], [r, r+1, r+1], color=this_alpha[a], edgecolor='k')
    pl = ax_alpha_stats_1.fill([a, a+1, a+1], [r, r, r+1], color=this_alpha_2[a], edgecolor='k')

plt.sca(ax_alpha_stats_1)
yl = plt.yticks([]), plt.xticks([]), plt.xlim([0, 3]), plt.ylim([0, r+1])
ti = plt.title('B', fontweight='bold', loc='left'), plt.title('Alpha div.\nstats', fontweight='bold')

for r in range(len(permanova_second.index.values)):
  row = permanova_second.index.values[r]
  this_alpha = [alpha_stats1.loc[row, 'Univariate p'], alpha_stats2.loc[row, 'Univariate p'], alpha_stats3.loc[row, 'Univariate p']]
  if row in ['antibiotics', 'HEFI', 'diet_richness_weekly']: name = 'Diet'
  else: name = 'Deprivation'
  this_alpha_2 = [alpha_stats1.loc[row, name+' p'], alpha_stats2.loc[row, name+' p'], alpha_stats3.loc[row, name+' p']]
  this_alpha = ['#008B90' if a <= 0.05 else 'w' for a in this_alpha]
  this_alpha_2 = ['#bb8fce' if a <= 0.05 else 'w' for a in this_alpha_2]
  for a in [0, 1, 2]:
    pl = ax_alpha_stats_2.fill([a, a, a+1], [r, r+1, r+1], color=this_alpha[a], edgecolor='k')
    pl = ax_alpha_stats_2.fill([a, a+1, a+1], [r, r, r+1], color=this_alpha_2[a], edgecolor='k')

plt.sca(ax_alpha_stats_2)
yl = plt.yticks([]), plt.xticks([0.5, 1.5, 2.5], ["FPD", "SE", "SI"]), plt.xlim([0, 3]), plt.ylim([0, r+1])

variables, axes = [], []
for r in range(len(permanova_first.index.values)):
  row = permanova_first.index.values[r]
  variables.append(row)
  axes.append(ax_metadata_1)

for r in range(len(permanova_second.index.values)):
  row = permanova_second.index.values[r]
  variables.append(row)
  axes.append(ax_metadata_2)

#plot metadata values
count = 0
for r in range(len(variables)):
  row = variables[r]
  print(row)
  if row == 'cur_msd_mat': count = 0
  if row == 'gender':
    gender = list(md['gender'].values)
    males, females, other = gender.count(1)/md.shape[0], gender.count(2)/md.shape[0], gender.count(3)/md.shape[0]
    ba = axes[r].barh([count, count, count], width=[males, females, other], left=[0, males, males+females], height=0.8, color=[colors_gender['Male'], colors_gender['Female'], colors_gender['Trans/gender-diverse']], edgecolor='k', alpha=0.7)
    tx = axes[r].text(males/2, count, 'Males\n('+str(round(males*100, 1))+'%)', ha='center', va='center')
    tx = axes[r].text((females/2)+males, count, 'Females\n('+str(round(females*100, 1))+'%)', ha='center', va='center')
    tx = axes[r].text(1.01, count, 'Trans/gender-\ndiverse ('+str(round(other*100, 1))+'%)', ha='left', va='center')
  elif row == 'ethnicity':
    ethnicity = list(md['ethnicity'].values)
    white, sasian, easian = ethnicity.count('White')/md.shape[0], ethnicity.count('South Asian')/md.shape[0], ethnicity.count('East Asian')/md.shape[0]
    ba = axes[r].barh([count, count, count], width=[easian, sasian, white], left=[0, easian, sasian+easian], height=0.8, color=[colors_ethnicity['East Asian'], colors_ethnicity['South Asian'], colors_ethnicity['White']], edgecolor='k', alpha=0.7)
    tx = axes[r].text(easian/2, count, 'East Asian\n('+str(round(easian*100))+'%)', ha='center', va='center')
    tx = axes[r].text((sasian/2)+easian, count, 'South Asian\n('+str(round(sasian*100))+'%)', ha='center', va='center')
    tx = axes[r].text((white/2)+easian+sasian, count, 'White\n('+str(round(white*100))+'%)', ha='center', va='center')
  elif row == 'antibiotics':
    antibiotics = list(md['antibiotics'].values)
    never, last_month = antibiotics.count('no')/md.shape[0], antibiotics.count('in_the_last_month')/md.shape[0]
    no_info = 1-never-last_month
    ba = axes[r].barh([count, count, count], width=[last_month, never, no_info], left=[0, last_month, last_month+never], height=0.8, color=[colors_antibiotics['in_the_last_month'], colors_antibiotics['never'], 'w'], edgecolor='k', alpha=0.7)
    tx = axes[r].text(last_month/2, count, 'Yes\n('+str(round(last_month*100))+'%)', ha='center', va='center')
    tx = axes[r].text((never/2)+last_month, count, 'No\n('+str(round(never*100))+'%)', color='w', ha='center', va='center')
    tx = axes[r].text((no_info/2)+never+last_month, count, 'NA\n('+str(round(no_info*100))+'%)', ha='center', va='center')
  elif row == 'physical_mental_condition':
    condition = list(md['physical_mental_condition'].values)
    none, physical, mental, both = condition.count('no_reported_condition')/md.shape[0], condition.count('physical_condition')/md.shape[0], condition.count('mental_condition')/md.shape[0], condition.count('mental_and_physical')/md.shape[0]
    ba = axes[r].barh([count, count, count, count], width=[physical, mental, both, none], left=[0, physical, physical+mental, physical+mental+both], color=[colors_condition['physical_condition'], colors_condition['mental_condition'], colors_condition['mental_and_physical'], colors_condition['no_reported_condition']], edgecolor='k', alpha=0.7)
    tx = axes[r].text((physical/2), count, 'Physical\n('+str(round(physical*100))+'%)', ha='center', va='center')
    tx = axes[r].text((mental/2)+physical, count, 'Mental\n('+str(round(mental*100))+'%)', ha='center', va='center')
    tx = axes[r].text((both/2)+physical+mental, count, 'Both\n('+str(round(both*100))+'%)', ha='center', va='center')
    tx = axes[r].text((none/2)+physical+mental+both, count, 'No reported conditions\n('+str(round(none*100))+'%)', ha='center', va='center')
  elif row == 'age':
    ages = [round(v, 1) for v in list(md['age'].values)]
    unique_ages = sorted(list(set(ages)))
    counts, age_plot = [], []
    age_span = 1/(max(ages)-min(ages))
    for a in range(len(unique_ages)):
      cnt = (ages.count(unique_ages[a])/md.shape[0])
      counts.append(cnt)
      age_plot.append((unique_ages[a]-min(ages))*age_span)
    counts_norm = [(c/max(counts))+count-0.4 for c in counts]
    w = lowess(counts_norm, unique_ages, frac=0.25, return_sorted=False)
    age_dict = {}
    for c in range(len(unique_ages)):
      age_dict[unique_ages[c]] = w[c]
    li = axes[r].plot(age_plot, w, 'k-')
    li = axes[r].fill_between(age_plot, [count-0.4 for c in range(len(w))], w, color='k', alpha=0.3)
    min_age, med_age, max_age = min(list(md['age'].values)), np.median(list(md['age'].values)), max(list(md['age'].values))
    tx = axes[r].text(0.005, age_dict[round(min_age, 1)]+0.2, str(round(min_age, 2))+'y', ha='left', va='bottom')
    tx = axes[r].text(0.995, age_dict[round(max_age, 1)]+0.1, str(round(max_age, 2))+'y', ha='right', va='bottom')
    tx = axes[r].text(((med_age-min_age)*age_span), age_dict[round(med_age, 1)]-0.3, str(round(med_age, 2))+'y', ha='center', va='center')
    tx = axes[r].scatter(((med_age-min_age)*age_span), age_dict[round(med_age, 1)], marker='o', color='k', s=10)
  else:
    var = list(md[row].values)
    var = [x for x in var if not np.isnan(x)]
    if row == 'diet_richness_weekly': var = [x for x in var if x != 0]
    counts, name_groups, group_plot = [], [], []
    rng = max(var)-min(var)
    nums = 150
    if len(set(var)) < 150:
      nums = len(set(var))
    mv = min(var)
    var_span = 1/rng
    interval = rng/nums
    start = min(var)
    for a in range(nums):
      cnt = len([i for i in var if start <= i <= start+interval])/len(var)
      counts.append(cnt)
      mid_point = np.mean([start, start+interval])
      name_groups.append(mid_point)
      group_plot.append((mid_point-mv)*var_span)
      start += interval
    if nums < 150:
      counts_norm = [((c/max(counts))*0.8)+count-0.4 for c in counts]
      w = lowess(counts_norm, name_groups, frac=0.2, return_sorted=False)
      nm = 14
      group_plot = [(1/nm)*k for k in range(len(group_plot))]
    else:
      counts_norm = [(c/max(counts))+count-0.4 for c in counts]
      w = lowess(counts_norm, name_groups, frac=0.25, return_sorted=False)
    var_dict = {}
    for c in range(len(name_groups)):
      var_dict[name_groups[c]] = w[c]
    li = axes[r].plot(group_plot, w, 'k-')
    li = axes[r].fill_between(group_plot, [count-0.4 for c in range(len(w))], w, color='k', alpha=0.3)
    min_var, med_var, max_var = min(var), np.median(var), max(var)
    closest_dist_min, closest_var_min, closest_dist_med, closest_var_med, closest_dist_max, closest_var_max = 10, '', 10, '', 10, ''
    for v in var_dict:
      if abs(min_var-v) < closest_dist_min:
        closest_dist_min, closest_var_min = abs(min_var-v), v
      if abs(med_var-v) < closest_dist_med:
        closest_dist_med, closest_var_med = abs(med_var-v), v
      if abs(max_var-v) < closest_dist_max:
        closest_dist_max, closest_var_max = abs(max_var-v), v
    if row == 'HEFI': rnd = 2
    elif row == 'diet_richness_weekly': rnd = 0
    else: rnd = 3
    tx = axes[r].text(0.005, var_dict[closest_var_min]+0.1, str(round(min_var, rnd)), ha='left', va='bottom')
    tx = axes[r].text(0.995, var_dict[closest_var_max]+0.1, str(round(max_var, rnd)), ha='right', va='bottom')
    tx = axes[r].text(((med_var-min_var)*var_span), var_dict[closest_var_med]-0.35, str(round(med_var, rnd)), ha='center', va='center')
    tx = axes[r].scatter(((med_var-min_var)*var_span), var_dict[closest_var_med], marker='o', color='k', s=10)
  count += 1

plt.sca(ax_metadata_1)
xl = plt.xlim([0, 1]), plt.ylim([-0.5, 3.5]), plt.yticks([]), plt.xticks([])
ti = plt.title('C', fontweight='bold', loc='left'), plt.title('Sample demographics (total $n$=4812)', fontweight='bold')

plt.sca(ax_metadata_2)
xl = plt.xlim([0, 1]), plt.ylim([-0.5, 3.5]), plt.yticks([]), plt.xticks([])

#pcoa plot
count = 0
for sample in md.index.values:
  try:
    pc1, pc2 = pca.loc[sample, 'PC1'], pca.loc[sample, 'PC2']
  except:
    continue
  age, gender, ethnicity = md.loc[sample, 'age'], md.loc[sample, 'gender'], md.loc[sample, 'ethnicity']
  sc = ax_pca1.scatter(pc1, pc2, marker='o', color=colors_gender[gender], alpha=0.2, s=age**2)
  sc = ax_pca2.scatter(pc1, pc2, marker='o', color=colors_ethnicity[ethnicity], alpha=0.2, s=age**2)
  count += 1

plt.sca(ax_pca1)
ti = plt.title('D', fontweight='bold', loc='left'), plt.title('Beta diversity: phylogenetic-RPCA', fontweight='bold')
xt = plt.xlim([-0.045, 0.045]), plt.ylim([-0.06, 0.06])
al = plt.xlabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)'), plt.ylabel('PC2 ('+str(round(prop_explain[1]*100, 2))+'%)')

plt.sca(ax_pca2)
ti = plt.title('E', fontweight='bold', loc='left'), plt.title('Beta diversity: phylogenetic-RPCA', fontweight='bold')
xt = plt.xlim([-0.045, 0.045]), plt.ylim([-0.06, 0.06]), plt.yticks([])
al = plt.xlabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)')

handles_gender = [Line2D([0], [0], marker='s', color='w', label=gen, markerfacecolor=colors_gender[gen], markersize=12) for gen in ['Male', 'Female', 'Trans/gender-diverse']]
handles_ethnicity = [Line2D([0], [0], marker='s', color='w', label=eth, markerfacecolor=colors_ethnicity[eth], markersize=12) for eth in ['East Asian', 'South Asian', 'White']]
leg = ax_pca1.legend(handles=handles_gender, loc='upper right')
leg = ax_pca2.legend(handles=handles_ethnicity, loc='upper right')
for ax in [ax_pca1, ax_pca2]:
  sc = ax.scatter(0.03, 0.96, marker='o', s=5**2, color='gray', transform=ax.transAxes)
  sc = ax.scatter(0.08, 0.96, marker=r'$\rightarrow$', s=20**2, color='k', transform=ax.transAxes)
  sc = ax.scatter(0.14, 0.96, marker='o', s=19**2, color='gray', transform=ax.transAxes)
  tx = ax.text(0.03, 0.93, '5y', ha='center', va='center', transform=ax.transAxes)
  tx = ax.text(0.14, 0.91, '19y', ha='center', va='center', transform=ax.transAxes)
  
#smooth pcoa plot
samples = [m for m in md.index.values if m in pca.index.values]
md_samples = md.loc[samples, :]

all_ages = md_samples.loc[:, 'age']
age_5_pc = p25 = np.percentile(all_ages, 5)
age_95_pc = p25 = np.percentile(all_ages, 95)
all_pc1 = pca.loc[md_samples.index.values, 'PC1']
all_pc2 = pca.loc[md_samples.index.values, 'PC2']

plt.sca(ax_age_pc1)
sc = plt.scatter(all_ages, all_pc1, marker='o', color='gray', alpha=0.03)

plt.sca(ax_age_pc2)
sc = plt.scatter(all_ages, all_pc2, marker='o', color='gray', alpha=0.03)

grouping = [['all', 'Overall', 'k'], ['gender', 1, colors_gender['Male']], ['gender', 2, colors_gender['Female']], ['ethnicity', 'South Asian', colors_ethnicity['South Asian']], ['ethnicity', 'East Asian', colors_ethnicity['East Asian']], ['ethnicity', 'White', colors_ethnicity['White']]]
for a in range(len(grouping)):
  if grouping[a][0] == 'all':
    group = md_samples.copy(deep=True)
  else:
    group = md_samples[md_samples[grouping[a][0]] == grouping[a][1]]
  all_ages = sorted(list(set([round(g, 1) for g in group['age']])))
  vals_group_pc1, vals_group_pc2 = {}, {}
  for age in all_ages:
    vals_group_pc1[age] = []
    vals_group_pc2[age] = []
  for row in group.index.values:
    age = round(group.loc[row, 'age'], 1)
    try:
      vals_group_pc1[age].append(pca.loc[row, 'PC1'])
      vals_group_pc2[age].append(pca.loc[row, 'PC2'])
    except:
      continue
  age_means_pc1, age_means_pc2 = [], []
  for age in all_ages:
    age_means_pc1.append(np.mean(vals_group_pc1[age]))
    age_means_pc2.append(np.mean(vals_group_pc2[age]))
  fitted_poly = Polynomial.fit(group['age'], pca.loc[group.index.values, 'PC1'], deg=4)
  w = fitted_poly(all_ages)
  li = ax_age_pc1.plot(all_ages, w, color=grouping[a][2], linestyle='-')
  adding = 0
  if grouping[a][1] == 'South Asian': adding += 0.012
  if grouping[a][1] == 'White': adding += 0.0075
  if grouping[a][1] == 2: adding += 0.003
  if grouping[a][1] == 'East Asian': adding -= 0.001
  if grouping[a][1] == 1: adding -= 0.0005
  tx = ax_age_pc1.text(all_ages[-1]+0.5, w[-1]+adding, str(grouping[a][1]).replace('1', 'Male').replace('2', 'Female'), color=grouping[a][2], ha='left', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.7, edgecolor=grouping[a][2]))
  fitted_poly = Polynomial.fit(group['age'], pca.loc[group.index.values, 'PC2'], deg=4)
  w = fitted_poly(all_ages)
  li = ax_age_pc2.plot(all_ages, w, color=grouping[a][2], linestyle='-')
  adding = 0
  if grouping[a][1] == 'South Asian': adding += 0.006
  if grouping[a][1] == 'East Asian': adding += 0.003
  if grouping[a][1] == 2: adding += 0.003
  if grouping[a][1] == 'Overall': adding -= 0.001
  if grouping[a][1] == 1: adding -= 0.005
  if grouping[a][1] == 'White': adding -= 0.007
  tx = ax_age_pc2.text(all_ages[-1]+0.5, w[-1]+adding, str(grouping[a][1]).replace('1', 'Male').replace('2', 'Female'), color=grouping[a][2], ha='left', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.7, edgecolor=grouping[a][2]))

plt.sca(ax_age_pc1)
ti = plt.title('F', fontweight='bold', loc='left'), plt.title('Beta diversity:\nphylogenetic-RPCA PC1', fontweight='bold'), plt.ylim([-0.02, 0.02])#, plt.xlim([4.99, 18.99])
al = plt.ylabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)'), plt.xlabel('Age (years)')
ymin_ax, ymax_ax = plt.ylim()
pl = plt.plot([age_5_pc, age_5_pc], [ymin_ax, ymax_ax], 'k--')
pl = plt.plot([age_95_pc, age_95_pc], [ymin_ax, ymax_ax], 'k--')
tx = plt.text(age_5_pc, ymax_ax*0.8, r'P$_5$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))
tx = plt.text(age_95_pc, ymax_ax*0.8, r'P$_{95}$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))

plt.sca(ax_age_pc2)
ti = plt.title('G', fontweight='bold', loc='left'), plt.title('Beta diversity:\nphylogenetic-RPCA PC2', fontweight='bold'), plt.ylim([-0.02, 0.02])#, plt.xlim([4.99, 18.99])
al = plt.ylabel('PC2 ('+str(round(prop_explain[1]*100, 2))+'%)'), plt.xlabel('Age (years)')
ymin_ax, ymax_ax = plt.ylim()
pl = plt.plot([age_5_pc, age_5_pc], [ymin_ax, ymax_ax], 'k--')
pl = plt.plot([age_95_pc, age_95_pc], [ymin_ax, ymax_ax], 'k--')
tx = plt.text(age_5_pc, ymax_ax*0.8, r'P$_5$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))
tx = plt.text(age_95_pc, ymax_ax*0.8, r'P$_{95}$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))

#smooth alpha plot
alpha1 = pd.read_csv(folder+'files/alpha_diversity/alpha_faith_pd.csv', index_col=0, header=0)
alpha2 = pd.read_csv(folder+'files/alpha_diversity/alpha_simpson_e.csv', index_col=0, header=0)
alpha3 = pd.read_csv(folder+'files/alpha_diversity/alpha_simpson.csv', index_col=0, header=0)
samples = [m for m in md.index.values if m in alpha1.index.values]
md_samples = md.loc[samples, :]

all_ages = md_samples.loc[:, 'age']
all_alpha1 = alpha1.loc[md_samples.index.values, 'Mean']
all_alpha2 = alpha2.loc[md_samples.index.values, 'Mean']
all_alpha3 = alpha3.loc[md_samples.index.values, 'Mean']

plt.sca(ax_age_alpha1)
sc = plt.scatter(all_ages, all_alpha1, marker='o', color='gray', alpha=0.03)

plt.sca(ax_age_alpha2)
sc = plt.scatter(all_ages, all_alpha2, marker='o', color='gray', alpha=0.03)

plt.sca(ax_age_alpha3)
sc = plt.scatter(all_ages, all_alpha3, marker='o', color='gray', alpha=0.03)

grouping = [['all', 'Overall', 'k'], ['gender', 1, colors_gender['Male']], ['gender', 2, colors_gender['Female']], ['ethnicity', 'South Asian', colors_ethnicity['South Asian']], ['ethnicity', 'East Asian', colors_ethnicity['East Asian']], ['ethnicity', 'White', colors_ethnicity['White']]]
for a in range(len(grouping)):
  if grouping[a][0] == 'all':
    group = md_samples.copy(deep=True)
  else:
    group = md_samples[md_samples[grouping[a][0]] == grouping[a][1]]
  all_ages = sorted(list(set([round(g, 1) for g in group['age']])))
  #all_ages = [v for v in ages if v < 15.5]
  vals_group_alpha1, vals_group_alpha2, vals_group_alpha3 = {}, {}, {}
  for age in all_ages:
    vals_group_alpha1[age] = []
    vals_group_alpha2[age] = []
    vals_group_alpha3[age] = []
  for row in group.index.values:
    age = round(group.loc[row, 'age'], 1)
    try:
      vals_group_alpha1[age].append(alpha1.loc[row, 'Mean'])
      vals_group_alpha2[age].append(alpha2.loc[row, 'Mean'])
      vals_group_alpha3[age].append(alpha3.loc[row, 'Mean'])
    except:
      continue
  age_means_alpha1, age_means_alpha2, age_means_alpha3  = [], [], []
  for age in all_ages:
    age_means_alpha1.append(np.mean(vals_group_alpha1[age]))
    age_means_alpha2.append(np.mean(vals_group_alpha2[age]))
    age_means_alpha3.append(np.mean(vals_group_alpha3[age]))
  fitted_poly = Polynomial.fit(group['age'], alpha1.loc[group.index.values, 'Mean'], deg=4)
  w = fitted_poly(all_ages)
  li = ax_age_alpha1.plot(all_ages, w, color=grouping[a][2], linestyle='-')
  adding = 0
  if grouping[a][1] == 'South Asian': adding += 0.6
  if grouping[a][1] == 'East Asian': adding += 0.3
  if grouping[a][1] == 1: adding += 0.7
  if grouping[a][1] == 'Overall': adding += 0.1
  if grouping[a][1] == 2: adding -= 0.5
  if grouping[a][1] == 'White': adding -= 0.3
  tx = ax_age_alpha1.text(all_ages[-1]+0.5, w[-1]+adding, str(grouping[a][1]).replace('1', 'Male').replace('2', 'Female'), color=grouping[a][2], ha='left', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.7, edgecolor=grouping[a][2]))
  fitted_poly = Polynomial.fit(group['age'], alpha2.loc[group.index.values, 'Mean'], deg=4)
  w = fitted_poly(all_ages)
  li = ax_age_alpha2.plot(all_ages, w, color=grouping[a][2], linestyle='-')
  adding = 0
  if grouping[a][1] == 'White': adding += 0.022
  if grouping[a][1] == 2: adding += 0.012
  if grouping[a][1] == 'South Asian': adding += 0.005
  if grouping[a][1] == 'Overall': adding -= 0.006
  if grouping[a][1] == 1: adding -= 0.012
  if grouping[a][1] == 'East Asian': adding -= 0.01
  tx = ax_age_alpha2.text(all_ages[-1]+0.5, w[-1]+adding, str(grouping[a][1]).replace('1', 'Male').replace('2', 'Female'), color=grouping[a][2], ha='left', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.7, edgecolor=grouping[a][2]))
  fitted_poly = Polynomial.fit(group['age'], alpha3.loc[group.index.values, 'Mean'], deg=4)
  w = fitted_poly(all_ages)
  li = ax_age_alpha3.plot(all_ages, w, color=grouping[a][2], linestyle='-')
  adding = 0
  if grouping[a][1] == 'South Asian': adding += 0.02
  if grouping[a][1] == 'White': adding += 0.025
  if grouping[a][1] == 2: adding += 0.01
  if grouping[a][1] == 1: adding -= 0.01
  if grouping[a][1] == 'East Asian': adding -= 0.005
  tx = ax_age_alpha3.text(all_ages[-1]+0.5, w[-1]+adding, str(grouping[a][1]).replace('1', 'Male').replace('2', 'Female'), color=grouping[a][2], ha='left', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.7, edgecolor=grouping[a][2]))

plt.sca(ax_age_alpha1)
ti = plt.title('H', fontweight='bold', loc='left'), plt.title("Alpha diversity:\nFaith's PD (FPD)", fontweight='bold'), plt.ylim([16, 22]), plt.xticks([6, 8, 10, 12, 14, 16, 18])#, plt.xlim([4.9, 18.99])
al = plt.ylabel('Diversity'), plt.xlabel('Age (years)')
ymin_ax, ymax_ax = plt.ylim()
pl = plt.plot([age_5_pc, age_5_pc], [ymin_ax, ymax_ax], 'k--')
pl = plt.plot([age_95_pc, age_95_pc], [ymin_ax, ymax_ax], 'k--')
tx = plt.text(age_5_pc, ((ymax_ax-ymin_ax)*0.9)+ymin_ax, r'P$_5$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))
tx = plt.text(age_95_pc, ((ymax_ax-ymin_ax)*0.9)+ymin_ax, r'P$_{95}$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))

plt.sca(ax_age_alpha2)
ti = plt.title('I', fontweight='bold', loc='left'), plt.title("Alpha diversity:\nSimpson's evenness (SE)", fontweight='bold'), plt.ylim([0.09, 0.18]), plt.xticks([6, 8, 10, 12, 14, 16, 18])#, plt.xlim([4.9, 18.99])
al = plt.ylabel(''), plt.xlabel('Age (years)')
ymin_ax, ymax_ax = plt.ylim()
pl = plt.plot([age_5_pc, age_5_pc], [ymin_ax, ymax_ax], 'k--')
pl = plt.plot([age_95_pc, age_95_pc], [ymin_ax, ymax_ax], 'k--')
tx = plt.text(age_5_pc, ((ymax_ax-ymin_ax)*0.9)+ymin_ax, r'P$_5$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))
tx = plt.text(age_95_pc, ((ymax_ax-ymin_ax)*0.9)+ymin_ax, r'P$_{95}$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))

plt.sca(ax_age_alpha3)
ti = plt.title('J', fontweight='bold', loc='left'), plt.title("Alpha diversity:\nSimpson's index (SI)", fontweight='bold'), plt.ylim([0.83, 0.95]), plt.xticks([6, 8, 10, 12, 14, 16, 18])#, plt.xlim([4.9, 18.99])
al = plt.ylabel(''), plt.xlabel('Age (years)')
ymin_ax, ymax_ax = plt.ylim()
pl = plt.plot([age_5_pc, age_5_pc], [ymin_ax, ymax_ax], 'k--')
pl = plt.plot([age_95_pc, age_95_pc], [ymin_ax, ymax_ax], 'k--')
tx = plt.text(age_5_pc, ((ymax_ax-ymin_ax)*0.9)+ymin_ax, r'P$_5$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))
tx = plt.text(age_95_pc, ((ymax_ax-ymin_ax)*0.9)+ymin_ax, r'P$_{95}$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))

plt.savefig(folder+'figures/beta_permanova_metadata_pcoa_alpha.png', dpi=600, bbox_inches='tight')
```

Split stats and demographics:
```{python}
prop_explain = [0.6386125734929017, 0.3023029246310683, 0.05908450187603021]
md = pd.read_csv(folder+'files/metadata_microbiome_participants_s2pheno.csv', index_col=0, header=0)
md_cur_env = pd.read_csv(folder+'files/metadata_microbiome_participants_s2pheno_current_env.csv', index_col=0, header=0)
pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_ordination_pca.csv', index_col=0, header=0)
metrics = ['gender', 'age', 'ethnicity', 'cur_msd_mat', 'cur_msd_soc', 'physical_mental_condition', 'cur_gta', 'cur_ior', 'cur_gmn_mean', 'cur_pm25_mean', 'HEFI', 'antibiotics']
permanova = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)

env_vars = ['cur_msd_mat', 'cur_msd_soc', 'cur_gta', 'cur_ior', 'cur_gmn_mean', 'cur_pm25_mean']
for row in md.index.values:
  if row not in md_cur_env.index.values:
    md.loc[row, env_vars] = np.nan

permanova_first = permanova.loc[['gender', 'age', 'ethnicity', 'physical_mental_condition'], :]
permanova_first = permanova_first.sort_values(by=['Univariate R2'], ascending=True)
permanova_second = permanova.loc[['cur_msd_mat', 'cur_msd_soc', 'cur_gta', 'cur_ior', 'cur_gmn_mean', 'cur_pm25_mean'], :]
permanova_second = permanova_second.sort_values(by=['Univariate R2'], ascending=True)
permanova_third = permanova.loc[[ 'HEFI',  'antibiotics']]
permanova_third = permanova_third.sort_values(by=['Univariate R2'], ascending=True)

rename = {'gender':'Gender', 'ethnicity':'Ethnicity', 'antibiotics':'Antibiotics', 'cur_msd_mat':'Material deprivation', 'cur_msd_soc':'Social deprivation', 'physical_mental_condition':'Diagnosed health condition', 'age':'Age', 'diet_richness_weekly':'Diet variety score (weekly)', 'HEFI':'Healthy Eating Index', 'cur_gta':'GTA', 'cur_ior':'Index of rurality', 'cur_gmn_mean':'Greenspace', 'cur_pm25_mean':'PM$_{2.5}$ (g m$^{-3}$)'}

fig = plt.figure(figsize=(15,20))
ax_overview = plt.subplot2grid((27,10),(0,0), colspan=10, rowspan=8)
ax_permanova_1 = plt.subplot2grid((27,10),(8,0), colspan=2, rowspan=4)
ax_permanova_2 = plt.subplot2grid((27,10),(12,0), colspan=2, rowspan=6)
ax_permanova_3 = plt.subplot2grid((27,10),(18,0), colspan=2, rowspan=2)
ax_alpha_stats_1 = plt.subplot2grid((27,10),(8,2), colspan=1, rowspan=4)
ax_alpha_stats_2 = plt.subplot2grid((27,10),(12,2), colspan=1, rowspan=6)
ax_alpha_stats_3 = plt.subplot2grid((27,10),(18,2), colspan=1, rowspan=2)
ax_metadata_1 = plt.subplot2grid((27,10),(8,3), colspan=7, rowspan=4)
ax_metadata_2 = plt.subplot2grid((27,10),(12,3), colspan=7, rowspan=6)
ax_metadata_3 = plt.subplot2grid((27,10),(18,3), colspan=7, rowspan=2)

plt.sca(ax_overview)
yl = plt.yticks([]), plt.xticks([])
ti = plt.title('A', fontweight='bold', loc='left'), plt.title('Overview of the Spit for Science oral microbiome cohort', fontweight='bold')
img = mpimg.imread(folder+'figures/cohort_overview_3.png')
ax_overview.imshow(img)

#
#plot permanova values
plt.sca(ax_permanova_1)
labels = []
for l in range(len(permanova_first.index.values)):
  label = permanova_first.index.values[l]
  r2, p = permanova_first.loc[label, 'Univariate R2'], permanova_first.loc[label, 'Univariate p']
  if p <= 0.05: bar_col = '#008B90'
  else: bar_col = 'w'
  ba = ax_permanova_1.barh(l+0.45, width=r2, height=0.4, color=bar_col, edgecolor='#008B90')
  if round(r2, 4) >= 0.004: tx = ax_permanova_1.text(r2/2, l+0.45, str(round(r2, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova_1.text(r2+0.0001, l+0.45, str(round(r2, 4)), color='k', ha='left', va='center')

  r2_mul, p_mul = permanova_first.loc[label, 'Basic strata R2'], permanova_first.loc[label, 'Basic strata p']
  if p_mul <= 0.05: bar_col_mul = '#bb8fce'
  else: bar_col_mul = 'w'
  ba = ax_permanova_1.barh(l, width=r2_mul, height=0.4, color=bar_col_mul, edgecolor='#bb8fce')
  if round(r2_mul, 4) >= 0.004: tx = ax_permanova_1.text(r2_mul/2, l, str(round(r2_mul, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova_1.text(r2_mul+0.0001, l, str(round(r2_mul, 4)), color='k', ha='left', va='center')

  count_vals = md[md[label].notnull()].shape[0]
  new_label = label
  for orig in rename:
    new_label = new_label.replace(orig, rename[orig])
  labels.append(new_label+'\n($n$='+str(count_vals)+')')

yl = plt.yticks([x+0.225 for x in range(permanova_first.shape[0])], labels), plt.ylim([-0.3, l+0.8])
ti = plt.title('B', fontweight='bold', loc='left'), plt.title('Contribution to\nvariation', fontweight='bold')
xt = plt.xticks([])

plt.sca(ax_permanova_2)
labels = []
for l in range(len(permanova_second.index.values)):
  label = permanova_second.index.values[l]
  r2, p = permanova_second.loc[label, 'Univariate R2'], permanova_second.loc[label, 'Univariate p']
  if p <= 0.05: bar_col = '#008B90'
  else: bar_col = 'w'
  ba = ax_permanova_2.barh(l+0.45, width=r2, height=0.4, color=bar_col, edgecolor='#008B90')
  if r2 >= 0.004: tx = ax_permanova_2.text(r2/2, l+0.45, str(round(r2, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova_2.text(r2+0.0001, l+0.45, str(round(r2, 4)), color='k', ha='left', va='center')

  if label in ['antibiotics', 'HEFI', 'diet_richness_weekly']: name = 'Diet'
  else: name = 'Environment'
  r2_mul, p_mul = permanova_second.loc[label, name+' R2'], permanova_second.loc[label, name+' p']
  if p_mul <= 0.05: bar_col_mul = '#bb8fce'
  else: bar_col_mul = 'w'
  ba = ax_permanova_2.barh(l, width=r2_mul, height=0.4, color=bar_col_mul, edgecolor='#bb8fce')
  if r2_mul >= 0.004: tx = ax_permanova_2.text(r2_mul/2, l, str(round(r2_mul, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova_2.text(r2_mul+0.0001, l, str(round(r2_mul, 4)), color='k', ha='left', va='center')

  count_vals = md[md[label].notnull()].shape[0]
  new_label = label
  for orig in rename:
    new_label = new_label.replace(orig, rename[orig])
  labels.append(new_label+'\n($n$='+str(count_vals)+')')

xl = plt.xlim(ax_permanova_1.get_xlim())
yl = plt.yticks([x+0.225 for x in range(permanova_second.shape[0])], labels), plt.ylim([-0.3, l+0.8])
xt = plt.xticks([])

plt.sca(ax_permanova_3)
labels = []
for l in range(len(permanova_third.index.values)):
  label = permanova_third.index.values[l]
  r2, p = permanova_third.loc[label, 'Univariate R2'], permanova_third.loc[label, 'Univariate p']
  if p <= 0.05: bar_col = '#008B90'
  else: bar_col = 'w'
  ba = ax_permanova_3.barh(l+0.45, width=r2, height=0.4, color=bar_col, edgecolor='#008B90')
  if r2 >= 0.004: tx = ax_permanova_3.text(r2/2, l+0.45, str(round(r2, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova_3.text(r2+0.0001, l+0.45, str(round(r2, 4)), color='k', ha='left', va='center')

  if label in ['antibiotics', 'HEFI', 'diet_richness_weekly']: name = 'Diet'
  else: name = 'Environment'
  r2_mul, p_mul = permanova_third.loc[label, name+' R2'], permanova_third.loc[label, name+' p']
  if p_mul <= 0.05: bar_col_mul = '#bb8fce'
  else: bar_col_mul = 'w'
  ba = ax_permanova_3.barh(l, width=r2_mul, height=0.4, color=bar_col_mul, edgecolor='#bb8fce')
  if r2_mul >= 0.004: tx = ax_permanova_3.text(r2_mul/2, l, str(round(r2_mul, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova_3.text(r2_mul+0.0001, l, str(round(r2_mul, 4)), color='k', ha='left', va='center')

  count_vals = md[md[label].notnull()].shape[0]
  new_label = label
  for orig in rename:
    new_label = new_label.replace(orig, rename[orig])
  labels.append(new_label+'\n($n$='+str(count_vals)+')')

xl = plt.xlim(ax_permanova_1.get_xlim())
yl = plt.yticks([x+0.225 for x in range(permanova_third.shape[0])], labels), plt.ylim([-0.3, l+0.8])
ti = plt.xlabel('PERMANOVA R$^{2}$', fontweight='bold')

colors_r2, names_r2 = ['#008B90', '#bb8fce'], ['Univariate', 'Multivariate']
handles_r2 = [Line2D([0], [0], marker='s', color='w', label=names_r2[r], markerfacecolor=colors_r2[r], markersize=12) for r in range(len(names_r2))]
colors_r2_sig, names_r2_sig = ['k', 'w'], ['(PERM)ANOVA $p$0.05', 'Not significant']
handles_r2_sig = [Line2D([0], [0], marker='s', color='w', label=names_r2_sig[r], markerfacecolor=colors_r2_sig[r], markeredgecolor='k', markersize=12) for r in range(len(names_r2_sig))]
leg = ax_permanova_1.legend(handles=handles_r2+handles_r2_sig, loc='lower right', bbox_to_anchor=(-0.09,0.95))

#plot alpha stats
alpha_stats1 = pd.read_csv(folder+'files/alpha_stats/faith_pd_summary.csv', index_col=0, header=0)
alpha_stats2 = pd.read_csv(folder+'files/alpha_stats/simpson_e_summary.csv', index_col=0, header=0)
alpha_stats3 = pd.read_csv(folder+'files/alpha_stats/simpson_summary.csv', index_col=0, header=0)
for r in range(len(permanova_first.index.values)):
  row = permanova_first.index.values[r]
  this_alpha = [alpha_stats1.loc[row, 'Univariate p'], alpha_stats2.loc[row, 'Univariate p'], alpha_stats3.loc[row, 'Univariate p']]
  this_alpha_2 = [alpha_stats1.loc[row, 'Basic p'], alpha_stats2.loc[row, 'Basic p'], alpha_stats3.loc[row, 'Basic p']]
  this_alpha = ['#008B90' if a <= 0.05 else 'w' for a in this_alpha]
  this_alpha_2 = ['#bb8fce' if a <= 0.05 else 'w' for a in this_alpha_2]
  for a in [0, 1, 2]:
    pl = ax_alpha_stats_1.fill([a, a, a+1], [r, r+1, r+1], color=this_alpha[a], edgecolor='k')
    pl = ax_alpha_stats_1.fill([a, a+1, a+1], [r, r, r+1], color=this_alpha_2[a], edgecolor='k')

plt.sca(ax_alpha_stats_1)
yl = plt.yticks([]), plt.xticks([]), plt.xlim([0, 3]), plt.ylim([0, r+1])
ti = plt.title('C', fontweight='bold', loc='left'), plt.title('Alpha div.\nstats', fontweight='bold')

for r in range(len(permanova_second.index.values)):
  row = permanova_second.index.values[r]
  this_alpha = [alpha_stats1.loc[row, 'Univariate p'], alpha_stats2.loc[row, 'Univariate p'], alpha_stats3.loc[row, 'Univariate p']]
  if row in ['antibiotics', 'HEFI', 'diet_richness_weekly']: name = 'Diet'
  else: name = 'Deprivation'
  this_alpha_2 = [alpha_stats1.loc[row, name+' p'], alpha_stats2.loc[row, name+' p'], alpha_stats3.loc[row, name+' p']]
  this_alpha = ['#008B90' if a <= 0.05 else 'w' for a in this_alpha]
  this_alpha_2 = ['#bb8fce' if a <= 0.05 else 'w' for a in this_alpha_2]
  for a in [0, 1, 2]:
    pl = ax_alpha_stats_2.fill([a, a, a+1], [r, r+1, r+1], color=this_alpha[a], edgecolor='k')
    pl = ax_alpha_stats_2.fill([a, a+1, a+1], [r, r, r+1], color=this_alpha_2[a], edgecolor='k')

plt.sca(ax_alpha_stats_2)
yl = plt.yticks([]), plt.xticks([]), plt.xlim([0, 3]), plt.ylim([0, r+1])

for r in range(len(permanova_third.index.values)):
  row = permanova_third.index.values[r]
  this_alpha = [alpha_stats1.loc[row, 'Univariate p'], alpha_stats2.loc[row, 'Univariate p'], alpha_stats3.loc[row, 'Univariate p']]
  if row in ['antibiotics', 'HEFI', 'diet_richness_weekly']: name = 'Diet'
  else: name = 'Deprivation'
  this_alpha_2 = [alpha_stats1.loc[row, name+' p'], alpha_stats2.loc[row, name+' p'], alpha_stats3.loc[row, name+' p']]
  this_alpha = ['#008B90' if a <= 0.05 else 'w' for a in this_alpha]
  this_alpha_2 = ['#bb8fce' if a <= 0.05 else 'w' for a in this_alpha_2]
  for a in [0, 1, 2]:
    pl = ax_alpha_stats_3.fill([a, a, a+1], [r, r+1, r+1], color=this_alpha[a], edgecolor='k')
    pl = ax_alpha_stats_3.fill([a, a+1, a+1], [r, r, r+1], color=this_alpha_2[a], edgecolor='k')

plt.sca(ax_alpha_stats_3)
yl = plt.yticks([]), plt.xticks([0.5, 1.5, 2.5], ["FPD", "SE", "SI"]), plt.xlim([0, 3]), plt.ylim([0, r+1])

variables, axes = [], []
for r in range(len(permanova_first.index.values)):
  row = permanova_first.index.values[r]
  variables.append(row)
  axes.append(ax_metadata_1)

for r in range(len(permanova_second.index.values)):
  row = permanova_second.index.values[r]
  variables.append(row)
  axes.append(ax_metadata_2)

for r in range(len(permanova_third.index.values)):
  row = permanova_third.index.values[r]
  variables.append(row)
  axes.append(ax_metadata_3)

#plot metadata values
count = 0
for r in range(len(variables)):
  row = variables[r]
  print(row)
  if row == 'cur_msd_mat': count = 0
  if row == 'HEFI': count = 0
  if row == 'gender':
    gender = list(md['gender'].values)
    males, females, other = gender.count(1)/md.shape[0], gender.count(2)/md.shape[0], gender.count(3)/md.shape[0]
    ba = axes[r].barh([count, count, count], width=[males, females, other], left=[0, males, males+females], height=0.8, color=[colors_gender['Male'], colors_gender['Female'], colors_gender['Trans/gender-diverse']], edgecolor='k', alpha=0.7)
    tx = axes[r].text(males/2, count, 'Males\n'+str(round(males*100, 1))+'%', ha='center', va='center')
    tx = axes[r].text((females/2)+males, count, 'Females\n'+str(round(females*100, 1))+'%', ha='center', va='center')
    tx = axes[r].text(1.01, count, 'Trans/gender-\ndiverse '+str(round(other*100, 1))+'%', ha='left', va='center')
  elif row == 'ethnicity':
    ethnicity = list(md['ethnicity'].values)
    white, sasian, easian = ethnicity.count('White')/md.shape[0], ethnicity.count('South Asian')/md.shape[0], ethnicity.count('East Asian')/md.shape[0]
    ba = axes[r].barh([count, count, count], width=[easian, sasian, white], left=[0, easian, sasian+easian], height=0.8, color=[colors_ethnicity['East Asian'], colors_ethnicity['South Asian'], colors_ethnicity['White']], edgecolor='k', alpha=0.7)
    tx = axes[r].text(easian/2, count, 'East Asian\n'+str(round(easian*100))+'%)', ha='center', va='center')
    tx = axes[r].text((sasian/2)+easian, count, 'South Asian\n'+str(round(sasian*100))+'%', ha='center', va='center')
    tx = axes[r].text((white/2)+easian+sasian, count, 'White\n'+str(round(white*100))+'%', ha='center', va='center')
  elif row == 'antibiotics':
    # antibiotics = list(md['antibiotics'].values)
    antibiotics = [v for v in md['antibiotics'].values if v in ['no', 'in_the_last_month']]
    print(antibiotics)
    # never, last_month = antibiotics.count('no')/md.shape[0], antibiotics.count('in_the_last_month')/md.shape[0]
    never, last_month = antibiotics.count('no')/len(antibiotics), antibiotics.count('in_the_last_month')/len(antibiotics)
    never_pc, last_month_pc = antibiotics.count('no')/md.shape[0], antibiotics.count('in_the_last_month')/md.shape[0]
    # no_info = 1-never-last_month
    # ba = axes[r].barh([count, count, count], width=[last_month, never, no_info], left=[0, last_month, last_month+never], height=0.8, color=[colors_antibiotics['in_the_last_month'], colors_antibiotics['never'], 'w'], edgecolor='k', alpha=0.7)
    ba = axes[r].barh([count, count], width=[last_month, never], left=[0, last_month], height=0.8, color=[colors_antibiotics['in_the_last_month'], colors_antibiotics['never']], edgecolor='k', alpha=0.7)
    tx = axes[r].text(last_month/2, count, 'Yes\n'+str(round(last_month*100))+'%', ha='center', va='center')
    tx = axes[r].text((never/2)+last_month, count, 'No\n'+str(round(never*100))+'%', color='w', ha='center', va='center')
    # tx = axes[r].text((no_info/2)+never+last_month, count, 'NA\n('+str(round(no_info*100))+'%)', ha='center', va='center')
  elif row == 'cur_gta':
    gta = list([v for v in md['cur_gta'].values if not np.isnan(v)])
    # no, yes = gta.count(0)/md.shape[0], gta.count(1)/md.shape[0]
    no, yes = gta.count(0)/len(gta), gta.count(1)/len(gta)
    no_pc, yes_pc = gta.count(0)/md.shape[0], gta.count(1)/md.shape[0]
    # no_info = 1-yes-no
    #ba = axes[r].barh([count, count, count], width=[yes, no, no_info], left=[0, yes, yes+no], height=0.8, color=[colors_gta[1], colors_gta[0], 'w'], edgecolor='k', alpha=0.7)
    ba = axes[r].barh([count, count], width=[yes, no], left=[0, yes], height=0.8, color=[colors_gta[1], colors_gta[0]], edgecolor='k', alpha=0.7)
    tx = axes[r].text(yes/2, count, 'Yes\n'+str(round(yes*100))+'%', color='w', ha='center', va='center')
    tx = axes[r].text((no/2)+yes, count, 'No\n'+str(round(no*100))+'%', color='w', ha='center', va='center')
    # tx = axes[r].text((no_info/2)+yes+no, count, 'NA\n('+str(round(no_info*100))+'%)', ha='center', va='center')
  elif row == 'physical_mental_condition':
    condition = list(md['physical_mental_condition'].values)
    none, physical, mental, both = condition.count('no_reported_condition')/md.shape[0], condition.count('physical_condition')/md.shape[0], condition.count('mental_condition')/md.shape[0], condition.count('mental_and_physical')/md.shape[0]
    ba = axes[r].barh([count, count, count, count], width=[physical, mental, both, none], left=[0, physical, physical+mental, physical+mental+both], color=[colors_condition['physical_condition'], colors_condition['mental_condition'], colors_condition['mental_and_physical'], colors_condition['no_reported_condition']], edgecolor='k', alpha=0.7)
    tx = axes[r].text((physical/2), count, 'Physical\n'+str(round(physical*100))+'%', ha='center', va='center')
    tx = axes[r].text((mental/2)+physical, count, 'Psych/NDD\n'+str(round(mental*100))+'%', ha='center', va='center')
    tx = axes[r].text((both/2)+physical+mental, count, 'Both\n'+str(round(both*100))+'%', ha='center', va='center')
    tx = axes[r].text((none/2)+physical+mental+both, count, 'No reported conditions\n'+str(round(none*100))+'%', ha='center', va='center')
  elif row == 'age':
    ages = [round(v, 1) for v in list(md['age'].values)]
    unique_ages = sorted(list(set(ages)))
    counts, age_plot = [], []
    age_span = 1/(max(ages)-min(ages))
    for a in range(len(unique_ages)):
      cnt = (ages.count(unique_ages[a])/md.shape[0])
      counts.append(cnt)
      age_plot.append((unique_ages[a]-min(ages))*age_span)
    counts_norm = [(c/max(counts))+count-0.4 for c in counts]
    w = lowess(counts_norm, unique_ages, frac=0.25, return_sorted=False)
    age_dict = {}
    for c in range(len(unique_ages)):
      age_dict[unique_ages[c]] = w[c]
    li = axes[r].plot(age_plot, w, 'k-')
    li = axes[r].fill_between(age_plot, [count-0.4 for c in range(len(w))], w, color='k', alpha=0.3)
    min_age, med_age, max_age = min(list(md['age'].values)), np.median(list(md['age'].values)), max(list(md['age'].values))
    tx = axes[r].text(0.005, age_dict[round(min_age, 1)]+0.2, str(round(min_age, 2))+'y', ha='left', va='bottom')
    tx = axes[r].text(0.995, age_dict[round(max_age, 1)]+0.1, str(round(max_age, 2))+'y', ha='right', va='bottom')
    tx = axes[r].text(((med_age-min_age)*age_span), age_dict[round(med_age, 1)]-0.3, str(round(med_age, 2))+'y', ha='center', va='center')
    tx = axes[r].scatter(((med_age-min_age)*age_span), age_dict[round(med_age, 1)], marker='o', color='k', s=10)
  else:
    var = list(md[row].values)
    var = [x for x in var if not np.isnan(x)]
    if row == 'diet_richness_weekly': var = [x for x in var if x != 0]
    counts, name_groups, group_plot = [], [], []
    rng = max(var)-min(var)
    nums = 150
    if len(set(var)) < 150:
      nums = len(set(var))
    mv = min(var)
    var_span = 1/rng
    interval = rng/nums
    start = min(var)
    for a in range(nums):
      cnt = len([i for i in var if start <= i <= start+interval])/len(var)
      counts.append(cnt)
      mid_point = np.mean([start, start+interval])
      name_groups.append(mid_point)
      group_plot.append((mid_point-mv)*var_span)
      start += interval
    if nums < 150:
      counts_norm = [((c/max(counts))*0.8)+count-0.4 for c in counts]
      w = lowess(counts_norm, name_groups, frac=0.2, return_sorted=False)
      nm = 14
      group_plot = [(1/nm)*k for k in range(len(group_plot))]
    else:
      counts_norm = [(c/max(counts))+count-0.4 for c in counts]
      if row == 'cur_ior':
        counts_norm = [(c/max(counts))*3+count-0.4 for c in counts]
      w = lowess(counts_norm, name_groups, frac=0.25, return_sorted=False)
    var_dict = {}
    for c in range(len(name_groups)):
      var_dict[name_groups[c]] = w[c]
    li = axes[r].plot(group_plot, w, 'k-')
    li = axes[r].fill_between(group_plot, [count-0.4 for c in range(len(w))], w, color='k', alpha=0.3)
    statistic, p_value = stats.shapiro(var)
    if p_value > 0.05: 
      med_var = np.mean(var)
    else:
      med_var = np.median(var)
    min_var, max_var = min(var), max(var)
    closest_dist_min, closest_var_min, closest_dist_med, closest_var_med, closest_dist_max, closest_var_max = 10, '', 10, '', 10, ''
    for v in var_dict:
      if abs(min_var-v) < closest_dist_min:
        closest_dist_min, closest_var_min = abs(min_var-v), v
      if abs(med_var-v) < closest_dist_med:
        closest_dist_med, closest_var_med = abs(med_var-v), v
      if abs(max_var-v) < closest_dist_max:
        closest_dist_max, closest_var_max = abs(max_var-v), v
    if row == 'HEFI': rnd = 2
    elif row == 'diet_richness_weekly': rnd = 0
    else: rnd = 3
    tx = axes[r].text(0.005, var_dict[closest_var_min]+0.1, str(round(min_var, rnd)), ha='left', va='bottom')
    tx = axes[r].text(0.995, var_dict[closest_var_max]+0.1, str(round(max_var, rnd)), ha='right', va='bottom')
    tx = axes[r].text(((med_var-min_var)*var_span), var_dict[closest_var_med]-0.35, str(round(med_var, rnd)), ha='center', va='center')
    tx = axes[r].scatter(((med_var-min_var)*var_span), var_dict[closest_var_med], marker='o', color='k', s=10)
  count += 1

plt.sca(ax_metadata_1)
xl = plt.xlim([0, 1]), plt.ylim([-0.5, 3.5]), plt.yticks([]), plt.xticks([])
ti = plt.title('D', fontweight='bold', loc='left'), plt.title('Sample demographics (total $n$=4812)', fontweight='bold')

plt.sca(ax_metadata_2)
xl = plt.xlim([0, 1]), plt.ylim([-0.5, 5.5]), plt.yticks([]), plt.xticks([])

plt.sca(ax_metadata_3)
xl = plt.xlim([0, 1]), plt.ylim([-0.5, 1.5]), plt.yticks([]), plt.xticks([])

plt.savefig(folder+'figures/permanova_metadata_2.png', dpi=600, bbox_inches='tight')
```

Split PCoA and alpha diversity:
```{python}
prop_explain = [0.6386125734929017, 0.3023029246310683, 0.05908450187603021]
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_ordination_pca.csv', index_col=0, header=0)
metrics = ['gender', 'age', 'ethnicity', 'HEFI', 'cur_msd_mat', 'cur_msd_soc', 'antibiotics', 'physical_mental_condition']
permanova = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)

permanova_first = permanova.loc[['gender', 'age', 'ethnicity', 'physical_mental_condition'], :]
permanova_first = permanova_first.sort_values(by=['Univariate R2'], ascending=True)
permanova_second = permanova.loc[[ 'HEFI', 'cur_msd_mat', 'cur_msd_soc', 'antibiotics'], :]
permanova_second = permanova_second.sort_values(by=['Univariate R2'], ascending=True)

rename = {'gender':'Gender', 'ethnicity':'Ethnicity', 'antibiotics':'Antibiotics', 'cur_msd_mat':'Material deprivation', 'cur_msd_soc':'Social deprivation', 'physical_mental_condition':'Physical/mental condition', 'age':'Age', 'diet_richness_weekly':'Diet variety score (weekly)', 'HEFI':'Healthy Eating Index'}

fig = plt.figure(figsize=(15,20))
ax_pca1 = plt.subplot2grid((20,10),(7,0), colspan=5, rowspan=6)
ax_pca2 = plt.subplot2grid((20,10),(7,5), colspan=5, rowspan=6)
ax_age_pc1 = plt.subplot2grid((20,9),(14,0), colspan=4, rowspan=2)
ax_age_pc2 = plt.subplot2grid((20,9),(14,5), colspan=4, rowspan=2)
#ax_age_pc3 = plt.subplot2grid((20,11),(14,8), colspan=3, rowspan=2)
ax_age_alpha1 = plt.subplot2grid((20,11),(17,0), colspan=3, rowspan=2)
ax_age_alpha2 = plt.subplot2grid((20,11),(17,4), colspan=3, rowspan=2)
ax_age_alpha3 = plt.subplot2grid((20,11),(17,8), colspan=3, rowspan=2)
#
#pcoa plot
count = 0
for sample in md.index.values:
  try:
    pc1, pc2 = pca.loc[sample, 'PC1'], pca.loc[sample, 'PC2']
  except:
    continue
  age, gender, ethnicity = md.loc[sample, 'age'], md.loc[sample, 'gender'], md.loc[sample, 'ethnicity']
  sc = ax_pca1.scatter(pc1, pc2, marker='o', color=colors_gender[gender], alpha=0.2, s=age**2)
  sc = ax_pca2.scatter(pc1, pc2, marker='o', color=colors_ethnicity[ethnicity], alpha=0.2, s=age**2)
  count += 1

plt.sca(ax_pca1)
ti = plt.title('A', fontweight='bold', loc='left'), plt.title('Beta diversity: phylogenetic-RPCA', fontweight='bold')
xt = plt.xlim([-0.045, 0.045]), plt.ylim([-0.06, 0.06])
al = plt.xlabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)'), plt.ylabel('PC2 ('+str(round(prop_explain[1]*100, 2))+'%)')

plt.sca(ax_pca2)
ti = plt.title('B', fontweight='bold', loc='left'), plt.title('Beta diversity: phylogenetic-RPCA', fontweight='bold')
xt = plt.xlim([-0.045, 0.045]), plt.ylim([-0.06, 0.06]), plt.yticks([])
al = plt.xlabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)')

handles_gender = [Line2D([0], [0], marker='s', color='w', label=gen, markerfacecolor=colors_gender[gen], markersize=12) for gen in ['Male', 'Female', 'Trans/gender-diverse']]
handles_ethnicity = [Line2D([0], [0], marker='s', color='w', label=eth, markerfacecolor=colors_ethnicity[eth], markersize=12) for eth in ['East Asian', 'South Asian', 'White']]
leg = ax_pca1.legend(handles=handles_gender, loc='upper right')
leg = ax_pca2.legend(handles=handles_ethnicity, loc='upper right')
for ax in [ax_pca1, ax_pca2]:
  sc = ax.scatter(0.03, 0.96, marker='o', s=5**2, color='gray', transform=ax.transAxes)
  sc = ax.scatter(0.08, 0.96, marker=r'$\rightarrow$', s=20**2, color='k', transform=ax.transAxes)
  sc = ax.scatter(0.14, 0.96, marker='o', s=19**2, color='gray', transform=ax.transAxes)
  tx = ax.text(0.03, 0.93, '5y', ha='center', va='center', transform=ax.transAxes)
  tx = ax.text(0.14, 0.91, '19y', ha='center', va='center', transform=ax.transAxes)
  
#smooth pcoa plot
samples = [m for m in md.index.values if m in pca.index.values]
md_samples = md.loc[samples, :]

all_ages = md_samples.loc[:, 'age']
age_5_pc = p25 = np.percentile(all_ages, 5)
age_95_pc = p25 = np.percentile(all_ages, 95)
all_pc1 = pca.loc[md_samples.index.values, 'PC1']
all_pc2 = pca.loc[md_samples.index.values, 'PC2']

plt.sca(ax_age_pc1)
sc = plt.scatter(all_ages, all_pc1, marker='o', color='gray', alpha=0.03)

plt.sca(ax_age_pc2)
sc = plt.scatter(all_ages, all_pc2, marker='o', color='gray', alpha=0.03)

grouping = [['all', 'Overall', 'k'], ['gender', 1, colors_gender['Male']], ['gender', 2, colors_gender['Female']], ['ethnicity', 'South Asian', colors_ethnicity['South Asian']], ['ethnicity', 'East Asian', colors_ethnicity['East Asian']], ['ethnicity', 'White', colors_ethnicity['White']]]
for a in range(len(grouping)):
  if grouping[a][0] == 'all':
    group = md_samples.copy(deep=True)
  else:
    group = md_samples[md_samples[grouping[a][0]] == grouping[a][1]]
  all_ages = sorted(list(set([round(g, 1) for g in group['age']])))
  vals_group_pc1, vals_group_pc2 = {}, {}
  for age in all_ages:
    vals_group_pc1[age] = []
    vals_group_pc2[age] = []
  for row in group.index.values:
    age = round(group.loc[row, 'age'], 1)
    try:
      vals_group_pc1[age].append(pca.loc[row, 'PC1'])
      vals_group_pc2[age].append(pca.loc[row, 'PC2'])
    except:
      continue
  age_means_pc1, age_means_pc2 = [], []
  for age in all_ages:
    age_means_pc1.append(np.mean(vals_group_pc1[age]))
    age_means_pc2.append(np.mean(vals_group_pc2[age]))
  fitted_poly = Polynomial.fit(group['age'], pca.loc[group.index.values, 'PC1'], deg=4)
  w = fitted_poly(all_ages)
  li = ax_age_pc1.plot(all_ages, w, color=grouping[a][2], linestyle='-')
  adding = 0
  if grouping[a][1] == 'South Asian': adding += 0.012
  if grouping[a][1] == 'White': adding += 0.0075
  if grouping[a][1] == 2: adding += 0.003
  if grouping[a][1] == 'East Asian': adding -= 0.001
  if grouping[a][1] == 1: adding -= 0.0005
  tx = ax_age_pc1.text(all_ages[-1]+0.5, w[-1]+adding, str(grouping[a][1]).replace('1', 'Male').replace('2', 'Female'), color=grouping[a][2], ha='left', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.7, edgecolor=grouping[a][2]))
  fitted_poly = Polynomial.fit(group['age'], pca.loc[group.index.values, 'PC2'], deg=4)
  w = fitted_poly(all_ages)
  li = ax_age_pc2.plot(all_ages, w, color=grouping[a][2], linestyle='-')
  adding = 0
  if grouping[a][1] == 'South Asian': adding += 0.006
  if grouping[a][1] == 'East Asian': adding += 0.003
  if grouping[a][1] == 2: adding += 0.003
  if grouping[a][1] == 'Overall': adding -= 0.001
  if grouping[a][1] == 1: adding -= 0.005
  if grouping[a][1] == 'White': adding -= 0.007
  tx = ax_age_pc2.text(all_ages[-1]+0.5, w[-1]+adding, str(grouping[a][1]).replace('1', 'Male').replace('2', 'Female'), color=grouping[a][2], ha='left', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.7, edgecolor=grouping[a][2]))

plt.sca(ax_age_pc1)
ti = plt.title('C', fontweight='bold', loc='left'), plt.title('Beta diversity:\nphylogenetic-RPCA PC1', fontweight='bold'), plt.ylim([-0.02, 0.02])#, plt.xlim([4.99, 18.99])
al = plt.ylabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)'), plt.xlabel('Age (years)')
ymin_ax, ymax_ax = plt.ylim()
pl = plt.plot([age_5_pc, age_5_pc], [ymin_ax, ymax_ax], 'k--')
pl = plt.plot([age_95_pc, age_95_pc], [ymin_ax, ymax_ax], 'k--')
tx = plt.text(age_5_pc, ymax_ax*0.8, r'P$_5$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))
tx = plt.text(age_95_pc, ymax_ax*0.8, r'P$_{95}$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))

plt.sca(ax_age_pc2)
ti = plt.title('D', fontweight='bold', loc='left'), plt.title('Beta diversity:\nphylogenetic-RPCA PC2', fontweight='bold'), plt.ylim([-0.02, 0.02])#, plt.xlim([4.99, 18.99])
al = plt.ylabel('PC2 ('+str(round(prop_explain[1]*100, 2))+'%)'), plt.xlabel('Age (years)')
ymin_ax, ymax_ax = plt.ylim()
pl = plt.plot([age_5_pc, age_5_pc], [ymin_ax, ymax_ax], 'k--')
pl = plt.plot([age_95_pc, age_95_pc], [ymin_ax, ymax_ax], 'k--')
tx = plt.text(age_5_pc, ymax_ax*0.8, r'P$_5$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))
tx = plt.text(age_95_pc, ymax_ax*0.8, r'P$_{95}$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))

#smooth alpha plot
alpha1 = pd.read_csv(folder+'files/alpha_diversity/alpha_faith_pd.csv', index_col=0, header=0)
alpha2 = pd.read_csv(folder+'files/alpha_diversity/alpha_simpson_e.csv', index_col=0, header=0)
alpha3 = pd.read_csv(folder+'files/alpha_diversity/alpha_simpson.csv', index_col=0, header=0)
samples = [m for m in md.index.values if m in alpha1.index.values]
md_samples = md.loc[samples, :]

all_ages = md_samples.loc[:, 'age']
all_alpha1 = alpha1.loc[md_samples.index.values, 'Mean']
all_alpha2 = alpha2.loc[md_samples.index.values, 'Mean']
all_alpha3 = alpha3.loc[md_samples.index.values, 'Mean']

plt.sca(ax_age_alpha1)
sc = plt.scatter(all_ages, all_alpha1, marker='o', color='gray', alpha=0.03)

plt.sca(ax_age_alpha2)
sc = plt.scatter(all_ages, all_alpha2, marker='o', color='gray', alpha=0.03)

plt.sca(ax_age_alpha3)
sc = plt.scatter(all_ages, all_alpha3, marker='o', color='gray', alpha=0.03)

grouping = [['all', 'Overall', 'k'], ['gender', 1, colors_gender['Male']], ['gender', 2, colors_gender['Female']], ['ethnicity', 'South Asian', colors_ethnicity['South Asian']], ['ethnicity', 'East Asian', colors_ethnicity['East Asian']], ['ethnicity', 'White', colors_ethnicity['White']]]
for a in range(len(grouping)):
  if grouping[a][0] == 'all':
    group = md_samples.copy(deep=True)
  else:
    group = md_samples[md_samples[grouping[a][0]] == grouping[a][1]]
  all_ages = sorted(list(set([round(g, 1) for g in group['age']])))
  #all_ages = [v for v in ages if v < 15.5]
  vals_group_alpha1, vals_group_alpha2, vals_group_alpha3 = {}, {}, {}
  for age in all_ages:
    vals_group_alpha1[age] = []
    vals_group_alpha2[age] = []
    vals_group_alpha3[age] = []
  for row in group.index.values:
    age = round(group.loc[row, 'age'], 1)
    try:
      vals_group_alpha1[age].append(alpha1.loc[row, 'Mean'])
      vals_group_alpha2[age].append(alpha2.loc[row, 'Mean'])
      vals_group_alpha3[age].append(alpha3.loc[row, 'Mean'])
    except:
      continue
  age_means_alpha1, age_means_alpha2, age_means_alpha3  = [], [], []
  for age in all_ages:
    age_means_alpha1.append(np.mean(vals_group_alpha1[age]))
    age_means_alpha2.append(np.mean(vals_group_alpha2[age]))
    age_means_alpha3.append(np.mean(vals_group_alpha3[age]))
  fitted_poly = Polynomial.fit(group['age'], alpha1.loc[group.index.values, 'Mean'], deg=4)
  w = fitted_poly(all_ages)
  li = ax_age_alpha1.plot(all_ages, w, color=grouping[a][2], linestyle='-')
  adding = 0
  if grouping[a][1] == 'South Asian': adding += 0.6
  if grouping[a][1] == 'East Asian': adding += 0.3
  if grouping[a][1] == 1: adding += 0.7
  if grouping[a][1] == 'Overall': adding += 0.1
  if grouping[a][1] == 2: adding -= 0.5
  if grouping[a][1] == 'White': adding -= 0.3
  tx = ax_age_alpha1.text(all_ages[-1]+0.5, w[-1]+adding, str(grouping[a][1]).replace('1', 'Male').replace('2', 'Female'), color=grouping[a][2], ha='left', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.7, edgecolor=grouping[a][2]))
  fitted_poly = Polynomial.fit(group['age'], alpha2.loc[group.index.values, 'Mean'], deg=4)
  w = fitted_poly(all_ages)
  li = ax_age_alpha2.plot(all_ages, w, color=grouping[a][2], linestyle='-')
  adding = 0
  if grouping[a][1] == 'White': adding += 0.022
  if grouping[a][1] == 2: adding += 0.012
  if grouping[a][1] == 'South Asian': adding += 0.005
  if grouping[a][1] == 'Overall': adding -= 0.006
  if grouping[a][1] == 1: adding -= 0.012
  if grouping[a][1] == 'East Asian': adding -= 0.01
  tx = ax_age_alpha2.text(all_ages[-1]+0.5, w[-1]+adding, str(grouping[a][1]).replace('1', 'Male').replace('2', 'Female'), color=grouping[a][2], ha='left', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.7, edgecolor=grouping[a][2]))
  fitted_poly = Polynomial.fit(group['age'], alpha3.loc[group.index.values, 'Mean'], deg=4)
  w = fitted_poly(all_ages)
  li = ax_age_alpha3.plot(all_ages, w, color=grouping[a][2], linestyle='-')
  adding = 0
  if grouping[a][1] == 'South Asian': adding += 0.02
  if grouping[a][1] == 'White': adding += 0.025
  if grouping[a][1] == 2: adding += 0.01
  if grouping[a][1] == 1: adding -= 0.01
  if grouping[a][1] == 'East Asian': adding -= 0.005
  tx = ax_age_alpha3.text(all_ages[-1]+0.5, w[-1]+adding, str(grouping[a][1]).replace('1', 'Male').replace('2', 'Female'), color=grouping[a][2], ha='left', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.7, edgecolor=grouping[a][2]))

plt.sca(ax_age_alpha1)
ti = plt.title('E', fontweight='bold', loc='left'), plt.title("Alpha diversity:\nFaith's PD (FPD)", fontweight='bold'), plt.ylim([16, 22]), plt.xticks([6, 8, 10, 12, 14, 16, 18])#, plt.xlim([4.9, 18.99])
al = plt.ylabel('Diversity'), plt.xlabel('Age (years)')
ymin_ax, ymax_ax = plt.ylim()
pl = plt.plot([age_5_pc, age_5_pc], [ymin_ax, ymax_ax], 'k--')
pl = plt.plot([age_95_pc, age_95_pc], [ymin_ax, ymax_ax], 'k--')
tx = plt.text(age_5_pc, ((ymax_ax-ymin_ax)*0.9)+ymin_ax, r'P$_5$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))
tx = plt.text(age_95_pc, ((ymax_ax-ymin_ax)*0.9)+ymin_ax, r'P$_{95}$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))

plt.sca(ax_age_alpha2)
ti = plt.title('F', fontweight='bold', loc='left'), plt.title("Alpha diversity:\nSimpson's evenness (SE)", fontweight='bold'), plt.ylim([0.09, 0.18]), plt.xticks([6, 8, 10, 12, 14, 16, 18])#, plt.xlim([4.9, 18.99])
al = plt.ylabel(''), plt.xlabel('Age (years)')
ymin_ax, ymax_ax = plt.ylim()
pl = plt.plot([age_5_pc, age_5_pc], [ymin_ax, ymax_ax], 'k--')
pl = plt.plot([age_95_pc, age_95_pc], [ymin_ax, ymax_ax], 'k--')
tx = plt.text(age_5_pc, ((ymax_ax-ymin_ax)*0.9)+ymin_ax, r'P$_5$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))
tx = plt.text(age_95_pc, ((ymax_ax-ymin_ax)*0.9)+ymin_ax, r'P$_{95}$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))

plt.sca(ax_age_alpha3)
ti = plt.title('G', fontweight='bold', loc='left'), plt.title("Alpha diversity:\nSimpson's index (SI)", fontweight='bold'), plt.ylim([0.83, 0.95]), plt.xticks([6, 8, 10, 12, 14, 16, 18])#, plt.xlim([4.9, 18.99])
al = plt.ylabel(''), plt.xlabel('Age (years)')
ymin_ax, ymax_ax = plt.ylim()
pl = plt.plot([age_5_pc, age_5_pc], [ymin_ax, ymax_ax], 'k--')
pl = plt.plot([age_95_pc, age_95_pc], [ymin_ax, ymax_ax], 'k--')
tx = plt.text(age_5_pc, ((ymax_ax-ymin_ax)*0.9)+ymin_ax, r'P$_5$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))
tx = plt.text(age_95_pc, ((ymax_ax-ymin_ax)*0.9)+ymin_ax, r'P$_{95}$', ha='center', va='center', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.85, edgecolor='k'))

plt.savefig(folder+'figures/beta_pcoa_alpha.png', dpi=600, bbox_inches='tight')
```

## Alpha diversity repeated rarefaction

```{python}
fig = plt.figure(figsize=(12,8))
alpha_metrics = ['chao1', 'faith_pd', 'observed_otus', 'shannon', 'simpson_e', 'simpson']
alpha_metric_name = ['Chao1 richness', "Faith's phylogenetic\ndiversity", "Observed taxa", "Shannon diversity", "Simpson's evenness", "Simpson's index\nof diversity"]

r, c = [0, 0, 0, 1, 1, 1], [0, 1, 2, 0, 1, 2]
for a in range(len(alpha_metrics)):
  ax = plt.subplot2grid((2,3),(r[a], c[a]))
  plt.sca(ax)
  ti = ax.set_title(alpha_metric_name[a], fontweight='bold')
  alp = pd.read_csv(folder+'files/alpha_diversity/alpha_'+alpha_metrics[a]+'.csv', index_col=0, header=0)
  alp = alp.sort_values(by=['Mean'], ascending=True)
  vals = [a for a in range(len(alp.index.values))]
  pl = ax.plot(vals, alp['Mean'], 'k-')
  fb = ax.fill_between(vals, alp['Lower'], alp['Upper'], color='r', alpha=0.5)
  if c[a] == 0: yl = ax.set_ylabel('Diversity')
  if r[a] == 1: xl = ax.set_xlabel('Samples (sorted by mean diversity)')
  xt = plt.xticks([])
  
plt.savefig(folder+'figures/alpha_repeated_rarefaction.png', dpi=600, bbox_inches='tight')
```

# Family plot

```{python}
prop_explain = [0.6386125734929017, 0.3023029246310683, 0.05908450187603021]
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
dist = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_distance.csv', index_col=0, header=0)

same_family, other_family = [], []
comparisons = set()

for sample1 in md.index.values:
  for sample2 in md.index.values:
    if sample1 == sample2: continue
    samples = sorted([sample1, sample2])
    samples = samples[0]+'_'+samples[1]
    if samples not in comparisons:
      if md.loc[sample1, 'family_id'] == md.loc[sample2, 'family_id']:
        same_family.append(dist.loc[sample1, sample2])
      else:
        other_family.append(dist.loc[sample1, sample2])
      comparisons.add(samples)

plt.figure(figsize=(10,10))
ax1 = plt.subplot(111)
ax1.scatter(np.random.normal(0, scale=0.1, size=len(same_family)), same_family, marker='o', color='k', alpha=0.01)
ax1.scatter(np.random.normal(1, scale=0.1, size=len(other_family)), other_family, marker='o', color='k', alpha=0.01)
box = ax1.boxplot(same_family, positions=[0], showfliers=False, vert=True, widths=0.8)
for item in ['boxes', 'whiskers', 'fliers', 'medians', 'caps']: bi = plt.setp(box[item], color='r')
box = ax1.boxplot(other_family, positions=[1], showfliers=False, vert=True, widths=0.8)
for item in ['boxes', 'whiskers', 'fliers', 'medians', 'caps']: bi = plt.setp(box[item], color='r')

plt.xticks([0, 1], ['Same family', 'Different family'])
plt.ylabel('Phylogenetic-RPCA distance')

plt.show()
```

# Genetic relatedness

Get kinship and distance values:
```{python}
gen_rel = pd.read_csv(folder_all+'king.kin0', index_col=None, header=0, sep='\t')
gen_rel = gen_rel.set_index(['ID1', 'ID2'])
dist = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_distance.csv', index_col=0, header=0)

sample1, sample2, kinship, distance = [], [], [], []

got_combo = set()
count = 0
for s1 in dist.index.values:
  for s2 in dist.index.values:
    if s1 == s2: continue
    samples = sorted([s1, s2])
    if samples[0]+'_'+samples[1] in got_combo: continue
    got_kinship = False
    try:
      kinship.append(gen_rel.loc[(samples[0], samples[1]), 'Kinship'])
      got_kinship = True
    except:
      try:
        kinship.append(gen_rel.loc[(samples[1], samples[0]), 'Kinship'])
        got_kinship = True
      except:
        got_kinship = False
    if not got_kinship: continue
    sample1.append(samples[0])
    sample2.append(samples[1])
    distance.append(dist.loc[samples[0], samples[1]])
    got_combo.add(samples[0]+'_'+samples[1])
    if count % 1000 == 0: print(count)
    count += 1
    
finished = True
all_corr = pd.DataFrame([sample1, sample2, kinship, distance], index=['Sample 1', 'Sample 2', 'Kinship', 'Distance']).transpose()
all_corr.to_csv(folder+'genetic_relatedness/kinship_and_distance.csv', index=False)

# #KeyError: "['TAG211724'] not in index"
# print(samples[0], samples[1])
# gen_rel.loc[(samples[1], samples[0]), 'Kinship']
# gen_rel.loc[('TAG200440', 'TAG200596'), 'Kinship']
```

Plot them:
```{python}
# kin_dist = pd.read_csv(folder+'genetic_relatedness/kinship_and_distance.csv', index_col=None, header=0).set_index(['Sample 1', 'Sample 2'])
# kin_dist = kin_dist.loc[~kin_dist.index.duplicated(keep='first'), :]
# kin_dist.to_csv(folder+'genetic_relatedness/kinship_and_distance.csv')

fig = plt.figure(figsize=(10,6))
ax1 = plt.subplot(111)

pl = plt.scatter(kin_dist['Kinship'], kin_dist['Distance'], marker='o', color='k', alpha=0.05)
fitted_poly = Polynomial.fit(kin_dist['Kinship'], kin_dist['Distance'], deg=1)
unique_vals = sorted(list(set(kin_dist['Kinship'].values)))
w = fitted_poly(unique_vals)
li = ax1.plot(unique_vals, w, color='r', linestyle='--')
corr, p = spearmanr(kin_dist['Kinship'], kin_dist['Distance'])
tx = ax1.text(0.98, 0.98, r'R$^2$='+str(round(corr, 3))+', $p$<0.001', ha='right', va='top', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8), transform=ax1.transAxes)
xl = plt.xlabel('Kinship coefficient', fontweight='bold')
yl = plt.ylabel('Phylogenetic-RPCA distance', fontweight='bold')

plt.savefig(folder+'figures/genetic_relatedness_distance_coefficient_correlation.png', dpi=600, bbox_inches='tight')
```

Within family ID two children:
```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
md = md.reset_index().set_index('family_id')
family_ids = set(md.index.values)
# kin_dist = pd.read_csv(folder+'genetic_relatedness/kinship_and_distance.csv', index_col=None, header=0).set_index(['Sample 1', 'Sample 2'])

count = 0
twin, sibs, half_sibs, cousins, not_related = [], [], [], [], []
for fid in family_ids:
  ids = md.loc[fid, 'id']
  if isinstance(ids, str): continue
  else: ids = sorted(ids.values)
  all_comps = []
  for i1 in ids:
    for i2 in ids:
      if i1 == i2: continue
      this_id = sorted([i1, i2])
      all_comps.append(this_id[0]+'_'+this_id[1])
  all_comps = set(all_comps)
  all_comps = [ids.split('_') for ids in all_comps]
  for ids in all_comps:
    try:
      coef, dist = kin_dist.loc[(ids[0], ids[1]), 'Kinship'], kin_dist.loc[(ids[0], ids[1]), 'Distance']
      count += 1
    except:
      continue
    if coef >= 0.354: twin.append(dist)
    elif coef >= 0.177: sibs.append(dist)
    elif coef >= 0.0884: half_sibs.append(dist)
    elif coef >= 0.0442: cousins.append(dist)
    else: not_related.append(dist)

fig = plt.figure(figsize=(10,6))
ax1 = plt.subplot(111)

relatedness = [twin, sibs, half_sibs, cousins, not_related]
names = ['Twins', 'First degree/\nfull siblings', 'Second degree/\nhalf siblings', 'Third degree/\ncousins', 'Not related']

for a in range(len(relatedness)):
  print(len(relatedness[a]))
  box = ax1.boxplot(relatedness[a], positions=[a], vert=True, showfliers=False, widths=0.8)
  for item in ['boxes', 'whiskers', 'fliers', 'medians', 'caps']: bi = plt.setp(box[item], color='r')
  sc = ax1.scatter(np.random.normal(a, scale=0.04, size=len(relatedness[a])), relatedness[a], marker='o', color='k', alpha=0.1)
  names[a] += ' ($n$='+str(len(relatedness[a]))+')'

plt.xticks(range(len(relatedness)), names, rotation=45)
plt.ylabel('Phylogenetic-RPCA distance', fontweight='bold')
plt.title("Distances within family ID's", fontweight='bold')

plt.savefig(folder+'figures/genetic_relatedness_distance_within_family_id_multiple_children.png', dpi=600, bbox_inches='tight')


```

Within family ID two children:
```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants_two_child_families.csv', index_col=0, header=0)
md = md.reset_index().set_index('family_id')
family_ids = set(md.index.values)
# kin_dist = pd.read_csv(folder+'genetic_relatedness/kinship_and_distance.csv', index_col=None, header=0).set_index(['Sample 1', 'Sample 2'])

count = 0
twin, sibs, half_sibs, cousins, not_related = [], [], [], [], []
for fid in family_ids:
  ids = sorted(md.loc[fid, 'id'].values)
  try:
    coef, dist = kin_dist.loc[(ids[0], ids[1]), 'Kinship'], kin_dist.loc[(ids[0], ids[1]), 'Distance']
    count += 1
  except:
    continue
  if coef >= 0.354: twin.append(dist)
  elif coef >= 0.177: sibs.append(dist)
  elif coef >= 0.0884: half_sibs.append(dist)
  elif coef >= 0.0442: cousins.append(dist)
  else: not_related.append(dist)

fig = plt.figure(figsize=(10,6))
ax1 = plt.subplot(111)

relatedness = [twin, sibs, half_sibs, cousins, not_related]
names = ['Twins', 'First degree/\nfull siblings', 'Second degree/\nhalf siblings', 'Third degree/\ncousins', 'Not related']

for a in range(len(relatedness)):
  print(len(relatedness[a]))
  box = ax1.boxplot(relatedness[a], positions=[a], vert=True, showfliers=False, widths=0.8)
  for item in ['boxes', 'whiskers', 'fliers', 'medians', 'caps']: bi = plt.setp(box[item], color='r')
  sc = ax1.scatter(np.random.normal(a, scale=0.04, size=len(relatedness[a])), relatedness[a], marker='o', color='k', alpha=0.1)
  names[a] += ' ($n$='+str(len(relatedness[a]))+')'
  
plt.xticks(range(len(relatedness)), names, rotation=45)
plt.ylabel('Phylogenetic-RPCA distance', fontweight='bold')
plt.title("Distances within family ID's (2 children in family)", fontweight='bold')
  
plt.savefig(folder+'figures/genetic_relatedness_distance_within_family_id.png', dpi=600, bbox_inches='tight')


```

Overall grouped:
```{python}
# kin_dist = pd.read_csv(folder+'genetic_relatedness/kinship_and_distance.csv', index_col=None, header=0).set_index(['Sample 1', 'Sample 2'])

count = 0
twin, sibs, half_sibs, cousins, not_related = [], [], [], [], []
for set_id in kin_dist.index.values:
  coef, dist = kin_dist.loc[set_id, 'Kinship'], kin_dist.loc[set_id, 'Distance']
  # ids = sorted(md.loc[fid, 'id'].values)
  # try:
  #   coef, dist = kin_dist.loc[(ids[0], ids[1]), 'Kinship'], kin_dist.loc[(ids[0], ids[1]), 'Distance']
  #   count += 1
  # except:
  #   continue
  if coef >= 0.354: twin.append(dist)
  elif coef >= 0.177: sibs.append(dist)
  elif coef >= 0.0884: half_sibs.append(dist)
  elif coef >= 0.0442: cousins.append(dist)
  else: not_related.append(dist)
  
print(count)

fig = plt.figure(figsize=(10,6))
ax1 = plt.subplot(111)

relatedness = [twin, sibs, half_sibs, cousins, not_related]
names = ['Twins', 'First degree/\nfull siblings', 'Second degree/\nhalf siblings', 'Third degree/\ncousins', 'Not related']

for a in range(len(relatedness)):
  print(len(relatedness[a]))
  box = ax1.boxplot(relatedness[a], positions=[a], vert=True, showfliers=False, widths=0.8)
  for item in ['boxes', 'whiskers', 'fliers', 'medians', 'caps']: bi = plt.setp(box[item], color='r')
  sc = ax1.scatter(np.random.normal(a, scale=0.04, size=len(relatedness[a])), relatedness[a], marker='o', color='k', alpha=0.05)
  names[a] += ' ($n$='+str(len(relatedness[a]))+')'
  
plt.xticks(range(len(relatedness)), names, rotation=45)
plt.ylabel('Phylogenetic-RPCA distance', fontweight='bold')
plt.title("Distances in groups", fontweight='bold')
  
plt.savefig(folder+'figures/genetic_relatedness_distance_in_groups.png', dpi=600, bbox_inches='tight')


```

Make overall figure:
```{python}
# kin_dist = pd.read_csv(folder+'genetic_relatedness/kinship_and_distance.csv', index_col=None, header=0).set_index(['Sample 1', 'Sample 2'])
# kin_dist_red = kin_dist[kin_dist['Kinship'] >= 0.0442]
# md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
dist = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_distance.csv', index_col=0, header=0)

plt.close()
fig = plt.figure(figsize=(15,11))
ax1, ax2 = plt.subplot(221), plt.subplot(222)
ax3, ax4 = plt.subplot(223), plt.subplot(224)

plt.sca(ax1)
pl = plt.scatter(kin_dist['Kinship'], kin_dist['Distance'], marker='o', color='k', alpha=0.01)
fitted_poly = Polynomial.fit(kin_dist['Kinship'], kin_dist['Distance'], deg=1)
unique_vals = sorted(list(set(kin_dist['Kinship'].values)))
w = fitted_poly(unique_vals)
li = ax1.plot(unique_vals, w, color='#008080', linestyle='--', lw=3)
corr, p = spearmanr(kin_dist['Kinship'], kin_dist['Distance'])
tx = ax1.text(0.98, 0.98, r"Spearman's R$^2$="+str(round(corr, 3))+', $p$=0.001', ha='right', va='top', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8), transform=ax1.transAxes)
xl = plt.xlabel('Kinship coefficient', fontweight='bold')
yl = plt.ylabel('Phylogenetic-RPCA distance', fontweight='bold')
ti = plt.title('A', fontweight='bold', loc='left')
l = len(list(kin_dist['Kinship'].values))
ti = plt.title('Oral microbiome similarity vs genetic relatedness\n(all participants $n$='+f"{l:,}"+' pairs)', fontweight='bold')

plt.sca(ax2)
pl = plt.scatter(kin_dist_red['Kinship'], kin_dist_red['Distance'], marker='o', color='k', alpha=0.05)
fitted_poly = Polynomial.fit(kin_dist_red['Kinship'], kin_dist_red['Distance'], deg=1)
unique_vals = sorted(list(set(kin_dist_red['Kinship'].values)))
w = fitted_poly(unique_vals)
li = ax2.plot(unique_vals, w, color='#008080', linestyle='--', lw=3)
corr, p = spearmanr(kin_dist_red['Kinship'], kin_dist_red['Distance'])
tx = ax2.text(0.98, 0.98, r"Spearman's R$^2$="+str(round(corr, 3))+', $p$=0.001', ha='right', va='top', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8), transform=ax2.transAxes)
xl = plt.xlabel('Kinship coefficient', fontweight='bold')
yl = plt.ylabel('Phylogenetic-RPCA distance', fontweight='bold')
ti = plt.title('B', fontweight='bold', loc='left')
l = len(list(kin_dist_red['Kinship'].values))
ti = plt.title('Oral microbiome similarity vs genetic relatedness\n(related individuals only $n$='+f"{l:,}"+' pairs)', fontweight='bold')

plt.sca(ax3)
# count = 0
# twin, sibs, half_sibs, cousins = [], [], [], []
# not_related = kin_dist[kin_dist['Kinship'] <= 0.0442]
# not_related = list(not_related['Distance'].values)
# for set_id in kin_dist_red.index.values:
#   coef, k_dist = kin_dist_red.loc[set_id, 'Kinship'], kin_dist_red.loc[set_id, 'Distance']
#   if coef >= 0.354: twin.append(k_dist)
#   elif coef >= 0.177: sibs.append(k_dist)
#   elif coef >= 0.0884: half_sibs.append(k_dist)
#   elif coef >= 0.0442: cousins.append(k_dist)

# relatedness = [twin+sibs, half_sibs+cousins, not_related]
# names = ['Twins/first\ndegree', 'Second/third\ndegree', 'Not related\n']

relatedness = [not_related, half_sibs+cousins, twin+sibs]
names = ['Not related\n', 'Second/third\ndegree', 'Twins/first\ndegree']

ma = 0
for a in range(len(relatedness)):
  box = ax3.boxplot(relatedness[a], positions=[a], vert=True, showfliers=False, widths=0.8)
  for item in ['boxes', 'whiskers', 'fliers', 'medians', 'caps']: bi = plt.setp(box[item], color='#008080', linewidth=3)
  sc = ax3.scatter(np.random.normal(a, scale=0.08, size=len(relatedness[a])), relatedness[a], marker='o', color='k', alpha=0.01)
  top = box['whiskers'][1].get_ydata()[1]
  if top > ma: ma = top
  l = len(relatedness[a])
  names[a] += ' ($n$='+f"{l:,}"+' pairs)'

f_statistic, p_value = stats.f_oneway(twin+sibs, half_sibs+cousins, not_related)
if p_value < 0.001: p_val = '$p$<0.001'
else: p_val = '$p$='+str(round(p_value, 3))
tx = ax3.text(0.98, 0.98, r'ANOVA F='+str(round(f_statistic, 3))+', '+p_val, ha='right', va='top', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8), transform=ax3.transAxes)

result = stats.tukey_hsd(twin+sibs, half_sibs+cousins, not_related)
li = plt.plot([0, 0, 2, 2], [ma*1.25, ma*1.3, ma*1.3, ma*1.25], 'k-')
tx = plt.text(1, ma*1.31, '$p$<0.001', ha='center', va='bottom')
li = plt.plot([0, 0, 1, 1], [ma*1.4, ma*1.45, ma*1.45, ma*1.4], 'k-')
tx = plt.text(0.5, ma*1.46, '$p$=0.043', ha='center', va='bottom')

xt = plt.xticks(range(len(relatedness)), names, rotation=45)
yl = plt.ylabel('Phylogenetic-RPCA distance', fontweight='bold')
ti = plt.title("Distances in genetic relatedness groups", fontweight='bold')
ti = plt.title("C", fontweight='bold', loc='left')
yl = plt.ylim([-0.2, 7.2])

plt.sca(ax4)

same_family, other_family = [], []
comparisons = set()

for sample1 in md.index.values:
  for sample2 in md.index.values:
    if sample1 == sample2: continue
    samples = sorted([sample1, sample2])
    samples = samples[0]+'_'+samples[1]
    if samples not in comparisons:
      if md.loc[sample1, 'family_id'] == md.loc[sample2, 'family_id']:
        same_family.append(dist.loc[sample1, sample2])
      else:
        other_family.append(dist.loc[sample1, sample2])
      comparisons.add(samples)

sc = ax4.scatter(np.random.normal(1, scale=0.1, size=len(same_family)), same_family, marker='o', color='k', alpha=0.01)
sc = ax4.scatter(np.random.normal(0, scale=0.1, size=len(other_family)), other_family, marker='o', color='k', alpha=0.01)
box = ax4.boxplot(same_family, positions=[1], showfliers=False, vert=True, widths=0.8)
for item in ['boxes', 'whiskers', 'fliers', 'medians', 'caps']: bi = plt.setp(box[item], color='#008080', linewidth=3)
box = ax4.boxplot(other_family, positions=[0], showfliers=False, vert=True, widths=0.8)
for item in ['boxes', 'whiskers', 'fliers', 'medians', 'caps']: bi = plt.setp(box[item], color='#008080', linewidth=3)

l1, l2 = len(same_family), len(other_family)
xt = plt.xticks([0, 1], ['Different family\nunit ($n$='+f"{l2:,}"+')', 'Same family\nunit ($n$='+f"{l1:,}"+')'], rotation=45)
yl = plt.ylabel('Phylogenetic-RPCA distance', fontweight='bold')

f_statistic, p_value = stats.f_oneway(same_family, other_family)
if p_value < 0.001: p_val = '$p$<0.001'
else: p_val = '$p$='+str(round(p_value, 3))
tx = ax4.text(0.98, 0.98, r'ANOVA F='+str(round(f_statistic, 3))+', '+p_val, ha='right', va='top', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8), transform=ax4.transAxes)

ti = plt.title("Distances within vs between family units", fontweight='bold')
ti = plt.title("D", fontweight='bold', loc='left')

# plt.show()
plt.savefig(folder+'figures/genetic_relatedness_overall.png', dpi=600, bbox_inches='tight')
```

Within family ID distance vs age difference:
NOT USED
```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
dist = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_distance.csv', index_col=0, header=0)

age, distances = [], []
compared = []

for sample1 in md.index.values:
  for sample2 in md.index.values:
    if sample1 == sample2: continue
    if md.loc[sample1, 'family_id'] != md.loc[sample2, 'family_id']: continue
    c = sorted([sample1, sample2])
    if c[0]+'_'+c[1] in compared: continue
    compared.append(c[0]+'_'+c[1])
    age.append(abs(md.loc[sample1, 'age']-md.loc[sample2, 'age']))
    distances.append(dist.loc[sample1, sample2])

corr, p = spearmanr(age, distances)
print(corr,p)

```

# Taxonomy summary

Get relative abundance at phylum level:
```{python}
ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)

tax_dict = {}
taxonomy = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
for row in taxonomy.index.values:
  tax_dict[row] = taxonomy.loc[row, 'Phylum']
  
ft = ft.rename(index=tax_dict)
ft = ft.groupby(by=ft.index, axis=0).sum()
  
ft_relabun = ft.divide(ft.sum(axis=0), axis=1).multiply(100)
ft_relabun['Mean'] = ft_relabun.mean(axis=1)
ft_relabun = ft_relabun.sort_values(by=['Mean'], ascending=False)

print(ft_relabun)
```

## Genus and ASV prevalence and abundance

```{python}
ft_genus = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
ft_asv = pd.read_csv(folder+'files/feature-table_min2000_with_metadata.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)

rename_genus = {}
for row in ft_genus.index.values:
  rename_genus[row] = tax.loc[row, 'Genus']

ft_genus = ft_genus.rename(index=rename_genus)

all_genus = list(tax['Genus'].values)
genus_count = {}
for genus in set(all_genus):
  genus_count[genus] = all_genus.count(genus)

fts = [ft_asv, ft_genus]
fig = plt.figure(figsize=(16,10))
axes = [plt.subplot2grid((4,7),(0,0), colspan=3, rowspan=2), plt.subplot2grid((4,7),(2,0), colspan=3, rowspan=2)]
cutoffs = [0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.95, 0.96, 0.97, 0.98, 0.99, 1]
cutoff_bar = [0.95, 0.96, 0.97, 0.98, 0.99, 1]
cutoff_ft = []

for f in range(len(fts)):
  ft = fts[f]
  ax = axes[f]
  ft_prev = ft.copy(deep=True)
  ft_prev[ft_prev > 1] = 1
  ft_prev['Prevalence'] = ft_prev.sum(axis=1)/ft.shape[1]
  ft = ft.divide(ft.sum(axis=0), axis=1).multiply(100)
  for prev in cutoffs:
    ft_prev = ft_prev[ft_prev['Prevalence'] >= prev]
    # if prev > 0.9: print(f, prev, ft_prev.sort_values(by=['Prevalence'], ascending=True))
    ft_sum = ft.copy(deep=True).loc[ft_prev.index.values, :]
    if f == 1 and prev in cutoff_bar:
      cutoff_ft.append(ft_sum)
    ft_sum = ft_sum.sum(axis=0)
    box = ax.boxplot(ft_sum, positions=[prev], widths=0.008, showfliers=False, vert=True)
    for item in ['boxes', 'whiskers', 'fliers', 'medians', 'caps']: bi = plt.setp(box[item], color='k')
  plt.sca(ax)
  xl = plt.xlim([-0.01, 1.01])
  if f == 0:
    yl = plt.ylabel('ASV relative abundance (%)', fontweight='bold')
  else:
    yl = plt.ylabel('Genus relative abundance (%)', fontweight='bold')
  xl = plt.xlabel('Prevalence (%)', fontweight='bold')
  xt = plt.xticks([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1], [0, 10, 20, 30, 40, 50, 60, 70, 80, 90, 100])
  
axes_plot = [[plt.subplot2grid((28,14),(0,9), colspan=1, rowspan=9), plt.subplot2grid((28,14),(0,10), colspan=4, rowspan=9)], [plt.subplot2grid((28,14),(11,9), colspan=1, rowspan=18), plt.subplot2grid((28,14),(11,10), colspan=4, rowspan=18)]]
titles = ['ASVs 95% prevalence', 'Genera 95% prevalence']

asv_rename = {}
count = 1
for row in ft_asv.index.values:
  sp = tax.loc[row, 'Species']
  if 'Unclassified g__' in sp: sp = '$'+sp.replace('Unclassified g__', '')+'$'
  elif 's__' in sp: sp = '$'+tax.loc[row, 'Genus'].replace('g__', '')+'$ $'+sp.replace('s__', '')+'$'
  asv_rename[row] = tax.loc[row, 'ASV']+': '+sp
  count += 1
  
for f in range(len(fts)):
  ft = fts[f]
  #axs = axes_plot[f]
  ft_prev = ft.copy(deep=True)
  ft_prev[ft_prev > 1] = 1
  ft_prev['Prevalence'] = ft_prev.sum(axis=1)/ft.shape[1]
  ft = ft.divide(ft.sum(axis=0), axis=1).multiply(100)
  ft_prev = ft_prev[ft_prev['Prevalence'] >= 0.95]
  ft_prev = ft_prev.loc[:, ['Prevalence']]
  ft_prev = ft_prev.sort_values(by=['Prevalence'], ascending=True)
  axes_plot[f][0].pcolor(ft_prev, edgecolor='k', cmap='Blues', vmin=0.9, vmax=1)
  plt.sca(axes_plot[f][0])
  if f == 0:
    xt = plt.yticks([a+0.5 for a in range(len(ft_prev.index.values))], [asv_rename[asv] for asv in ft_prev.index.values])
  else:
    xt = plt.yticks([a+0.5 for a in range(len(ft_prev.index.values))], ['$'+gen.replace('g__', '')+'$ ('+str(genus_count[gen])+')' for gen in ft_prev.index.values])
  xt = plt.xticks([])
  yticks = []
  for t in range(len(ft_prev.index.values)):
    pl = axes_plot[f][0].text(0.5, t+0.5, str(round(ft_prev.iloc[t, 0]*100, 2)), color='w', ha='center', va='center')
    abun_vals = ft.loc[ft_prev.index.values[t], :].values
    box = axes_plot[f][1].boxplot(abun_vals, positions=[t+0.5], widths=0.3, showfliers=False, vert=False)
    for item in ['boxes', 'whiskers', 'fliers', 'medians', 'caps']: bi = plt.setp(box[item], color='k')
    #tx = axes_plot[f][1].text(np.median(abun_vals), t+0.8, str(round(np.median(abun_vals), 2)), ha='center', va='bottom', fontsize=7, bbox=dict(facecolor='white', alpha=0.8))
    yticks.append(str(round(np.median(abun_vals), 2))+'%')
  plt.sca(axes_plot[f][1])
  yl = axes_plot[f][1].set_ylim([0, len(ft_prev.index.values)]), plt.yticks([t+0.5 for t in range(len(ft_prev.index.values))], yticks)
  axes_plot[f][1].yaxis.tick_right()
  xl = plt.xlabel('Relative abundance (%)', fontweight='bold')
  yl = axes_plot[f][0].set_ylabel(titles[f], fontweight='bold')
  

plt.subplots_adjust(hspace=0.6, wspace=0.8)
plt.savefig(folder+'figures/prevalence_ASV_genus_heatmap.png', dpi=600, bbox_inches='tight')
```

For adults with heatmap:
```{python}
ft = pd.read_csv(folder_atpath+'exports/feature-table_w_tax.txt', index_col=0, header=1, sep='\t')
tax = ft.loc[:, ['taxonomy']]
ft = ft.drop('taxonomy', axis=1)

#drop samples with < 2000 reads
ft = ft.transpose()
ft['Sum'] = ft.sum(axis=1)
ft = ft[ft['Sum'] >= 2000]
ft = ft.drop('Sum', axis=1).transpose()
ft = ft[ft.max(axis=1) > 0]

ft.to_csv(folder_atpath+'exports/feature-table_min_2000.txt', sep='\t')
tax.loc[ft.index.values, :].to_csv(folder_atpath+'exports/taxonomy_min_2000.txt', sep='\t')

# get taxonomy
names = ['Kingdom', 'Phylum', 'Class', 'Order', 'Family', 'Genus', 'Species']
for row in tax.index.values:
  this_tax = tax.loc[row, 'taxonomy'].split(';')
  lowest = ''
  for level in this_tax:
    if isinstance(level, str):
      lowest = level
  for r in range(len(names)):
    try:
      if not isinstance(this_tax[r], str):
        this_tax[r] = 'Unclassified '+lowest
    except:
      this_tax.append('Unclassified '+lowest)
  for l in range(len(this_tax)):
    tax.loc[row, names[l]] = this_tax[l]
  #tax.loc[row, :] = this_tax
  
tax_genus = {}
for row in tax.index.values:
  tax_genus[row] = tax.loc[row, 'Genus']
  
all_genus = list(tax['Genus'].values)
genus_count = {}
for genus in set(all_genus):
  genus_count[genus] = all_genus.count(genus)

ft_genus = ft.copy(deep=True).rename(index=tax_genus)
ft_genus = ft_genus.groupby(by=ft_genus.index, axis=0).sum()
ft_genus.to_csv(folder_atpath+'feature_table_genus.csv')

ft_asv = ft.copy(deep=True)

fts = [ft_asv, ft_genus]
fig = plt.figure(figsize=(16,10))
# axes = [plt.subplot2grid((3,5),(0,0), colspan=3), plt.subplot2grid((3,5),(1,0), colspan=3), plt.subplot2grid((3,5),(2,0), colspan=3)]
axes = [plt.subplot2grid((4,7),(0,0), colspan=3, rowspan=2), plt.subplot2grid((4,7),(2,0), colspan=3, rowspan=2)]
cutoffs = [0, 0.01, 0.05, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.95, 0.96, 0.97, 0.98, 0.99, 1]
cutoff_bar = [0.95, 0.96, 0.97, 0.98, 0.99, 1]
cutoff_ft = []

for f in range(len(fts)):
  ft = fts[f]
  ax = axes[f]
  ft_prev = ft.copy(deep=True)
  ft_prev[ft_prev > 1] = 1
  ft_prev['Prevalence'] = ft_prev.sum(axis=1)/ft.shape[1]
  ft = ft.divide(ft.sum(axis=0), axis=1).multiply(100)
  for prev in cutoffs:
    ft_prev = ft_prev[ft_prev['Prevalence'] >= prev]
    # if prev >= 0.9: print(f, prev, ft_prev.sort_values(by=['Prevalence'], ascending=True))
    ft_sum = ft.copy(deep=True).loc[ft_prev.index.values, :]
    if f == 1 and prev in cutoff_bar:
      cutoff_ft.append(ft_sum)
    ft_sum = ft_sum.sum(axis=0)
    box = ax.boxplot(ft_sum, positions=[prev], widths=0.008, showfliers=False, vert=True)
    for item in ['boxes', 'whiskers', 'fliers', 'medians', 'caps']: bi = plt.setp(box[item], color='k')
  plt.sca(ax)
  xl = plt.xlim([-0.01, 1.01])
  if f == 0:
    yl = plt.ylabel('ASV relative abundance (%)', fontweight='bold')
    xl = plt.xlabel('Prevalence (%)', fontweight='bold')
  else:
    yl = plt.ylabel('Genus relative abundance (%)', fontweight='bold')
    xl = plt.xlabel('Prevalence (%)', fontweight='bold')
  xt = plt.xticks([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1], ['0', '10', '20', '30', '40', '50', '60', '70', '80', '90', '100'])

axes_plot = [[plt.subplot2grid((25,14),(0,9), colspan=1, rowspan=5), plt.subplot2grid((25,14),(0,10), colspan=4, rowspan=5)], [plt.subplot2grid((25,14),(7,9), colspan=1, rowspan=18), plt.subplot2grid((25,14),(7,10), colspan=4, rowspan=18)]]
titles = ['ASVs 95%\nprevalence', 'Genera 95% prevalence']

asv_rename = {}
count = 1
for row in ft_asv.index.values:
  sp = tax.loc[row, 'Species']
  if 'Unclassified  g__' in sp: sp = '$'+sp.replace('Unclassified  g__', '')+'$'
  elif 's__' in sp: sp = '$'+tax.loc[row, 'Genus'].replace('g__', '')+'$ $'+sp.replace('s__', '')+'$'
  asv_rename[row] = 'ASV'+str(count)+': '+sp
  count += 1

for f in range(len(fts)):
  ft = fts[f]
  #axs = axes_plot[f]
  ft_prev = ft.copy(deep=True)
  ft_prev[ft_prev > 1] = 1
  ft_prev['Prevalence'] = ft_prev.sum(axis=1)/ft.shape[1]
  ft = ft.divide(ft.sum(axis=0), axis=1).multiply(100)
  ft_prev = ft_prev[ft_prev['Prevalence'] >= 0.95]
  ft_prev = ft_prev.loc[:, ['Prevalence']]
  ft_prev = ft_prev.sort_values(by=['Prevalence'], ascending=True)
  axes_plot[f][0].pcolor(ft_prev, edgecolor='k', cmap='Blues', vmin=0.9, vmax=1)
  plt.sca(axes_plot[f][0])
  if f == 0:
    xt = plt.yticks([a+0.5 for a in range(len(ft_prev.index.values))], [asv_rename[asv] for asv in ft_prev.index.values])
  else:
    xt = plt.yticks([a+0.5 for a in range(len(ft_prev.index.values))], ['$'+gen.replace('g__', '')+'$ ('+str(genus_count[gen])+')' for gen in ft_prev.index.values])
  xt = plt.xticks([])
  yticks = []
  for t in range(len(ft_prev.index.values)):
    pl = axes_plot[f][0].text(0.5, t+0.5, str(round(ft_prev.iloc[t, 0]*100, 2)), color='w', ha='center', va='center')
    abun_vals = ft.loc[ft_prev.index.values[t], :].values
    box = axes_plot[f][1].boxplot(abun_vals, positions=[t+0.5], widths=0.3, showfliers=False, vert=False)
    for item in ['boxes', 'whiskers', 'fliers', 'medians', 'caps']: bi = plt.setp(box[item], color='k')
    #tx = axes_plot[f][1].text(np.median(abun_vals), t+0.8, str(round(np.median(abun_vals), 2)), ha='center', va='bottom', fontsize=7, bbox=dict(facecolor='white', alpha=0.8))
    yticks.append(str(round(np.median(abun_vals), 2))+'%')
  plt.sca(axes_plot[f][1])
  yl = axes_plot[f][1].set_ylim([0, len(ft_prev.index.values)]), plt.yticks([t+0.5 for t in range(len(ft_prev.index.values))], yticks)
  axes_plot[f][1].yaxis.tick_right()
  xl = plt.xlabel('Relative abundance (%)', fontweight='bold')
  yl = axes_plot[f][0].set_ylabel(titles[f], fontweight='bold')

plt.subplots_adjust(wspace=0.8, hspace=0.5)
plt.savefig(folder+'figures/adults_prevalence_ASV_genus_heatmap.png', dpi=600, bbox_inches='tight')
```

Adults beta diversity:
## Calculate beta diversity

Phylogenetic RPCA:
```{bash, eval=FALSE}
conda activate qiime2-amplicon-2024.2
mkdir phylo_rpca

#edited header columns to Feature ID and Taxon
qiime tools import \
  --type 'FeatureData[Taxonomy]' \
  --input-path taxonomy_min_2000.txt \
  --output-path taxonomy_min_2000.qza

biom convert -i feature-table_min_2000.txt -o feature-table_min_2000.biom --table-type="OTU table" --to-hdf5
qiime tools import \
  --input-path feature-table_min_2000.biom \
  --type 'FeatureTable[Frequency]' \
  --input-format BIOMV210Format \
  --output-path feature-table_min_2000.qza

qiime dev refresh-cache
pip install gemelli
qiime gemelli phylogenetic-rpca-with-taxonomy \
    --i-table feature-table_min_2000.qza \
    --i-phylogeny asvs-tree.qza \
    --m-taxonomy-file taxonomy_min_2000.qza \
    --p-min-feature-count 0 \
    --p-min-sample-count 0 \
    --o-biplot phylo_rpca/phylo-ordination.qza \
    --o-distance-matrix phylo_rpca/phylo-distance.qza \
    --o-counts-by-node-tree phylo_rpca/phylo-tree.qza \
    --o-counts-by-node phylo_rpca/phylo-table.qza \
    --o-t2t-taxonomy phylo_rpca/phylo-taxonomy.qza
    
qiime tools export \
  --input-path phylo_rpca/phylo-ordination.qza \
  --output-path phylo_rpca

qiime tools export \
  --input-path phylo_rpca/phylo-distance.qza \
  --output-path phylo_rpca
```

## Tree and heatmap

```{python}
fig = plt.figure(figsize=(22,16.5))

tree_ax = plt.subplot2grid((44,75),(1,0), rowspan=20, colspan=10, frameon=False)
prev_ax = plt.subplot2grid((44,75),(1,22), rowspan=20, colspan=2)
mean_abun_ax = plt.subplot2grid((44,75),(1,19), rowspan=20, colspan=2, frameon=False)
abun_title = plt.subplot2grid((44,75),(21,25), rowspan=1, colspan=44, frameon=False)
gender_ax = plt.subplot2grid((44,75),(1,25), rowspan=20, colspan=6)
gender_da = plt.subplot2grid((44,75),(1,31), rowspan=20, colspan=1, frameon=False)
ethnicity_ax = plt.subplot2grid((44,75),(1,33), rowspan=20, colspan=6)
ethnicity_da = plt.subplot2grid((44,75),(1,39), rowspan=20, colspan=1, frameon=False)
condition_ax = plt.subplot2grid((44,75),(1,41), rowspan=20, colspan=8)
condition_da = plt.subplot2grid((44,75),(1,49), rowspan=20, colspan=1, frameon=False)
age_ax = plt.subplot2grid((44,75),(1,51), rowspan=20, colspan=23)
age_da = plt.subplot2grid((44,75),(1,74), rowspan=20, colspan=1, frameon=False)

prev_labels = plt.subplot2grid((44,75),(0,22), rowspan=1, colspan=2, frameon=False)
gender_labels = plt.subplot2grid((44,75),(0,25), rowspan=1, colspan=6)
ethnicity_labels = plt.subplot2grid((44,75),(0,33), rowspan=1, colspan=6)
condition_labels = plt.subplot2grid((44,75),(0,41), rowspan=1, colspan=8)
age_labels = plt.subplot2grid((44,75),(0,51), rowspan=1, colspan=23)
mean_abun_labels = plt.subplot2grid((44,75),(0,19), rowspan=1, colspan=2, frameon=False)
ax_rem = [tree_ax, prev_ax, gender_ax, ethnicity_ax, age_ax, prev_labels, gender_labels, ethnicity_labels, age_labels, abun_title, mean_abun_labels, condition_labels, condition_ax, gender_da, ethnicity_da, condition_da, age_da]
for ax in ax_rem:
  xt = ax.set_xticks([]), ax.set_yticks([])
ax_lab = [gender_labels, ethnicity_labels, condition_labels, age_labels]
labels_colors = [[[1, 2, 3], colors_gender, ['M', 'F', 'GD'], ['k', 'w', 'w']], [[1, 2, 3], colors_ethnicity, ['EA', 'SA', 'W'], ['w', 'w', 'w']], [[1, 2, 3, 4], colors_condition, ['None', 'Phys.', 'Ment.', 'Both'], ['k', 'k', 'k', 'k']], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], colors_age, ['5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18'], ['k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k']]]
for l in range(len(ax_lab)):
  print(labels_colors[l][2])
  if labels_colors[l] == []: continue
  locs, colors, names, font_col = labels_colors[l][0], labels_colors[l][1], labels_colors[l][2], labels_colors[l][3]
  if l < 3: ba = ax_lab[l].bar(locs, [1 for c in locs], color=[colors[c] for c in locs], width=1, edgecolor='k')
  else: ba = ax_lab[l].bar(locs, [1 for c in locs], color='w', width=1, edgecolor='k')
  tx = [ax_lab[l].text(locs[t], 0.5, names[t].replace('Ment.', 'P/NDD'), ha='center', va='center', color=font_col[t], fontsize=10) for t in range(len(locs))]
  li = ax_lab[l].set_xlim([locs[0]-0.5, locs[-1]+0.5]), ax_lab[l].set_ylim([0, 1])

ti = abun_title.set_title('Genus relative abundance (%)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', fontweight='bold')
  
ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
ft = ft.loc[:, md.index.values]
tree_name = folder+'files/tree_genus.nwk'
ft_relabun = ft.divide(ft.sum(axis=0), axis=1).multiply(100)
ft_relabun['Mean'] = ft_relabun.mean(axis=1)
ft_relabun = ft_relabun.sort_values(by=['Mean'], ascending=False)
ft_relabun.drop('Mean', axis=1, inplace=True)
ft_relabun = ft_relabun.head(20)
taxa = list(set(list(ft_relabun.index.values)))

tax_dict = {}
taxonomy = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
for row in taxonomy.index.values:
  tax_dict[row] = taxonomy.loc[row, 'Genus']
  
tree = Tree(tree_name, format=1)
plt.rcParams["lines.linewidth"] = 1

tree.prune(taxa)
tree_name = tree_name.replace('.nwk', '_reduced.nwk')
tree.write(outfile=tree_name, format=1)
tree = Phylo.read(tree_name, "newick")
leaves_first = draw_tree(tree, axes=tree_ax, end_same=False, plot_labels=False)
leaves = draw_tree(tree, axes=tree_ax, end_same=True, plot_labels=False)

order = []
count = 1
for leaf in leaves[1:]:
  if leaf[0] in ft_relabun.index.values:
    this_name = tax_dict[leaf[0]]
    if '_[' in this_name: leaf_name = this_name.replace('g__', ' ').replace('_[', ' [')
    else: leaf_name = '  $'+this_name.split('g__')[1]+'$'
    pl = tree_ax.plot([leaves_first[count][1], leaf[1]], [leaf[2], leaf[2]], 'k--')
    tx = tree_ax.text(leaf[1], leaf[2], leaf_name, va=leaf[4], ha=leaf[5])
    order.append(this_name)
  count += 1

ft_relabun = ft_relabun.rename(index=tax_dict)
ft_relabun = ft_relabun.loc[order, :]

yl = tree_ax.set_ylim([0.5, leaves[-1][2]+0.5])
ft_prev = ft_relabun.copy(deep=True)
ft_prev[ft_prev > 0] = 1
ft_prev['Prevalence'] = ft_prev.mean(axis=1)
ft_prev = ft_prev.loc[:, ['Prevalence']]
mi, ma = ft_prev.min(axis=0).values[0], ft_prev.max(axis=0).values[0]
mid = np.mean([mi, ma])
pa = prev_ax.pcolor(ft_prev, edgecolor='k', cmap='Blues')
for r in range(len(ft_prev.index.values)):
  val = ft_prev.iloc[r, :].values[0]
  if val <= mid: col = 'k'
  else: col = 'w'
  tx = prev_ax.text(0.5, r+0.5, str(round(val, 2)), va='center', ha='center', color=col)
yt = prev_ax.set_yticks([])
xt = prev_ax.set_xticks([])
ti = prev_labels.set_title('Prev.', fontweight='bold')

hm_groups = ['gender', 'ethnicity', 'physical_mental_condition', 'age']
hm_titles = ['Gender', 'Ethnicity', 'Diagnosed health\ncondition', 'Age']
da_axes = [gender_da, ethnicity_da, condition_da, age_da]
hm_axes = [gender_ax, ethnicity_ax, condition_ax, age_ax]
hm_axes_labels = [gender_labels, ethnicity_labels, condition_labels, age_labels]
hm_maps = ['viridis', 'cividis', 'inferno', 'plasma']
for g in range(len(hm_groups)):
  da = pd.read_csv(folder+'differential_abundance/'+hm_groups[g]+'_maaslin.csv', index_col=0, header=0)
  ft_relabun_red = ft_relabun.copy(deep=True)
  rename_sample = {}
  for col in ft_relabun_red.columns:
    st = md.loc[col, hm_groups[g]]
    if g == 3:
      st = int(st)
    rename_sample[col] = st
  ft_relabun_red = ft_relabun_red.rename(columns=rename_sample)
  ft_relabun_red = ft_relabun_red.groupby(by=ft_relabun_red.columns, axis=1).mean()
  ft_norm = ft_relabun_red.copy(deep=True).transpose()
  ft_norm = ft_norm.divide(ft_norm.max(axis=0), axis=1).transpose()
  ha = hm_axes[g].pcolor(ft_norm, edgecolor='k', cmap=hm_maps[g])
  mid = np.mean([max(ft_norm.max(axis=1).values), min(ft_norm.min(axis=1).values)])
  for r in range(len(ft_norm.index.values)):
    for c in range(len(ft_norm.columns)):
      norm_val = ft_norm.iloc[r, c]
      val = ft_relabun_red.iloc[r, c]
      if norm_val < mid: col = 'w'
      else: col = 'k'
      if val >= 10: val = int(val)
      elif val > 1: val = round(val, 1)
      else: val = round(val, 2)
      if g > 1: fs = 8
      else: fs = 8
      tx = hm_axes[g].text(c+0.5, r+0.5, str(val), va='center', ha='center', color=col, fontsize=fs)
      name = ft_norm.index.values[r]
      try:
        sig_da = da.loc[name, 'maaslin_qval_abun']
        if sig_da <= 0.1:
          sc = da_axes[g].scatter(0.5, r+0.5, marker='*', color='k')
      except:
        sig_da = min(da.loc[name, 'maaslin_qval_abun'])
        if sig_da <= 0.1:
          sc = da_axes[g].scatter(0.5, r+0.5, marker='*', color='k')
  yt = hm_axes[g].set_yticks([])
  xt = hm_axes[g].set_xticks([])
  ti = hm_axes_labels[g].set_title(hm_titles[g], fontweight='bold')
  yt = hm_axes_labels[g].set_yticks([])
  yt = hm_axes_labels[g].set_xticks([])
  yl = da_axes[g].set_ylim([0, r+1]), da_axes[g].set_xlim([0, 1])

for r in range(len(ft_relabun_red.index.values)):
  mean = np.mean(ft_relabun_red.iloc[r, :].values)
  sc = mean_abun_ax.scatter(0.5, r, color='k', s=mean*15)

yl = mean_abun_ax.set_ylim([-0.5, r+0.5]), mean_abun_ax.set_xticks([]), mean_abun_ax.set_yticks([])
ti = mean_abun_labels.set_title('Mean\nabun.', fontweight='bold', linespacing=0.8)

handles = [Line2D([0], [0], marker='*', color='w', label='Significantly differentially abundant', markerfacecolor='k', markeredgecolor='k', markersize=12)]
leg = tree_ax.legend(handles=handles, loc='upper left', bbox_to_anchor=(0,1.1))

plt.savefig(folder+'figures/tree_and_heatmap.png', dpi=600, bbox_inches='tight')
```

With adults:
```{python}
fig = plt.figure(figsize=(24,24))

tree_ax = plt.subplot2grid((44,82),(1,0), rowspan=20, colspan=10, frameon=False)
mean_abun_ax = plt.subplot2grid((44,82),(1,19), rowspan=20, colspan=2, frameon=False)
mean_abun_adults_ax = plt.subplot2grid((44,82),(1,21), rowspan=20, colspan=2, frameon=False)
prev_ax = plt.subplot2grid((44,82),(1,25), rowspan=20, colspan=2)
prev_adults_ax = plt.subplot2grid((44,82),(1,27), rowspan=20, colspan=2)

gender_ax = plt.subplot2grid((44,82),(1,30), rowspan=20, colspan=4)
gender_adults_ax = plt.subplot2grid((44,82),(1,34), rowspan=20, colspan=4)

age_ax = plt.subplot2grid((44,82),(1,39), rowspan=20, colspan=21)
age_adults_ax = plt.subplot2grid((44,82),(1,60), rowspan=20, colspan=21)

prev_labels = plt.subplot2grid((44,82),(0,25), rowspan=1, colspan=4, frameon=False)
#prev_adults_labels = plt.subplot2grid((44,75),(0,27), rowspan=1, colspan=2, frameon=False)

gender_labels = plt.subplot2grid((44,82),(0,30), rowspan=1, colspan=4, frameon=False)
gender_adults_labels = plt.subplot2grid((44,82),(0,34), rowspan=1, colspan=4, frameon=False)

mean_abun_labels = plt.subplot2grid((44,82),(0,19), rowspan=1, colspan=4, frameon=False)
# mean_abun_adults_labels = plt.subplot2grid((44,75),(0,21), rowspan=1, colspan=2, frameon=False)
age_labels = plt.subplot2grid((44,82),(0,39), rowspan=1, colspan=21)
age_adults_labels = plt.subplot2grid((44,82),(0,60), rowspan=1, colspan=21)
ax_rem = [tree_ax, prev_ax, prev_adults_ax, age_ax, age_adults_ax, prev_labels, age_labels, age_adults_labels, mean_abun_labels, gender_labels, gender_adults_labels]
for ax in ax_rem:
  xt = ax.set_xticks([]), ax.set_yticks([])
ax_lab = [age_labels, age_adults_labels, prev_labels, mean_abun_labels, gender_labels, gender_adults_labels]
labels_colors = [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], colors_age, ['5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18'], ['k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k']], [[1, 2, 3, 4, 5, 6, 7], colors_age, ['35-40', '41-45', '46-50', '51-55', '56-60', '61-65', '> 65'], ['k', 'k', 'k', 'k', 'k', 'k', 'k']], [[1, 2], colors_age, ['Child', 'Adult'], ['k', 'k']], [[1, 2], colors_age, ['Child', 'Adult'], ['k', 'k']], [[1,2], colors_gender, ['M', 'F'], ['k', 'w']], [[1,2], colors_gender, ['M', 'F'], ['k', 'w']]]
for l in range(len(ax_lab)):
  print(labels_colors[l][2])
  if labels_colors[l] == []: continue
  locs, colors, names, font_col = labels_colors[l][0], labels_colors[l][1], labels_colors[l][2], labels_colors[l][3]
  if l < 4: ba = ax_lab[l].bar(locs, [1 for c in locs], color='w', width=1, edgecolor='k')
  else: ba = ax_lab[l].bar(locs, [1 for c in locs], color=[colors[c] for c in locs], width=1, edgecolor='k')
  tx = [ax_lab[l].text(locs[t], 0.5, names[t], ha='center', va='center', color=font_col[t], fontsize=10) for t in range(len(locs))]
  li = ax_lab[l].set_xlim([locs[0]-0.5, locs[-1]+0.5]), ax_lab[l].set_ylim([0, 1])

ti = age_labels.set_title('Age\nChildren', fontweight='bold')
ti = age_adults_labels.set_title('Age\nAdults', fontweight='bold')
ti = prev_labels.set_title('Prevalence', fontweight='bold')
ti = gender_labels.set_title('Gender\nChildren', fontweight='bold')
ti = gender_adults_labels.set_title('Sex\nAdults', fontweight='bold')
ti = mean_abun_labels.set_title('Mean\nabundance', fontweight='bold')

ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
ft = ft.loc[:, md.index.values]
tree_name = folder+'files/tree_genus.nwk'
ft_relabun = ft.divide(ft.sum(axis=0), axis=1).multiply(100)

da = pd.read_csv(folder+'differential_abundance/age_maaslin.csv', index_col=0, header=0)
da = da[da['maaslin_qval_abun'] <= 0.1]

da_gender = pd.read_csv(folder+'differential_abundance/gender_maaslin.csv', index_col=0, header=0)
da_gender = da_gender[da_gender['maaslin_qval_abun'] <= 0.1]

tax_dict = {}
taxonomy = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
for row in taxonomy.index.values:
  tax_dict[row] = taxonomy.loc[row, 'Genus']

reverse_dict = {}
for row in ft_relabun.index.values:
  reverse_dict[tax_dict[row]] = row
  
da_tax = list(da_gender.index.values)+list(da.index.values)
da_tax = list(set(da_tax))
  
da_keeping = []
for tax in da_tax:
  da_keeping.append(reverse_dict[tax])

da_keeping = list(set(da_keeping))
ft_relabun = ft_relabun.loc[da_keeping, :]
taxa = da_keeping

tree = Tree(tree_name, format=1)
plt.rcParams["lines.linewidth"] = 1

tree.prune(taxa)
tree_name = tree_name.replace('.nwk', '_reduced.nwk')
tree.write(outfile=tree_name, format=1)
tree = Phylo.read(tree_name, "newick")
leaves_first = draw_tree(tree, axes=tree_ax, end_same=False, plot_labels=False)
leaves = draw_tree(tree, axes=tree_ax, end_same=True, plot_labels=False)

order = []
count = 1
for l in range(len(leaves)):
  if l == 0: continue
  leaf = leaves[l]
  if '__' in leaf[0]: continue
  try:
  # if leaf[0] in ft_relabun.index.values:
    this_name = tax_dict[leaf[0]]
    if '_[' in this_name: leaf_name = this_name.replace('g__', ' ').replace('_[', ' [')
    elif 'Unclassified' in this_name: leaf_name = this_name
    else: leaf_name = '  $'+this_name.split('g__')[1]+'$'
    pl = tree_ax.plot([leaves_first[l][1], leaf[1]], [leaf[2], leaf[2]], 'k--')
    tx = tree_ax.text(leaf[1], leaf[2], leaf_name, va=leaf[4], ha=leaf[5])
    order.append(this_name)
    count += 1
  except:
    print(leaf)

ft_relabun = ft_relabun.rename(index=tax_dict)
ft_relabun = ft_relabun.loc[order, :]

ft_adults = pd.read_csv(folder_atpath+'feature_table_genus.csv', index_col=0, header=0)
ft_adults_relabun = ft_adults.divide(ft_adults.sum(axis=0), axis=1).multiply(100)
rename_adults = {}
for row in ft_adults_relabun.index.values:
  if row[0] == ' ':
    rename_adults[row] = row[1:]
ft_adults_relabun = ft_adults_relabun.rename(index=rename_adults)
for tax in order:
  if tax not in ft_adults_relabun.index.values:
    ft_adults_relabun.loc[tax, :] = 0
ft_adults_relabun = ft_adults_relabun.loc[order, :]

md_adults = pd.read_csv(folder_atpath+'FrailtyParticipants_metadata.csv', index_col=0, header=0)
keep_samples = [sample for sample in ft_adults_relabun.columns if sample in md_adults.index.values]
ft_adults_relabun = ft_adults_relabun.loc[:, keep_samples]
md_adults = md_adults.loc[keep_samples, :]
age_groups = [[35, 40], [40, 45], [45, 50], [50, 55], [55, 60], [60, 65], [65, 70]]
name_group = [35, 40, 45, 50, 55, 60, 65]
groups = [[], [], [], [], [], [], []]
adult_age_rename = {}
for sample in keep_samples:
  adult_age = md_adults.loc[sample, 'AGE']
  got_age = False
  for g in range(len(age_groups)):
    if age_groups[g][0] <= adult_age < age_groups[g][1]:
      groups[g].append(sample)
      got_age = True
      adult_age_rename[sample] = name_group[g]
      break
  if not got_age:
    groups[-1].append(sample)
    adult_age_rename[sample] = name_group[g]

adult_sex_rename = {}
for sample in keep_samples:
  adult_sex = md_adults.loc[sample, 'Sex']
  adult_sex_rename[sample] = adult_sex

yl = tree_ax.set_ylim([0.5, leaves[-1][2]+0.5])
ft_prev = ft_relabun.copy(deep=True)
ft_prev[ft_prev > 0] = 1
ft_prev['Prevalence'] = ft_prev.mean(axis=1)
ft_prev = ft_prev.loc[:, ['Prevalence']]
mi, ma = ft_prev.min(axis=0).values[0], ft_prev.max(axis=0).values[0]
mid = np.mean([mi, ma])
pa = prev_ax.pcolor(ft_prev, edgecolor='k', cmap='Blues')
for r in range(len(ft_prev.index.values)):
  val = ft_prev.iloc[r, :].values[0]
  if val <= mid: col = 'k'
  else: col = 'w'
  tx = prev_ax.text(0.5, r+0.5, str(round(val, 2)), va='center', ha='center', color=col)
yt = prev_ax.set_yticks([])
xt = prev_ax.set_xticks([])

hm_groups = ['age']
hm_titles = ['Age']
hm_axes = [age_ax]
hm_axes_labels = [age_labels]
hm_maps = ['plasma']
for g in range(len(hm_groups)):
  ft_relabun_red = ft_relabun.copy(deep=True)
  rename_sample = {}
  for col in ft_relabun_red.columns:
    st = md.loc[col, hm_groups[g]]
    st = int(st)
    rename_sample[col] = st
  ft_relabun_red = ft_relabun_red.rename(columns=rename_sample)
  ft_relabun_red = ft_relabun_red.groupby(by=ft_relabun_red.columns, axis=1).mean()
  ft_adults_relabun_red = ft_adults_relabun.copy(deep=True)
  ft_adults_relabun_red = ft_adults_relabun_red.rename(columns=adult_age_rename)
  ft_adults_relabun_red = ft_adults_relabun_red.groupby(by=ft_adults_relabun_red.columns, axis=1).mean()
  samples_child = list(ft_relabun_red.columns)
  samples_adult = list(ft_adults_relabun_red.columns)
  ft_overall = pd.concat([ft_relabun_red, ft_adults_relabun_red])
  ft_overall = ft_overall.groupby(by=ft_overall.index, axis=0).sum()
  ft_overall = ft_overall.loc[order, :]
  ft_norm = ft_overall.copy(deep=True).transpose()
  ft_norm = ft_norm.divide(ft_norm.max(axis=0), axis=1).transpose()
  ft_norm_adult = ft_norm.copy(deep=True).loc[order, samples_adult]
  ft_norm = ft_norm.loc[order, samples_child]
  ha = hm_axes[g].pcolor(ft_norm, edgecolor='k', cmap=hm_maps[g])
  ha = age_adults_ax.pcolor(ft_norm_adult, edgecolor='k', cmap=hm_maps[g])
  mid = np.mean([max(ft_norm.max(axis=1).values), min(ft_norm.min(axis=1).values)])
  ft_relabun_red = ft_relabun_red.loc[order, :]
  ft_adults_relabun_red = ft_adults_relabun_red.loc[order, :]
  for r in range(len(ft_norm.index.values)):
    for c in range(len(ft_norm.columns)):
      norm_val = ft_norm.iloc[r, c]
      val = ft_relabun_red.iloc[r, c]
      if norm_val < mid: col = 'w'
      else: col = 'k'
      if val >= 10: val = int(val)
      elif val > 1: val = round(val, 1)
      # elif val > 0.1: val = round(val, 2)
      else: val = round(val, 2)
      if g > 1: fs = 8
      else: fs = 8
      tx = hm_axes[g].text(c+0.5, r+0.5, str(val), va='center', ha='center', color=col, fontsize=fs)
  yt = hm_axes[g].set_yticks([]), hm_axes[g].set_xticks([])
  mid = np.mean([max(ft_norm_adult.max(axis=1).values), min(ft_norm_adult.min(axis=1).values)])
  for r in range(len(ft_norm_adult.index.values)):
    for c in range(len(ft_norm_adult.columns)):
      norm_val = ft_norm_adult.iloc[r, c]
      val = ft_adults_relabun_red.iloc[r, c]
      if norm_val < mid: col = 'w'
      else: col = 'k'
      if val >= 10: val = int(val)
      elif val > 1: val = round(val, 1)
      else: val = round(val, 2)
      if g > 1: fs = 8
      else: fs = 8
      tx = age_adults_ax.text(c+0.5, r+0.5, str(val), va='center', ha='center', color=col, fontsize=fs)
  yt = age_adults_ax.set_yticks([]), age_adults_ax.set_xticks([])
  
hm_groups = ['gender']
hm_titles = ['Gender']
hm_axes = [gender_ax]
hm_axes_labels = [gender_labels]
hm_maps = ['viridis']
for g in range(len(hm_groups)):
  ft_relabun_red = ft_relabun.copy(deep=True)
  rename_sample = {}
  for col in ft_relabun_red.columns:
    st = md.loc[col, hm_groups[g]]
    st = str(st)
    rename_sample[col] = st
  ft_relabun_red = ft_relabun_red.rename(columns=rename_sample)
  ft_relabun_red = ft_relabun_red.groupby(by=ft_relabun_red.columns, axis=1).mean()
  ft_relabun_red = ft_relabun_red.drop('3.0', axis=1)
  ft_adults_relabun_red = ft_adults_relabun.copy(deep=True)
  ft_adults_relabun_red = ft_adults_relabun_red.rename(columns=adult_sex_rename)
  ft_adults_relabun_red = ft_adults_relabun_red.groupby(by=ft_adults_relabun_red.columns, axis=1).mean()
  samples_child = list(ft_relabun_red.columns)
  samples_adult = list(ft_adults_relabun_red.columns)
  ft_overall = pd.concat([ft_relabun_red, ft_adults_relabun_red])
  ft_overall = ft_overall.groupby(by=ft_overall.index, axis=0).sum()
  ft_overall = ft_overall.loc[order, :]
  ft_norm = ft_overall.copy(deep=True).transpose()
  ft_norm = ft_norm.divide(ft_norm.max(axis=0), axis=1).transpose()
  ft_norm_adult = ft_norm.copy(deep=True).loc[order, samples_adult]
  ft_norm = ft_norm.loc[order, samples_child]
  ha = hm_axes[g].pcolor(ft_norm, edgecolor='k', cmap=hm_maps[g])
  ha = gender_adults_ax.pcolor(ft_norm_adult, edgecolor='k', cmap=hm_maps[g])
  mid = np.mean([max(ft_norm.max(axis=1).values), min(ft_norm.min(axis=1).values)])
  ft_relabun_red = ft_relabun_red.loc[order, :]
  ft_adults_relabun_red = ft_adults_relabun_red.loc[order, :]
  print(ft_adults_relabun_red)
  for r in range(len(ft_norm.index.values)):
    for c in range(len(ft_norm.columns)):
      norm_val = ft_norm.iloc[r, c]
      val = ft_relabun_red.iloc[r, c]
      if norm_val < mid: col = 'w'
      else: col = 'k'
      if val >= 10: val = int(val)
      elif val > 1: val = round(val, 1)
      # elif val > 0.1: val = round(val, 2)
      else: val = round(val, 2)
      if g > 1: fs = 8
      else: fs = 8
      tx = hm_axes[g].text(c+0.5, r+0.5, str(val), va='center', ha='center', color=col, fontsize=fs)
  yt = hm_axes[g].set_yticks([]), hm_axes[g].set_xticks([])
  mid = np.mean([max(ft_norm_adult.max(axis=1).values), min(ft_norm_adult.min(axis=1).values)])
  for r in range(len(ft_norm_adult.index.values)):
    for c in range(len(ft_norm_adult.columns)):
      norm_val = ft_norm_adult.iloc[r, c]
      val = ft_adults_relabun_red.iloc[r, c]
      if norm_val < mid: col = 'w'
      else: col = 'k'
      if val >= 10: val = int(val)
      elif val > 1: val = round(val, 1)
      # elif val > 0.1: val = round(val, 2)
      else: val = round(val, 2)
      if g > 1: fs = 8
      else: fs = 8
      tx = gender_adults_ax.text(c+0.5, r+0.5, str(val), va='center', ha='center', color=col, fontsize=fs)
  yt = gender_adults_ax.set_yticks([]), gender_adults_ax.set_xticks([])

for r in range(len(ft_relabun_red.index.values)):
  mean = np.mean(ft_relabun_red.iloc[r, :].values)
  sc = mean_abun_ax.scatter(0.5, r, color='k', s=mean*15)

yl = mean_abun_ax.set_ylim([-0.5, r+0.5]), mean_abun_ax.set_xticks([]), mean_abun_ax.set_yticks([])

yl = tree_ax.set_ylim([0.5, leaves[-1][2]+0.5])
ft_prev = ft_adults_relabun.copy(deep=True)
ft_prev[ft_prev > 0] = 1
ft_prev['Prevalence'] = ft_prev.mean(axis=1)
ft_prev = ft_prev.loc[:, ['Prevalence']]
mi, ma = ft_prev.min(axis=0).values[0], ft_prev.max(axis=0).values[0]
mid = np.mean([mi, ma])
pa = prev_adults_ax.pcolor(ft_prev, edgecolor='k', cmap='Blues')
for r in range(len(ft_prev.index.values)):
  val = ft_prev.iloc[r, :].values[0]
  if val <= mid: col = 'k'
  else: col = 'w'
  tx = prev_adults_ax.text(0.5, r+0.5, str(round(val, 2)), va='center', ha='center', color=col)
yt = prev_adults_ax.set_yticks([])
xt = prev_adults_ax.set_xticks([])

for r in range(len(ft_adults_relabun_red.index.values)):
  mean = np.mean(ft_adults_relabun_red.iloc[r, :].values)
  sc = mean_abun_adults_ax.scatter(0.5, r, color='k', s=mean*15)

yl = mean_abun_adults_ax.set_ylim([-0.5, r+0.5]), mean_abun_adults_ax.set_xticks([]), mean_abun_adults_ax.set_yticks([])

plt.savefig(folder+'figures/tree_and_heatmap_with_adults.png', dpi=600, bbox_inches='tight')
```

# Plots for each variable

## Age

```{python}
fig = plt.figure(figsize=(20,28))

pcoa = plt.subplot2grid((12,9),(0,0), rowspan=3, colspan=3)
pc_x = plt.subplot2grid((12,9),(3,0), colspan=3)
pc_y = plt.subplot2grid((12,9),(0,3), rowspan=3)

ax_alp_lab = plt.subplot2grid((36,27),(0,14), rowspan=4, colspan=13, frameon=False)
ti = ax_alp_lab.set_title('Alpha diversity', fontweight='bold')

alpha_1 = plt.subplot2grid((36,27),(0,14), rowspan=4, colspan=6)
alpha_2 = plt.subplot2grid((36,27),(4,14), rowspan=4, colspan=6)
alpha_3 = plt.subplot2grid((36,27),(8,14), rowspan=4, colspan=6)
alpha_4 = plt.subplot2grid((36,27),(0,21), rowspan=4, colspan=6)
alpha_5 = plt.subplot2grid((36,27),(4,21), rowspan=4, colspan=6)
alpha_6 = plt.subplot2grid((36,27),(8,21), rowspan=4, colspan=6)

abun_ax = plt.subplot2grid((72,54), (30,0), rowspan=30, colspan=22)
prev_ax = plt.subplot2grid((72,54), (30,23), rowspan=30, colspan=22)
abun_labels = plt.subplot2grid((72,54), (29,0), rowspan=1, colspan=22)
prev_labels = plt.subplot2grid((72,54), (29,23), rowspan=1, colspan=22)
maaslin_ax = plt.subplot2grid((72,54), (30,46), rowspan=30, colspan=4)
maaslin_prev_ax = plt.subplot2grid((72,54), (30,50), rowspan=30, colspan=4)
maaslin_labels = plt.subplot2grid((72,54), (29,46), rowspan=1, colspan=4)
maaslin_prev_labels = plt.subplot2grid((72,54), (29,50), rowspan=1, colspan=4)

ax_rem = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels, ax_alp_lab]
ax_lab = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels]
for ax in ax_rem:
  xt = ax.set_xticks([]), ax.set_yticks([])
labels_colors = [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], colors_age, ['5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18'], ['k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k'], 'Relative abundance (%)'], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], colors_age, ['5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18'], ['k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k'], 'Prevalence'],
[[1], colors_age, ['Abundance'], ['k'], ''], [[1], colors_age, ['Prevalence'], ['k'], '']]
for l in range(len(ax_lab)):
  if labels_colors[l] == []: continue
  locs, colors, names, font_col = labels_colors[l][0], labels_colors[l][1], labels_colors[l][2], labels_colors[l][3]
  ba = ax_lab[l].bar(locs, [1 for c in locs], color='w', width=1, edgecolor='k')
  tx = [ax_lab[l].text(locs[t], 0.5, names[t], ha='center', va='center', color=font_col[t], fontsize=10) for t in range(len(locs))]
  li = ax_lab[l].set_xlim([locs[0]-0.5, locs[-1]+0.5]), ax_lab[l].set_ylim([0, 1])
  ti = ax_lab[l].set_title(labels_colors[l][4], fontweight='bold')

ti = maaslin_labels.set_title(' Differential abundance', fontweight='bold', loc='left')

ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
ft = ft.loc[:, md.index.values]

tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
rename_tax = {}
for row in tax.index.values:
  rename_tax[row] = tax.loc[row, 'Genus']

ft = ft.rename(index=rename_tax)
ft_prev = ft.copy(deep=True)
ft_prev[ft_prev > 0] = 1
ft_relabun = ft.copy(deep=True)
ft_relabun = ft_relabun.divide(ft_relabun.sum(axis=0), axis=1).multiply(100)
ft_relabun['Mean'] = ft_relabun.mean(axis=1)
ft_relabun = ft_relabun.sort_values(by=['Mean'], ascending=False)
ft_relabun.drop('Mean', axis=1, inplace=True)

all_da_sig = pd.read_csv(folder+'differential_abundance/age_maaslin.csv', index_col=0, header=0)

#get taxa to plot
all_sig_tax = all_da_sig[all_da_sig['maaslin_qval_abun'] <= 0.1]
most_abun_tax = ft_relabun.head(20)
all_tax_keeping = list(all_sig_tax.index.values)+list(most_abun_tax.index.values)
all_tax_keeping = list(set(all_tax_keeping))
tax_keeping_order = [row for row in ft_relabun.index.values if row in all_tax_keeping]

ft_relabun = ft_relabun.loc[tax_keeping_order, :]
tax_reverse = list(ft_relabun.index.values)
tax_reverse.reverse()
ft_relabun = ft_relabun.loc[tax_reverse, :]
ft_prev = ft_prev.loc[tax_reverse, :]
all_da = all_da_sig.loc[tax_reverse, :]

hm_groups = ['age', 'age']
hm_axes = [abun_ax, prev_ax]
hm_maps = ['plasma', 'Blues']
fts = [ft_relabun, ft_prev]
for g in range(len(hm_groups)):
  ft = fts[g].copy(deep=True)
  rename_sample = {}
  for col in ft.columns:
    st = md.loc[col, hm_groups[g]]
    st = int(st)
    rename_sample[col] = st
  ft = ft.rename(columns=rename_sample)
  ft = ft.groupby(by=ft.columns, axis=1).mean()
  ft_norm = ft.copy(deep=True).transpose()
  if g == 0:
    ft_norm = ft_norm.divide(ft_norm.max(axis=0), axis=1).transpose()
  else:
    ft_norm = ft_norm.transpose()
  ha = hm_axes[g].pcolor(ft_norm, edgecolor='k', cmap=hm_maps[g])
  mid = np.mean([max(ft_norm.max(axis=1).values), min(ft_norm.min(axis=1).values)])
  for r in range(len(ft_norm.index.values)):
    for c in range(len(ft_norm.columns)):
      norm_val = ft_norm.iloc[r, c]
      val = ft.iloc[r, c]
      if norm_val < mid:
        if g == 0: col = 'w'
        else: col = 'k'
      else:
        if g == 0: col = 'k'
        else: col = 'w'
      if val >= 10: val = int(val)
      elif val > 1: val = round(val, 1)
      else: val = round(val, 2)
      if g > 1: fs = 8
      else: fs = 8
      tx = hm_axes[g].text(c+0.5, r+0.5, str(val), va='center', ha='center', color=col, fontsize=fs)
  plt.sca(hm_axes[g])
  if g == 1: yt = hm_axes[g].set_yticks([])
  else: 
    taxa_names = []
    for name in ft_relabun.index.values:
      if '_[' in name: taxa_name = name.replace('g__', ' ').replace('_[', ' [')
      else: taxa_name = '  $'+name.split('g__')[1]+'$'
      taxa_names.append(taxa_name)
    yt = plt.yticks([a+0.5 for a in range(len(ft_relabun.index.values))], taxa_names)
  xt = hm_axes[g].set_xticks([]), hm_axes[g].set_xlabel('Age (years)', fontweight='bold')

axes = [maaslin_ax, maaslin_prev_ax]
names = ['maaslin_coef_abun', 'maaslin_coef_prev']
qvals = ['maaslin_qval_abun', 'maaslin_qval_prev']
min_max = []
for n in range(len(names)):
  vals = all_da[names[n]].values
  vals = [abs(v) for v in vals]
  m = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=-max(vals), vmax=max(vals)), cmap=cm.RdBu_r)
  min_max.append(m)

for t in range(len(all_da.index.values)):
  tax = all_da.index.values[t]
  for l in range(len(names)):
    this_sig = all_da.loc[tax, qvals[l]]
    if this_sig <= 0.1:
      sig = True
    else:
      sig = False
    if sig:
      val = all_da.loc[tax, names[l]]
      ba = axes[l].barh(t, 1, height=1, left=0, color=min_max[l].to_rgba(val), alpha=0.5, edgecolor='k')
      tx = axes[l].text(0.5, t, str(round(val, 2)), color='k', ha='center', va='center')
    else:
      ba = axes[l].barh(t, 1, height=1, left=0, color='gray', alpha=0.5, edgecolor='k')

for ax in axes:
  plt.sca(ax)
  yt = plt.yticks([]), plt.xticks([])
  yl = plt.ylim([-0.5, t+0.5]), plt.xlim([0, 1])
  
pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_ordination_pca.csv', index_col=0, header=0)
prop_explain = [0.6386125734929017, 0.3023029246310683, 0.05908450187603021]
#pcoa plot
count = 0
all_ages = md.loc[:, 'age']
m = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=min(all_ages), vmax=max(all_ages)), cmap=cm.plasma)
colors_plot = [m.to_rgba(age) for age in all_ages]
sc = pcoa.scatter(pca.loc[md.index.values, 'PC1'], pca.loc[md.index.values, 'PC2'], marker='o', color=colors_plot, alpha=0.2)
sc = pc_x.scatter(pca.loc[md.index.values, 'PC1'], all_ages, marker='o', color='gray', alpha=0.2)
sc = pc_y.scatter(all_ages, pca.loc[md.index.values, 'PC2'], marker='o', color='gray', alpha=0.2)

plt.sca(pcoa)
ti = plt.title('Beta diversity: phylogenetic-RPCA', fontweight='bold')
xt = plt.xticks([])
al = plt.ylabel('PC2 ('+str(round(prop_explain[1]*100, 2))+'%)', fontweight='bold')
ax_colbar = inset_axes(pcoa, width="30%", height="8%", loc='upper left') 
plt.sca(ax_colbar)
cb = mpl.colorbar.ColorbarBase(ax_colbar, cmap=mpl.cm.plasma, norm=mpl.colors.Normalize(vmin=min(all_ages), vmax=max(all_ages)), orientation='horizontal')
xl = plt.xlabel('Age (years)', fontsize=8)

plt.sca(pc_x)
al = plt.ylabel('Age (years)', fontweight='bold'), plt.xlabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)', fontweight='bold')
# li = plt.plot(np.unique(pca.loc[md.index.values, 'PC1']), np.poly1d(np.polyfit(pca.loc[md.index.values, 'PC1'], all_ages, 1))(np.unique(pca.loc[md.index.values, 'PC1'])), 'k--')
age_means = {}
pca_vals = pca.loc[md.index.values, 'PC1'].values
for a in range(len(all_ages)):
  if round(pca_vals[a], 3) in age_means:
    age_means[round(pca_vals[a], 3)].append(all_ages[a])
  else:
    age_means[round(pca_vals[a], 3)] = [all_ages[a]]
pcv_plot, mean_age = [], []
for pcv in age_means:
  pcv_plot.append(pcv)
  mean_age.append(np.mean(age_means[pcv]))

order = np.argsort(pcv_plot)
pcv_plot_ordered = [pcv_plot[i] for i in order]
mean_age_ordered = [mean_age[i] for i in order]

fitted_poly = Polynomial.fit(pca.loc[md.index.values, 'PC1'], all_ages, deg=4)
w = fitted_poly(pcv_plot_ordered)

# w = lowess(mean_age_ordered, pcv_plot_ordered, frac=0.35, return_sorted=False)
li = plt.plot(pcv_plot_ordered, w, 'r-')
corr, p = spearmanr(pca.loc[md.index.values, 'PC1'], all_ages)
string = "Spearman's:\nR="+str(round(corr,3))+', $p$='+str(round(p,3))
tx = pc_x.text(0.98, 0.98, string, ha='right', va='top', transform=pc_x.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

plt.sca(pc_y)
al = plt.xlabel('Age (years)', fontweight='bold'), plt.yticks([])
age_means = {}
pca_vals = pca.loc[md.index.values, 'PC2'].values
for a in range(len(all_ages)):
  if int(all_ages[a]) in age_means:
    age_means[int(all_ages[a])].append(pca_vals[a])
  else:
    age_means[int(all_ages[a])] = [pca_vals[a]]
age_plot, mean_pcv = [], []
for age in age_means:
  age_plot.append(age)
  mean_pcv.append(np.mean(age_means[age]))

order = np.argsort(age_plot)
age_plot_ordered = [age_plot[i] for i in order]
mean_pcv_ordered = [mean_pcv[i] for i in order]

fitted_poly = Polynomial.fit(all_ages, pca.loc[md.index.values, 'PC2'], deg=4)
w = fitted_poly(age_plot_ordered)

# w = lowess(mean_pcv_ordered, age_plot_ordered, frac=0.35, return_sorted=False)
li = plt.plot(age_plot_ordered, w, 'r-')
corr, p = spearmanr(all_ages, pca.loc[md.index.values, 'PC2'])
string = "Spearman's:\nR="+str(round(corr,3))+', $p$='+str(round(p,3))
tx = pc_y.text(0.98, 0.98, string, ha='right', va='top', transform=pc_y.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

perm_stats = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)
p = round(perm_stats.loc['age', 'Univariate p'], 3)
if p < 0.001: p = '<0.001'
string_perm = 'PERMANOVA\nAge Univariate:\n$R^{2}$='+str(round(perm_stats.loc['age', 'Univariate R2'], 2))+', $p$='+str(p)+'\n\n'
p = round(perm_stats.loc['age', 'Basic strata p'], 3)
if p < 0.001: p = '<0.001'
string_perm += 'Age Multivariate:\n$R^{2}$='+str(round(perm_stats.loc['age', 'Basic strata R2'], 2))+', $p$='+str(p)
tx = pc_y.text(0.5, -0.15, string_perm, ha='center', va='top', transform=pc_y.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

alpha_metrics = ['chao1', 'faith_pd', 'observed_otus', 'shannon', 'simpson_e', 'simpson']
alpha_metric_name = ['Chao1 richness', "Faith's phylogenetic diversity", "Observed taxa", "Shannon diversity", "Simpson's evenness", "Simpson's index of diversity"]
alpha_axes = [alpha_1, alpha_2, alpha_3, alpha_4, alpha_5, alpha_6]
for a in range(len(alpha_metrics)):
  plt.sca(alpha_axes[a])
  alp = pd.read_csv(folder+'files/alpha_diversity/alpha_'+alpha_metrics[a]+'.csv', index_col=0, header=0)
  alp_stats = pd.read_csv(folder+'files/alpha_stats/'+alpha_metrics[a]+'_summary.csv', index_col=0, header=0)
  sc = alpha_axes[a].scatter(all_ages, alp.loc[md.index.values, 'Mean'], marker='o', color='gray', alpha=0.2)
  # li = plt.plot(np.unique(all_ages), np.poly1d(np.polyfit(all_ages, alp.loc[md.index.values, 'Mean'], 1))(np.unique(all_ages)), 'k--')
  age_means = {}
  alp_vals = alp.loc[md.index.values, 'Mean']
  for ag in range(len(all_ages)):
    if int(all_ages[ag]) in age_means:
      age_means[int(all_ages[ag])].append(alp_vals[ag])
    else:
      age_means[int(all_ages[ag])] = [alp_vals[ag]]
  age_plot, mean_alp = [], []
  for age in age_means:
    age_plot.append(age)
    mean_alp.append(np.mean(age_means[age]))
  order = np.argsort(age_plot)
  age_plot_ordered = [age_plot[i] for i in order]
  mean_alp_ordered = [mean_alp[i] for i in order]
  
  fitted_poly = Polynomial.fit(all_ages, alp.loc[md.index.values, 'Mean'], deg=4)
  w = fitted_poly(age_plot_ordered)
  
  # w = lowess(mean_alp_ordered, age_plot_ordered, frac=0.35, return_sorted=False)
  li = plt.plot(age_plot_ordered, w, 'r-')
  corr, p = spearmanr(all_ages, alp_vals)
  anov_p = round(alp_stats.loc['age', 'Univariate p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string = 'Age Univariate: F='+str(round(alp_stats.loc['age', 'Univariate F'], 2))+', $p$='+str(anov_p)+'\n'
  anov_p = round(alp_stats.loc['age', 'Basic p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string += 'Age Multivariate: F='+str(round(alp_stats.loc['age', 'Basic F'], 2))+', $p$='+str(anov_p)+'\n'
  string += "Spearman's: R="+str(round(corr,3))+', $p$='+str(round(p,3))
  if alpha_metrics[a] != 'simpson' and alpha_metrics[a] != 'shannon':
    tx = alpha_axes[a].text(0.96, 0.96, string, ha='right', va='top', transform=alpha_axes[a].transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))
  else:
    tx = alpha_axes[a].text(0.96, 0.04, string, ha='right', va='bottom', transform=alpha_axes[a].transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))
  yt = plt.ylabel(alpha_metric_name[a], fontweight='bold')
  if a in [2, 5]:
    xt = plt.xlabel('Age (years)', fontweight='bold')

plt.savefig(folder+'figures/age_overall_plot.png', dpi=600, bbox_inches='tight')
```

## Gender

```{python}
fig = plt.figure(figsize=(20,28))

pcoa = plt.subplot2grid((12,9),(0,0), rowspan=3, colspan=3)
pc_x = plt.subplot2grid((12,9),(3,0), colspan=3)
pc_y = plt.subplot2grid((12,9),(0,3), rowspan=3)

ax_alp_lab = plt.subplot2grid((36,28),(0,14), rowspan=4, colspan=14, frameon=False)
ti = ax_alp_lab.set_title('Alpha diversity', fontweight='bold')

alpha_1 = plt.subplot2grid((36,28),(0,14), rowspan=6, colspan=4)
alpha_2 = plt.subplot2grid((36,28),(6,14), rowspan=6, colspan=4)
alpha_3 = plt.subplot2grid((36,28),(0,19), rowspan=6, colspan=4)
alpha_4 = plt.subplot2grid((36,28),(6,19), rowspan=6, colspan=4)
alpha_5 = plt.subplot2grid((36,28),(0,24), rowspan=6, colspan=4)
alpha_6 = plt.subplot2grid((36,28),(6,24), rowspan=6, colspan=4)

abun_ax = plt.subplot2grid((72,54), (30,0), rowspan=30, colspan=22)
prev_ax = plt.subplot2grid((72,54), (30,23), rowspan=30, colspan=22)
abun_labels = plt.subplot2grid((72,54), (29,0), rowspan=1, colspan=22)
prev_labels = plt.subplot2grid((72,54), (29,23), rowspan=1, colspan=22)
maaslin_ax = plt.subplot2grid((72,54), (30,46), rowspan=30, colspan=4)
maaslin_prev_ax = plt.subplot2grid((72,54), (30,50), rowspan=30, colspan=4)
maaslin_labels = plt.subplot2grid((72,54), (29,46), rowspan=1, colspan=4)
maaslin_prev_labels = plt.subplot2grid((72,54), (29,50), rowspan=1, colspan=4)

ax_rem = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels, ax_alp_lab]
ax_lab = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels]
for ax in ax_rem:
  xt = ax.set_xticks([]), ax.set_yticks([])
labels_colors = [[[1, 2, 3], colors_gender, ['Male', 'Female', 'Trans/gender-diverse'], ['k', 'w', 'w'], 'Relative abundance (%)'], [[1, 2, 3], colors_gender, ['Male', 'Female', 'Trans/gender-diverse'], ['k', 'w', 'w'], 'Prevalence'], [[1], colors_age, ['Abundance'], ['k'], ''], [[1], colors_age, ['Prevalence'], ['k'], '']]
# labels_colors = [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], colors_age, ['5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18'], ['k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k'], 'Relative abundance (%)'], [[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14], colors_age, ['5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15', '16', '17', '18'], ['k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k', 'k'], 'Prevalence'], [[1], colors_age, ['Abundance'], ['k'], ''], [[1], colors_age, ['Prevalence'], ['k'], '']]
for l in range(len(ax_lab)):
  if labels_colors[l] == []: continue
  locs, colors, names, font_col = labels_colors[l][0], labels_colors[l][1], labels_colors[l][2], labels_colors[l][3]
  if l < 2: ba = ax_lab[l].bar(locs, [1 for c in locs], color=[colors[c] for c in locs], width=1, edgecolor='k')
  else: ba = ax_lab[l].bar(locs, [1 for c in locs], color='w', width=1, edgecolor='k')
  tx = [ax_lab[l].text(locs[t], 0.5, names[t], ha='center', va='center', color=font_col[t], fontsize=10) for t in range(len(locs))]
  li = ax_lab[l].set_xlim([locs[0]-0.5, locs[-1]+0.5]), ax_lab[l].set_ylim([0, 1])
  ti = ax_lab[l].set_title(labels_colors[l][4], fontweight='bold')

ti = maaslin_labels.set_title(' Differential abundance', fontweight='bold', loc='left')

ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
ft = ft.loc[:, md.index.values]

tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
rename_tax = {}
for row in tax.index.values:
  rename_tax[row] = tax.loc[row, 'Genus']

ft = ft.rename(index=rename_tax)
ft_prev = ft.copy(deep=True)
ft_prev[ft_prev > 0] = 1
ft_relabun = ft.copy(deep=True)
ft_relabun = ft_relabun.divide(ft_relabun.sum(axis=0), axis=1).multiply(100)
ft_relabun['Mean'] = ft_relabun.mean(axis=1)
ft_relabun = ft_relabun.sort_values(by=['Mean'], ascending=False)
ft_relabun.drop('Mean', axis=1, inplace=True)

all_da_sig = pd.read_csv(folder+'differential_abundance/gender_maaslin.csv', index_col=0, header=0)

#get taxa to plot
all_sig_tax = all_da_sig[all_da_sig['maaslin_qval_abun'] <= 0.1]
most_abun_tax = ft_relabun.head(20)
all_tax_keeping = list(all_sig_tax.index.values)+list(most_abun_tax.index.values)
all_tax_keeping = list(set(all_tax_keeping))
tax_keeping_order = [row for row in ft_relabun.index.values if row in all_tax_keeping]

ft_relabun = ft_relabun.loc[tax_keeping_order, :]
tax_reverse = list(ft_relabun.index.values)
tax_reverse.reverse()
ft_relabun = ft_relabun.loc[tax_reverse, :]
ft_prev = ft_prev.loc[tax_reverse, :]
all_da = all_da_sig.loc[tax_reverse, :]

hm_groups = ['gender', 'gender']
hm_axes = [abun_ax, prev_ax]
hm_maps = ['viridis', 'Blues']
fts = [ft_relabun, ft_prev]
for g in range(len(hm_groups)):
  ft = fts[g].copy(deep=True)
  rename_sample = {}
  for col in ft.columns:
    st = md.loc[col, hm_groups[g]]
    st = int(st)
    rename_sample[col] = st
  ft = ft.rename(columns=rename_sample)
  ft = ft.groupby(by=ft.columns, axis=1).mean()
  ft_norm = ft.copy(deep=True).transpose()
  if g == 0:
    ft_norm = ft_norm.divide(ft_norm.max(axis=0), axis=1).transpose()
  else:
    ft_norm = ft_norm.transpose()
  ha = hm_axes[g].pcolor(ft_norm, edgecolor='k', cmap=hm_maps[g])
  mid = np.mean([max(ft_norm.max(axis=1).values), min(ft_norm.min(axis=1).values)])
  for r in range(len(ft_norm.index.values)):
    for c in range(len(ft_norm.columns)):
      norm_val = ft_norm.iloc[r, c]
      val = ft.iloc[r, c]
      if norm_val < mid:
        if g == 0: col = 'w'
        else: col = 'k'
      else:
        if g == 0: col = 'k'
        else: col = 'w'
      if val >= 10: val = round(val, 1)
      elif val > 1: val = round(val, 2)
      elif val > 0.0001: val = round(val, 4)
      else: val = round(val, 6)
      if g > 1: fs = 10
      else: fs = 10
      tx = hm_axes[g].text(c+0.5, r+0.5, str(val), va='center', ha='center', color=col, fontsize=fs)
  plt.sca(hm_axes[g])
  if g == 1: yt = hm_axes[g].set_yticks([])
  else: 
    taxa_names = []
    for name in ft_relabun.index.values:
      if '_[' in name: taxa_name = name.replace('g__', ' ').replace('_[', ' [')
      elif 'g__' not in name: taxa_name = name
      else: taxa_name = name.replace('g__', ' $')+'$'
      taxa_names.append(taxa_name)
    yt = plt.yticks([a+0.5 for a in range(len(ft_relabun.index.values))], taxa_names)
  xt = hm_axes[g].set_xticks([])

axes = [maaslin_ax, maaslin_prev_ax]
names = ['maaslin_coef_abun', 'maaslin_coef_prev']
qvals = ['maaslin_qval_abun', 'maaslin_qval_prev']

for t in range(len(all_da.index.values)):
  tax = all_da.index.values[t]
  for l in range(len(names)):
    this_sig = all_da.loc[tax, qvals[l]]
    if this_sig <= 0.1:
      sig = True
    else:
      sig = False
    if sig:
      val = all_da.loc[tax, names[l]]
      ba = axes[l].barh(t, 1, height=1, left=0, color='#e67e22', alpha=0.5, edgecolor='k')
      sc = axes[l].scatter(0.5, t, marker='*', color='k')
    else:
      ba = axes[l].barh(t, 1, height=1, left=0, color='gray', alpha=0.5, edgecolor='k')

for ax in axes:
  plt.sca(ax)
  yt = plt.yticks([]), plt.xticks([])
  yl = plt.ylim([-0.5, t+0.5]), plt.xlim([0, 1])

pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_ordination_pca.csv', index_col=0, header=0)
prop_explain = [0.6386125734929017, 0.3023029246310683, 0.05908450187603021]
#pcoa plot
count = 0
all_genders = md.loc[:, 'gender']
colors_plot = [colors_gender[g] for g in all_genders]
sc = pcoa.scatter(pca.loc[md.index.values, 'PC1'], pca.loc[md.index.values, 'PC2'], marker='o', color=colors_plot, alpha=0.2)

groups_plotting_pc1, groups_plotting_pc2 = [], []
for gender in [1, 2, 3]:
  participants = md[md['gender'] == gender].index.values
  group_plotting_pc1 = pca.loc[participants, 'PC1']
  group_plotting_pc2 = pca.loc[participants, 'PC2']
  groups, axes = [group_plotting_pc1, group_plotting_pc2], [pc_x, pc_y]
  for g in range(len(groups)):
    if g == 0:
      box = axes[g].boxplot(groups[g], positions=[gender], patch_artist=True, vert=False, showfliers=False, widths=0.3)
      vp = axes[g].violinplot(groups[g], points=500, positions=[gender], showmeans=False, showextrema=False, showmedians=False, vert=False, side='high', widths=0.6)
      sc = axes[g].scatter(groups[g], np.random.normal(gender-0.3, scale=0.04, size=len(groups[g])), marker='o', color=colors_gender[gender], alpha=0.05)
    else:
      box = axes[g].boxplot(groups[g], positions=[gender], patch_artist=True, vert=True, showfliers=False, widths=0.3)
      vp = axes[g].violinplot(groups[g], points=500, positions=[gender], showmeans=False, showextrema=False, showmedians=False, vert=True, side='low', widths=0.6)
      sc = axes[g].scatter(np.random.normal(gender+0.3, scale=0.04, size=len(groups[g])), groups[g], marker='o', color=colors_gender[gender], alpha=0.05)
    for item in ['whiskers', 'medians', 'caps']: bi = plt.setp(box[item], color='k')
    for patch, color in zip(box['boxes'], [colors_gender[gender]]):
      patch.set_facecolor(color)
      patch.set_alpha(0.4)
    for idx, b in enumerate(vp['bodies']):
      b.set_color(colors_gender[gender])
      b.set_alpha(0.4)

plt.sca(pcoa)
ti = plt.title('Beta diversity: phylogenetic-RPCA', fontweight='bold')
xt = plt.xticks([])
al = plt.ylabel('PC2 ('+str(round(prop_explain[1]*100, 2))+'%)', fontweight='bold')
handles_gender = [Line2D([0], [0], marker='s', color='w', label=gen, markerfacecolor=colors_gender[gen], markersize=12) for gen in ['Male', 'Female', 'Trans/gender-diverse']]
# handles_ethnicity = [Line2D([0], [0], marker='s', color='w', label=eth, markerfacecolor=colors_ethnicity[eth], markersize=12) for eth in ['East Asian', 'South Asian', 'White']]
leg = pcoa.legend(handles=handles_gender, loc='lower right')
# leg = ax_pca2.legend(handles=handles_ethnicity, loc='upper right')

plt.sca(pc_x)
al = plt.xlabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)', fontweight='bold')
yt = plt.yticks([1, 2, 3], ['Male', 'Female', 'Trans/gender-\ndiverse'])

plt.sca(pc_y)
yt = plt.xticks([1, 2, 3], ['Male', 'Female', 'Trans/gender-\ndiverse'], rotation=90), plt.yticks([])

perm_stats = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)
p = round(perm_stats.loc['gender', 'Univariate p'], 3)
if p < 0.001: p = '<0.001'
string_perm = 'PERMANOVA\nUnivariate:\n$R^{2}$='+str(round(perm_stats.loc['gender', 'Univariate R2'], 4))+', $p$='+str(p)+'\n\n'
p = round(perm_stats.loc['gender', 'Basic strata p'], 3)
if p < 0.001: p = '<0.001'
string_perm += 'Multivariate:\n$R^{2}$='+str(round(perm_stats.loc['gender', 'Basic strata R2'], 4))+', $p$='+str(p)
tx = pc_y.text(0.5, -0.25, string_perm, ha='center', va='top', transform=pc_y.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

alpha_metrics = ['chao1', 'faith_pd', 'observed_otus', 'shannon', 'simpson_e', 'simpson']
alpha_metric_name = ['Chao1 richness', "Faith's phylogenetic diversity", "Observed taxa", "Shannon diversity", "Simpson's evenness", "Simpson's index of diversity"]
alpha_axes = [alpha_1, alpha_2, alpha_3, alpha_4, alpha_5, alpha_6]
for a in range(len(alpha_metrics)):
  plt.sca(alpha_axes[a])
  alp = pd.read_csv(folder+'files/alpha_diversity/alpha_'+alpha_metrics[a]+'.csv', index_col=0, header=0)
  alp_stats = pd.read_csv(folder+'files/alpha_stats/'+alpha_metrics[a]+'_summary.csv', index_col=0, header=0)
  for gender in [1, 2, 3]:
    participants = md[md['gender'] == gender].index.values
    group_plotting = alp.loc[participants, 'Mean']
    box = alpha_axes[a].boxplot(group_plotting, positions=[gender], patch_artist=True, vert=True, showfliers=False, widths=0.3)
    vp = alpha_axes[a].violinplot(group_plotting, points=500, positions=[gender], showmeans=False, showextrema=False, showmedians=False, vert=True, side='low', widths=0.6)
    sc = alpha_axes[a].scatter(np.random.normal(gender+0.3, scale=0.04, size=len(group_plotting)), group_plotting, marker='o', color=colors_gender[gender], alpha=0.05)
    print(alpha_metrics[a], gender, np.median(group_plotting), np.mean(group_plotting))
    for item in ['whiskers', 'medians', 'caps']: bi = plt.setp(box[item], color='k')
    for patch, color in zip(box['boxes'], [colors_gender[gender]]):
      patch.set_facecolor(color)
      patch.set_alpha(0.4)
    for idx, b in enumerate(vp['bodies']):
      b.set_color(colors_gender[gender])
      b.set_alpha(0.4)
  anov_p = round(alp_stats.loc['gender', 'Univariate p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string = 'Uni: F='+str(round(alp_stats.loc['gender', 'Univariate F'], 2))+', $p$='+str(anov_p)+'\n'
  anov_p = round(alp_stats.loc['gender', 'Basic p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string += 'Multi: F='+str(round(alp_stats.loc['gender', 'Basic F'], 2))+', $p$='+str(anov_p)
  tx = alpha_axes[a].text(0.96, 0.04, string, ha='right', va='bottom', transform=alpha_axes[a].transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))
  yt = plt.ylabel(alpha_metric_name[a], fontweight='bold')
  if a in [1, 3, 5]:
    xt = plt.xticks([1, 2, 3], ['Male', 'Female', 'Trans/gender-\ndiverse'], rotation=90)

plt.savefig(folder+'figures/gender_overall_plot.png', dpi=600, bbox_inches='tight')
```

## Ethnicity

```{python}
fig = plt.figure(figsize=(20,28))

pcoa = plt.subplot2grid((12,9),(0,0), rowspan=3, colspan=3)
pc_x = plt.subplot2grid((12,9),(3,0), colspan=3)
pc_y = plt.subplot2grid((12,9),(0,3), rowspan=3)

ax_alp_lab = plt.subplot2grid((36,28),(0,14), rowspan=4, colspan=14, frameon=False)
ti = ax_alp_lab.set_title('Alpha diversity', fontweight='bold')

alpha_1 = plt.subplot2grid((36,28),(0,14), rowspan=6, colspan=4)
alpha_2 = plt.subplot2grid((36,28),(6,14), rowspan=6, colspan=4)
alpha_3 = plt.subplot2grid((36,28),(0,19), rowspan=6, colspan=4)
alpha_4 = plt.subplot2grid((36,28),(6,19), rowspan=6, colspan=4)
alpha_5 = plt.subplot2grid((36,28),(0,24), rowspan=6, colspan=4)
alpha_6 = plt.subplot2grid((36,28),(6,24), rowspan=6, colspan=4)

abun_ax = plt.subplot2grid((72,54), (30,0), rowspan=30, colspan=22)
prev_ax = plt.subplot2grid((72,54), (30,23), rowspan=30, colspan=22)
abun_labels = plt.subplot2grid((72,54), (29,0), rowspan=1, colspan=22)
prev_labels = plt.subplot2grid((72,54), (29,23), rowspan=1, colspan=22)
maaslin_ax = plt.subplot2grid((72,54), (30,46), rowspan=30, colspan=4)
maaslin_prev_ax = plt.subplot2grid((72,54), (30,50), rowspan=30, colspan=4)
maaslin_labels = plt.subplot2grid((72,54), (29,46), rowspan=1, colspan=4)
maaslin_prev_labels = plt.subplot2grid((72,54), (29,50), rowspan=1, colspan=4)

ax_rem = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels, ax_alp_lab]
ax_lab = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels]
for ax in ax_rem:
  xt = ax.set_xticks([]), ax.set_yticks([])
labels_colors = [[[1, 2, 3], colors_ethnicity, ['East Asian', 'South Asian', 'White'], ['w', 'w', 'w'], 'Relative abundance (%)'], [[1, 2, 3], colors_ethnicity, ['East Asian', 'South Asian', 'White'], ['w', 'w', 'w'], 'Prevalence'], [[1], colors_age, ['Abundance'], ['k'], ''], [[1], colors_age, ['Prevalence'], ['k'], '']]
for l in range(len(ax_lab)):
  if labels_colors[l] == []: continue
  locs, colors, names, font_col = labels_colors[l][0], labels_colors[l][1], labels_colors[l][2], labels_colors[l][3]
  if l < 2: ba = ax_lab[l].bar(locs, [1 for c in locs], color=[colors[c] for c in locs], width=1, edgecolor='k')
  else: ba = ax_lab[l].bar(locs, [1 for c in locs], color='w', width=1, edgecolor='k')
  tx = [ax_lab[l].text(locs[t], 0.5, names[t], ha='center', va='center', color=font_col[t], fontsize=10) for t in range(len(locs))]
  li = ax_lab[l].set_xlim([locs[0]-0.5, locs[-1]+0.5]), ax_lab[l].set_ylim([0, 1])
  ti = ax_lab[l].set_title(labels_colors[l][4], fontweight='bold')

ti = maaslin_labels.set_title(' Differential abundance', fontweight='bold', loc='left')

ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
ft = ft.loc[:, md.index.values]

tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
rename_tax = {}
for row in tax.index.values:
  rename_tax[row] = tax.loc[row, 'Genus']

ft = ft.rename(index=rename_tax)
ft_prev = ft.copy(deep=True)
ft_prev[ft_prev > 0] = 1
ft_relabun = ft.copy(deep=True)
ft_relabun = ft_relabun.divide(ft_relabun.sum(axis=0), axis=1).multiply(100)
ft_relabun['Mean'] = ft_relabun.mean(axis=1)
ft_relabun = ft_relabun.sort_values(by=['Mean'], ascending=False)
ft_relabun.drop('Mean', axis=1, inplace=True)

all_da_sig = pd.read_csv(folder+'differential_abundance/ethnicity_maaslin.csv', index_col=0, header=0)

#get taxa to plot
all_sig_tax = all_da_sig[all_da_sig['maaslin_qval_abun'] <= 0.1]
most_abun_tax = ft_relabun.head(20)
all_tax_keeping = list(all_sig_tax.index.values)+list(most_abun_tax.index.values)
all_tax_keeping = list(set(all_tax_keeping))
tax_keeping_order = [row for row in ft_relabun.index.values if row in all_tax_keeping]

ft_relabun = ft_relabun.loc[tax_keeping_order, :]
tax_reverse = list(ft_relabun.index.values)
tax_reverse.reverse()
ft_relabun = ft_relabun.loc[tax_reverse, :]
ft_prev = ft_prev.loc[tax_reverse, :]
all_da = all_da_sig.loc[tax_reverse, :]

hm_groups = ['ethnicity', 'ethnicity']
hm_axes = [abun_ax, prev_ax]
hm_maps = ['cividis', 'Blues']
fts = [ft_relabun, ft_prev]
for g in range(len(hm_groups)):
  ft = fts[g].copy(deep=True)
  rename_sample = {}
  for col in ft.columns:
    st = md.loc[col, hm_groups[g]]
    rename_sample[col] = st
  ft = ft.rename(columns=rename_sample)
  ft = ft.groupby(by=ft.columns, axis=1).mean()
  ft_norm = ft.copy(deep=True).transpose()
  if g == 0:
    ft_norm = ft_norm.divide(ft_norm.max(axis=0), axis=1).transpose()
  else:
    ft_norm = ft_norm.transpose()
  ha = hm_axes[g].pcolor(ft_norm, edgecolor='k', cmap=hm_maps[g])
  mid = np.mean([max(ft_norm.max(axis=1).values), min(ft_norm.min(axis=1).values)])
  for r in range(len(ft_norm.index.values)):
    for c in range(len(ft_norm.columns)):
      norm_val = ft_norm.iloc[r, c]
      val = ft.iloc[r, c]
      if norm_val < mid:
        if g == 0: col = 'w'
        else: col = 'k'
      else:
        if g == 0: col = 'k'
        else: col = 'w'
      if val >= 10: val = round(val, 1)
      elif val > 1: val = round(val, 2)
      elif val > 0.0001: val = round(val, 4)
      else: val = round(val, 6)
      if g > 1: fs = 10
      else: fs = 10
      tx = hm_axes[g].text(c+0.5, r+0.5, str(val), va='center', ha='center', color=col, fontsize=fs)
  plt.sca(hm_axes[g])
  if g == 1: yt = hm_axes[g].set_yticks([])
  else: 
    taxa_names = []
    for name in ft_relabun.index.values:
      if '_[' in name: taxa_name = name.replace('g__', ' ').replace('_[', ' [')
      elif 'g__' not in name: taxa_name = name
      else: taxa_name = name.replace('g__', ' $')+'$'
      taxa_names.append(taxa_name)
    yt = plt.yticks([a+0.5 for a in range(len(ft_relabun.index.values))], taxa_names)
  xt = hm_axes[g].set_xticks([])
  if g == 0:
    for row in ft.index.values:
      if ft.loc[row, 'South Asian'] < ft.loc[row, 'East Asian']:
        if ft.loc[row, 'East Asian'] < ft.loc[row, 'White']:
          print(row)

axes = [maaslin_ax, maaslin_prev_ax]
names = ['maaslin_coef_abun', 'maaslin_coef_prev']
qvals = ['maaslin_qval_abun', 'maaslin_qval_prev']

for t in range(len(all_da.index.values)):
  tax = all_da.index.values[t]
  for l in range(len(names)):
    this_sig = all_da.loc[tax, qvals[l]]
    if this_sig <= 0.1:
      sig = True
    else:
      sig = False
    if sig:
      val = all_da.loc[tax, names[l]]
      ba = axes[l].barh(t, 1, height=1, left=0, color='#e67e22', alpha=0.5, edgecolor='k')
      sc = axes[l].scatter(0.5, t, marker='*', color='k')
    else:
      ba = axes[l].barh(t, 1, height=1, left=0, color='gray', alpha=0.5, edgecolor='k')

for ax in axes:
  plt.sca(ax)
  yt = plt.yticks([]), plt.xticks([])
  yl = plt.ylim([-0.5, t+0.5]), plt.xlim([0, 1])

pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_ordination_pca.csv', index_col=0, header=0)
prop_explain = [0.6386125734929017, 0.3023029246310683, 0.05908450187603021]
#pcoa plot
count = 0
all_ethnicities = md.loc[:, 'ethnicity']
colors_plot = [colors_ethnicity[g] for g in all_ethnicities]
sc = pcoa.scatter(pca.loc[md.index.values, 'PC1'], pca.loc[md.index.values, 'PC2'], marker='o', color=colors_plot, alpha=0.2)

groups_plotting_pc1, groups_plotting_pc2 = [], []
x = {'East Asian':1, 'South Asian':2, 'White':3}
for ethnicity in ['East Asian', 'South Asian', 'White']:
  participants = md[md['ethnicity'] == ethnicity].index.values
  group_plotting_pc1 = pca.loc[participants, 'PC1']
  group_plotting_pc2 = pca.loc[participants, 'PC2']
  groups, axes = [group_plotting_pc1, group_plotting_pc2], [pc_x, pc_y]
  for g in range(len(groups)):
    if g == 0:
      box = axes[g].boxplot(groups[g], positions=[x[ethnicity]], patch_artist=True, vert=False, showfliers=False, widths=0.3)
      vp = axes[g].violinplot(groups[g], points=500, positions=[x[ethnicity]], showmeans=False, showextrema=False, showmedians=False, vert=False, side='high', widths=0.6)
      sc = axes[g].scatter(groups[g], np.random.normal(x[ethnicity]-0.3, scale=0.04, size=len(groups[g])), marker='o', color=colors_ethnicity[ethnicity], alpha=0.05)
    else:
      box = axes[g].boxplot(groups[g], positions=[x[ethnicity]], patch_artist=True, vert=True, showfliers=False, widths=0.3)
      vp = axes[g].violinplot(groups[g], points=500, positions=[x[ethnicity]], showmeans=False, showextrema=False, showmedians=False, vert=True, side='low', widths=0.6)
      sc = axes[g].scatter(np.random.normal(x[ethnicity]+0.3, scale=0.04, size=len(groups[g])), groups[g], marker='o', color=colors_ethnicity[ethnicity], alpha=0.05)
    for item in ['whiskers', 'medians', 'caps']: bi = plt.setp(box[item], color='k')
    for patch, color in zip(box['boxes'], [colors_ethnicity[ethnicity]]):
      patch.set_facecolor(color)
      patch.set_alpha(0.4)
    for idx, b in enumerate(vp['bodies']):
      b.set_color(colors_ethnicity[ethnicity])
      b.set_alpha(0.4)

plt.sca(pcoa)
ti = plt.title('Beta diversity: phylogenetic-RPCA', fontweight='bold')
xt = plt.xticks([])
al = plt.ylabel('PC2 ('+str(round(prop_explain[1]*100, 2))+'%)', fontweight='bold')
# handles_gender = [Line2D([0], [0], marker='s', color='w', label=gen, markerfacecolor=colors_gender[gen], markersize=12) for gen in ['Male', 'Female', 'Trans/gender-diverse']]
handles_ethnicity = [Line2D([0], [0], marker='s', color='w', label=eth, markerfacecolor=colors_ethnicity[eth], markersize=12) for eth in ['East Asian', 'South Asian', 'White']]
leg = pcoa.legend(handles=handles_ethnicity, loc='lower right')
# leg = ax_pca2.legend(handles=handles_ethnicity, loc='upper right')

plt.sca(pc_x)
al = plt.xlabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)', fontweight='bold')
yt = plt.yticks([1, 2, 3], ['East Asian', 'South Asian', 'White'])

plt.sca(pc_y)
yt = plt.xticks([1, 2, 3], ['East Asian', 'South Asian', 'White'], rotation=90), plt.yticks([])

perm_stats = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)
p = round(perm_stats.loc['ethnicity', 'Univariate p'], 3)
if p < 0.001: p = '<0.001'
string_perm = 'PERMANOVA\nUnivariate:\n$R^{2}$='+str(round(perm_stats.loc['ethnicity', 'Univariate R2'], 4))+', $p$='+str(p)+'\n\n'
p = round(perm_stats.loc['ethnicity', 'Basic strata p'], 3)
if p < 0.001: p = '<0.001'
string_perm += 'Multivariate:\n$R^{2}$='+str(round(perm_stats.loc['ethnicity', 'Basic strata R2'], 4))+', $p$='+str(p)
tx = pc_y.text(0.5, -0.25, string_perm, ha='center', va='top', transform=pc_y.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

alpha_metrics = ['chao1', 'faith_pd', 'observed_otus', 'shannon', 'simpson_e', 'simpson']
alpha_metric_name = ['Chao1 richness', "Faith's phylogenetic diversity", "Observed taxa", "Shannon diversity", "Simpson's evenness", "Simpson's index of diversity"]
alpha_axes = [alpha_1, alpha_2, alpha_3, alpha_4, alpha_5, alpha_6]
for a in range(len(alpha_metrics)):
  plt.sca(alpha_axes[a])
  alp = pd.read_csv(folder+'files/alpha_diversity/alpha_'+alpha_metrics[a]+'.csv', index_col=0, header=0)
  alp_stats = pd.read_csv(folder+'files/alpha_stats/'+alpha_metrics[a]+'_summary.csv', index_col=0, header=0)
  for ethnicity in ['East Asian', 'South Asian', 'White']:
    participants = md[md['ethnicity'] == ethnicity].index.values
    group_plotting = alp.loc[participants, 'Mean']
    box = alpha_axes[a].boxplot(group_plotting, positions=[x[ethnicity]], patch_artist=True, vert=True, showfliers=False, widths=0.3)
    vp = alpha_axes[a].violinplot(group_plotting, points=500, positions=[x[ethnicity]], showmeans=False, showextrema=False, showmedians=False, vert=True, side='low', widths=0.6)
    sc = alpha_axes[a].scatter(np.random.normal(x[ethnicity]+0.3, scale=0.04, size=len(group_plotting)), group_plotting, marker='o', color=colors_ethnicity[ethnicity], alpha=0.05)
    for item in ['whiskers', 'medians', 'caps']: bi = plt.setp(box[item], color='k')
    for patch, color in zip(box['boxes'], [colors_ethnicity[ethnicity]]):
      patch.set_facecolor(color)
      patch.set_alpha(0.4)
    for idx, b in enumerate(vp['bodies']):
      b.set_color(colors_ethnicity[ethnicity])
      b.set_alpha(0.4)
  anov_p = round(alp_stats.loc['ethnicity', 'Univariate p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string = 'Uni: F='+str(round(alp_stats.loc['ethnicity', 'Univariate F'], 2))+', $p$='+str(anov_p)+'\n'
  anov_p = round(alp_stats.loc['ethnicity', 'Basic p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string += 'Multi: F='+str(round(alp_stats.loc['ethnicity', 'Basic F'], 2))+', $p$='+str(anov_p)
  tx = alpha_axes[a].text(0.96, 0.04, string, ha='right', va='bottom', transform=alpha_axes[a].transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))
  yt = plt.ylabel(alpha_metric_name[a], fontweight='bold')
  if a in [1, 3, 5]:
    xt = plt.xticks([1, 2, 3], ['East Asian', 'South Asian', 'White'], rotation=90)

plt.savefig(folder+'figures/ethnicity_overall_plot.png', dpi=600, bbox_inches='tight')
```

## Physical/mental health condition

```{python}
fig = plt.figure(figsize=(20,28))

pcoa = plt.subplot2grid((12,9),(0,0), rowspan=3, colspan=3)
pc_x = plt.subplot2grid((12,9),(3,0), colspan=3)
pc_y = plt.subplot2grid((12,9),(0,3), rowspan=3)

ax_alp_lab = plt.subplot2grid((36,28),(0,14), rowspan=4, colspan=14, frameon=False)
ti = ax_alp_lab.set_title('Alpha diversity', fontweight='bold')

alpha_1 = plt.subplot2grid((36,28),(0,14), rowspan=6, colspan=4)
alpha_2 = plt.subplot2grid((36,28),(6,14), rowspan=6, colspan=4)
alpha_3 = plt.subplot2grid((36,28),(0,19), rowspan=6, colspan=4)
alpha_4 = plt.subplot2grid((36,28),(6,19), rowspan=6, colspan=4)
alpha_5 = plt.subplot2grid((36,28),(0,24), rowspan=6, colspan=4)
alpha_6 = plt.subplot2grid((36,28),(6,24), rowspan=6, colspan=4)

abun_ax = plt.subplot2grid((72,54), (30,0), rowspan=30, colspan=15)
prev_ax = plt.subplot2grid((72,54), (30,16), rowspan=30, colspan=15)
abun_labels = plt.subplot2grid((72,54), (29,0), rowspan=1, colspan=15)
prev_labels = plt.subplot2grid((72,54), (29,16), rowspan=1, colspan=15)

maaslin_ax = plt.subplot2grid((72,54), (30,34), rowspan=30, colspan=10)
maaslin_prev_ax = plt.subplot2grid((72,54), (30,44), rowspan=30, colspan=10)
maaslin_labels = plt.subplot2grid((72,54), (29,34), rowspan=1, colspan=10)
maaslin_prev_labels = plt.subplot2grid((72,54), (29,44), rowspan=1, colspan=10)

ax_rem = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels, ax_alp_lab]
ax_lab = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels]
for ax in ax_rem:
  xt = ax.set_xticks([]), ax.set_yticks([])
labels_colors = [[[1, 2, 3, 4], colors_condition, ['None', 'Phys.', 'Ment.', 'Both'], ['k', 'k', 'k', 'k'], 'Relative abundance (%)'], [[1, 2, 3, 4], colors_condition, ['None', 'Phys.', 'Ment.', 'Both'], ['k', 'k', 'k', 'k'], 'Prevalence'], [[1, 2, 3], colors_condition, ['Phys.', 'Ment.', 'Both'], ['k', 'k', 'k'], 'Differential abundance\nAbundance'], [[1, 2, 3], colors_condition, ['Phys.', 'Ment.', 'Both'], ['k', 'k', 'k'], 'Differential abundance\nPrevalence']]
for l in range(len(ax_lab)):
  if labels_colors[l] == []: continue
  locs, colors, names, font_col = labels_colors[l][0], labels_colors[l][1], labels_colors[l][2], labels_colors[l][3]
  ba = ax_lab[l].bar(locs, [1 for c in locs], color=[colors[c] for c in names], width=1, edgecolor='k')
  tx = [ax_lab[l].text(locs[t], 0.5, names[t].replace('Ment.', 'Psych/NDD'), ha='center', va='center', color=font_col[t], fontsize=10) for t in range(len(locs))]
  li = ax_lab[l].set_xlim([locs[0]-0.5, locs[-1]+0.5]), ax_lab[l].set_ylim([0, 1])
  ti = ax_lab[l].set_title(labels_colors[l][4], fontweight='bold')

ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
ft = ft.loc[:, md.index.values]

tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
rename_tax = {}
for row in tax.index.values:
  rename_tax[row] = tax.loc[row, 'Genus']

ft = ft.rename(index=rename_tax)
ft_prev = ft.copy(deep=True)
ft_prev[ft_prev > 0] = 1
ft_relabun = ft.copy(deep=True)
ft_relabun = ft_relabun.divide(ft_relabun.sum(axis=0), axis=1).multiply(100)
ft_relabun['Mean'] = ft_relabun.mean(axis=1)
ft_relabun = ft_relabun.sort_values(by=['Mean'], ascending=False)
ft_relabun.drop('Mean', axis=1, inplace=True)

groups = ['physical_condition', 'mental_condition', 'mental_and_physical']
all_da_sig = []
for group in groups:
  this_group = pd.read_csv(folder+'differential_abundance/physical_mental_condition_'+group+'_maaslin.csv', index_col=0, header=0)
  this_group['Group'] = group
  all_da_sig.append(this_group)

all_da_sig = pd.concat(all_da_sig)

#get taxa to plot
all_sig_tax = all_da_sig[all_da_sig['maaslin_qval_abun'] <= 0.1]
most_abun_tax = ft_relabun.head(20)
all_tax_keeping = list(all_sig_tax.index.values)+list(most_abun_tax.index.values)
all_tax_keeping = list(set(all_tax_keeping))
tax_keeping_order = [row for row in ft_relabun.index.values if row in all_tax_keeping]

ft_relabun = ft_relabun.loc[tax_keeping_order, :]
tax_reverse = list(ft_relabun.index.values)
tax_reverse.reverse()
ft_relabun = ft_relabun.loc[tax_reverse, :]
ft_prev = ft_prev.loc[tax_reverse, :]
all_da = all_da_sig.loc[tax_reverse, :]

hm_groups = ['physical_mental_condition', 'physical_mental_condition']
hm_axes = [abun_ax, prev_ax]
hm_maps = ['inferno', 'Blues']
fts = [ft_relabun, ft_prev]
for g in range(len(hm_groups)):
  ft = fts[g].copy(deep=True)
  rename_sample = {}
  for col in ft.columns:
    st = md.loc[col, hm_groups[g]]
    rename_sample[col] = st
  ft = ft.rename(columns=rename_sample)
  ft = ft.groupby(by=ft.columns, axis=1).mean()
  ft_norm = ft.copy(deep=True).transpose()
  if g == 0:
    ft_norm = ft_norm.divide(ft_norm.max(axis=0), axis=1).transpose()
  else:
    ft_norm = ft_norm.transpose()
  ha = hm_axes[g].pcolor(ft_norm, edgecolor='k', cmap=hm_maps[g])
  mid = np.mean([max(ft_norm.max(axis=1).values), min(ft_norm.min(axis=1).values)])
  for r in range(len(ft_norm.index.values)):
    for c in range(len(ft_norm.columns)):
      norm_val = ft_norm.iloc[r, c]
      val = ft.iloc[r, c]
      if norm_val < mid:
        if g == 0: col = 'w'
        else: col = 'k'
      else:
        if g == 0: col = 'k'
        else: col = 'w'
      if val >= 10: val = round(val, 1)
      elif val > 1: val = round(val, 2)
      elif val > 0.0001: val = round(val, 4)
      else: val = round(val, 6)
      if g > 1: fs = 10
      else: fs = 10
      tx = hm_axes[g].text(c+0.5, r+0.5, str(val), va='center', ha='center', color=col, fontsize=fs)
  plt.sca(hm_axes[g])
  if g == 1: yt = hm_axes[g].set_yticks([])
  else: 
    taxa_names = []
    for name in ft_relabun.index.values:
      if '_[' in name: taxa_name = name.replace('g__', ' ').replace('_[', ' [')
      elif 'g__' not in name: taxa_name = name
      else: taxa_name = name.replace('g__', ' $')+'$'
      taxa_names.append(taxa_name)
    yt = plt.yticks([a+0.5 for a in range(len(ft_relabun.index.values))], taxa_names)
  xt = hm_axes[g].set_xticks([])

axes = [maaslin_ax, maaslin_prev_ax]
names = ['maaslin_coef_abun', 'maaslin_coef_prev']
qvals = ['maaslin_qval_abun', 'maaslin_qval_prev']
min_max = []
for n in range(len(names)):
  vals = all_da[names[n]].values
  vals = [abs(v) for v in vals]
  m = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=-max(vals), vmax=max(vals)), cmap=cm.RdBu_r)
  min_max.append(m)

for t in range(len(tax_reverse)):
  tax = tax_reverse[t]
  for l in range(len(names)):
    count = 0
    for group in ['physical_condition', 'mental_condition', 'mental_and_physical']:
      this_da = all_da[all_da['Group'] == group]
      this_sig = this_da.loc[tax, qvals[l]]
      if this_sig <= 0.1:
        sig = True
      else:
        sig = False
      if sig:
        val = this_da.loc[tax, names[l]]
        ba = axes[l].barh(t, 1, height=1, left=count, color=min_max[l].to_rgba(val), alpha=0.5, edgecolor='k')
        tx = axes[l].text(count+0.5, t, str(round(val, 2)), color='k', ha='center', va='center')
      else:
        ba = axes[l].barh(t, 1, height=1, left=count, color='gray', alpha=0.5, edgecolor='k')
      count += 1

for ax in axes:
  plt.sca(ax)
  yt = plt.yticks([]), plt.xticks([])
  yl = plt.ylim([-0.5, t+0.5]), plt.xlim([0, 3])

pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_ordination_pca.csv', index_col=0, header=0)
prop_explain = [0.6386125734929017, 0.3023029246310683, 0.05908450187603021]
#pcoa plot
count = 0
all_conditions = md.loc[:, 'physical_mental_condition']
colors_plot = [colors_condition[g] for g in all_conditions]
sc = pcoa.scatter(pca.loc[md.index.values, 'PC1'], pca.loc[md.index.values, 'PC2'], marker='o', color=colors_plot, alpha=0.2)

groups_plotting_pc1, groups_plotting_pc2 = [], []
x = {'no_reported_condition':1, 'physical_condition':2, 'mental_condition':3, 'mental_and_physical':4}
for condition in ['no_reported_condition', 'physical_condition', 'mental_condition', 'mental_and_physical']:
  participants = md[md['physical_mental_condition'] == condition].index.values
  group_plotting_pc1 = pca.loc[participants, 'PC1']
  group_plotting_pc2 = pca.loc[participants, 'PC2']
  groups, axes = [group_plotting_pc1, group_plotting_pc2], [pc_x, pc_y]
  for g in range(len(groups)):
    if g == 0:
      box = axes[g].boxplot(groups[g], positions=[x[condition]], patch_artist=True, vert=False, showfliers=False, widths=0.3)
      vp = axes[g].violinplot(groups[g], points=500, positions=[x[condition]], showmeans=False, showextrema=False, showmedians=False, vert=False, side='high', widths=0.6)
      sc = axes[g].scatter(groups[g], np.random.normal(x[condition]-0.3, scale=0.04, size=len(groups[g])), marker='o', color=colors_condition[condition], alpha=0.05)
    else:
      box = axes[g].boxplot(groups[g], positions=[x[condition]], patch_artist=True, vert=True, showfliers=False, widths=0.3)
      vp = axes[g].violinplot(groups[g], points=500, positions=[x[condition]], showmeans=False, showextrema=False, showmedians=False, vert=True, side='low', widths=0.6)
      sc = axes[g].scatter(np.random.normal(x[condition]+0.3, scale=0.04, size=len(groups[g])), groups[g], marker='o', color=colors_condition[condition], alpha=0.05)
    for item in ['whiskers', 'medians', 'caps']: bi = plt.setp(box[item], color='k')
    for patch, color in zip(box['boxes'], [colors_condition[condition]]):
      patch.set_facecolor(color)
      patch.set_alpha(0.4)
    for idx, b in enumerate(vp['bodies']):
      b.set_color(colors_condition[condition])
      b.set_alpha(0.4)

plt.sca(pcoa)
ti = plt.title('Beta diversity: phylogenetic-RPCA', fontweight='bold')
xt = plt.xticks([])
al = plt.ylabel('PC2 ('+str(round(prop_explain[1]*100, 2))+'%)', fontweight='bold')
handles_condition = [Line2D([0], [0], marker='s', color='w', label=con.replace('Phys.', 'Physical'), markerfacecolor=colors_condition[con], markersize=12) for con in ['None', 'Phys.', 'Ment.', 'Both']]
leg = pcoa.legend(handles=handles_condition, loc='lower right')

plt.sca(pc_x)
al = plt.xlabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)', fontweight='bold')
yt = plt.yticks([1, 2, 3, 4], ['None', 'Physical', 'Psych/NDD', 'Both'])

plt.sca(pc_y)
yt = plt.xticks([1, 2, 3, 4], ['None', 'Physical', 'Psych/NDD', 'Both'], rotation=90), plt.yticks([])

perm_stats = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)
p = round(perm_stats.loc['physical_mental_condition', 'Univariate p'], 3)
if p < 0.001: p = '<0.001'
string_perm = 'PERMANOVA\nUnivariate:\n$R^{2}$='+str(round(perm_stats.loc['physical_mental_condition', 'Univariate R2'], 4))+', $p$='+str(p)+'\n\n'
p = round(perm_stats.loc['physical_mental_condition', 'Basic strata p'], 3)
if p < 0.001: p = '<0.001'
string_perm += 'Multivariate:\n$R^{2}$='+str(round(perm_stats.loc['physical_mental_condition', 'Basic strata R2'], 4))+', $p$='+str(p)
tx = pc_y.text(0.5, -0.2, string_perm, ha='center', va='top', transform=pc_y.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

alpha_metrics = ['chao1', 'faith_pd', 'observed_otus', 'shannon', 'simpson_e', 'simpson']
alpha_metric_name = ['Chao1 richness', "Faith's phylogenetic diversity", "Observed taxa", "Shannon diversity", "Simpson's evenness", "Simpson's index of diversity"]
alpha_axes = [alpha_1, alpha_2, alpha_3, alpha_4, alpha_5, alpha_6]
for a in range(len(alpha_metrics)):
  plt.sca(alpha_axes[a])
  alp = pd.read_csv(folder+'files/alpha_diversity/alpha_'+alpha_metrics[a]+'.csv', index_col=0, header=0)
  alp_stats = pd.read_csv(folder+'files/alpha_stats/'+alpha_metrics[a]+'_summary.csv', index_col=0, header=0)
  for condition in ['no_reported_condition', 'physical_condition', 'mental_condition', 'mental_and_physical']:
    participants = md[md['physical_mental_condition'] == condition].index.values
    group_plotting = alp.loc[participants, 'Mean']
    box = alpha_axes[a].boxplot(group_plotting, positions=[x[condition]], patch_artist=True, vert=True, showfliers=False, widths=0.3)
    vp = alpha_axes[a].violinplot(group_plotting, points=500, positions=[x[condition]], showmeans=False, showextrema=False, showmedians=False, vert=True, side='low', widths=0.6)
    sc = alpha_axes[a].scatter(np.random.normal(x[condition]+0.3, scale=0.04, size=len(group_plotting)), group_plotting, marker='o', color=colors_condition[condition], alpha=0.05)
    for item in ['whiskers', 'medians', 'caps']: bi = plt.setp(box[item], color='k')
    for patch, color in zip(box['boxes'], [colors_condition[condition]]):
      patch.set_facecolor(color)
      patch.set_alpha(0.4)
    for idx, b in enumerate(vp['bodies']):
      b.set_color(colors_condition[condition])
      b.set_alpha(0.4)
  anov_p = round(alp_stats.loc['physical_mental_condition', 'Univariate p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string = 'Uni: F='+str(round(alp_stats.loc['physical_mental_condition', 'Univariate F'], 2))+', $p$='+str(anov_p)+'\n'
  anov_p = round(alp_stats.loc['physical_mental_condition', 'Basic p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string += 'Multi: F='+str(round(alp_stats.loc['physical_mental_condition', 'Basic F'], 2))+', $p$='+str(anov_p)
  tx = alpha_axes[a].text(0.96, 0.04, string, ha='right', va='bottom', transform=alpha_axes[a].transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))
  yt = plt.ylabel(alpha_metric_name[a], fontweight='bold')
  if a in [1, 3, 5]:
    xt = plt.xticks([1, 2, 3, 4], ['None', 'Physical', 'Psych/NDD', 'Both'], rotation=90)

plt.savefig(folder+'figures/condition_overall_plot.png', dpi=600, bbox_inches='tight')
```

## Genera DA with age and gender

```{python}
fig = plt.figure(figsize=(12,10))
genera = ['g__Gemella', 'g__Neisseria', 'g__Prevotella', 'g__Haemophilus']

ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
ft = ft.loc[:, md.index.values]

tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
rename_tax = {}
for row in tax.index.values:
  rename_tax[row] = tax.loc[row, 'Genus']

ft = ft.rename(index=rename_tax)
ft_relabun = ft_relabun.divide(ft_relabun.sum(axis=0), axis=1).multiply(100)
ft_relabun = ft_relabun.loc[genera, :]

all_ages = md.loc[:, 'age']
grouping = [['gender', 1, colors_gender['Male']], ['gender', 2, colors_gender['Female']]]
axes = []

for g in range(len(genera)):
  ax = plt.subplot(2,2,g+1)
  for a in range(len(grouping)):
    group = md[md[grouping[a][0]] == grouping[a][1]]
    unique_ages = sorted(list(set([round(g, 1) for g in group['age']])))
    genus = ft_relabun.loc[genera[g], group.index.values].values
    fitted_poly = Polynomial.fit(group['age'], genus, deg=4)
    w = fitted_poly(unique_ages)
    li = ax.plot(unique_ages, w, color=grouping[a][2], linestyle='-')
    sc = ax.scatter(group['age'], genus, color=grouping[a][2], alpha=0.01)
  plt.sca(ax)
  ti = ax.set_title('$'+genera[g].replace('g__', '')+'$', fontweight='bold')
  if g in [0, 2]: yl = ax.set_ylabel('Relative abundance (%)')
  if g in [2, 3]: xl = ax.set_xlabel('Age (years)')
  axes.append(ax)
  
handles_gender = [Line2D([0], [0], marker='s', color='w', label=gen, markerfacecolor=colors_gender[gen], markersize=12) for gen in ['Male', 'Female']]
leg = axes[1].legend(handles=handles_gender, loc='upper left', bbox_to_anchor=(1.03, 1.01))


plt.savefig(folder+'figures/age_gender_DA_genera.png', dpi=600, bbox_inches='tight')
```

## Social deprivation

```{python}
fig = plt.figure(figsize=(20,28))

pcoa = plt.subplot2grid((12,9),(0,0), rowspan=3, colspan=3)
pc_x = plt.subplot2grid((12,9),(3,0), colspan=3)
pc_y = plt.subplot2grid((12,9),(0,3), rowspan=3)

ax_alp_lab = plt.subplot2grid((36,27),(0,14), rowspan=4, colspan=13, frameon=False)
ti = ax_alp_lab.set_title('Alpha diversity', fontweight='bold')

alpha_1 = plt.subplot2grid((36,27),(0,14), rowspan=4, colspan=6)
alpha_2 = plt.subplot2grid((36,27),(4,14), rowspan=4, colspan=6)
alpha_3 = plt.subplot2grid((36,27),(8,14), rowspan=4, colspan=6)
alpha_4 = plt.subplot2grid((36,27),(0,21), rowspan=4, colspan=6)
alpha_5 = plt.subplot2grid((36,27),(4,21), rowspan=4, colspan=6)
alpha_6 = plt.subplot2grid((36,27),(8,21), rowspan=4, colspan=6)

abun_ax = plt.subplot2grid((72,54), (30,0), rowspan=30, colspan=22)
prev_ax = plt.subplot2grid((72,54), (30,23), rowspan=30, colspan=22)
#abun_labels = plt.subplot2grid((72,54), (29,0), rowspan=1, colspan=22)
#prev_labels = plt.subplot2grid((72,54), (29,23), rowspan=1, colspan=22)
maaslin_ax = plt.subplot2grid((72,54), (30,46), rowspan=30, colspan=4)
maaslin_prev_ax = plt.subplot2grid((72,54), (30,50), rowspan=30, colspan=4)
maaslin_labels = plt.subplot2grid((72,54), (29,46), rowspan=1, colspan=4)
maaslin_prev_labels = plt.subplot2grid((72,54), (29,50), rowspan=1, colspan=4)

ax_rem = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels, ax_alp_lab]
ax_lab = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels]
for ax in ax_rem:
  xt = ax.set_xticks([]), ax.set_yticks([])
labels_colors = [[], [], [[1], colors_age, ['Abundance'], ['k'], ''], [[1], colors_age, ['Prevalence'], ['k'], '']]
for l in range(len(ax_lab)):
  if labels_colors[l] == []: continue
  locs, colors, names, font_col = labels_colors[l][0], labels_colors[l][1], labels_colors[l][2], labels_colors[l][3]
  ba = ax_lab[l].bar(locs, [1 for c in locs], color='w', width=1, edgecolor='k')
  tx = [ax_lab[l].text(locs[t], 0.5, names[t], ha='center', va='center', color=font_col[t], fontsize=10) for t in range(len(locs))]
  li = ax_lab[l].set_xlim([locs[0]-0.5, locs[-1]+0.5]), ax_lab[l].set_ylim([0, 1])
  ti = ax_lab[l].set_title(labels_colors[l][4], fontweight='bold')

ti = maaslin_labels.set_title(' Differential abundance', fontweight='bold', loc='left')
ti = abun_ax.set_title('Relative abundance (%)', fontweight='bold')
ti = prev_ax.set_title('Prevalence', fontweight='bold')

ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
md = md.loc[:, ['cur_msd_soc']].dropna(axis=0)
ft = ft.loc[:, md.index.values]

tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
rename_tax = {}
for row in tax.index.values:
  rename_tax[row] = tax.loc[row, 'Genus']

ft = ft.rename(index=rename_tax)
ft_prev = ft.copy(deep=True)
ft_prev[ft_prev > 0] = 1
ft_relabun = ft.copy(deep=True)
ft_relabun = ft_relabun.divide(ft_relabun.sum(axis=0), axis=1).multiply(100)
ft_relabun['Mean'] = ft_relabun.mean(axis=1)
ft_relabun = ft_relabun.sort_values(by=['Mean'], ascending=False)
ft_relabun.drop('Mean', axis=1, inplace=True)

all_da_sig = pd.read_csv(folder+'differential_abundance/cur_msd_soc_maaslin.csv', index_col=0, header=0)

#get taxa to plot
all_sig_tax = all_da_sig[all_da_sig['maaslin_qval_abun'] <= 0.1]
most_abun_tax = ft_relabun.head(20)
all_tax_keeping = list(all_sig_tax.index.values)+list(most_abun_tax.index.values)
all_tax_keeping = list(set(all_tax_keeping))
tax_keeping_order = [row for row in ft_relabun.index.values if row in all_tax_keeping]

ft_relabun = ft_relabun.loc[tax_keeping_order, :]
tax_reverse = list(ft_relabun.index.values)
tax_reverse.reverse()
ft_relabun = ft_relabun.loc[tax_reverse, :]
ft_prev = ft_prev.loc[tax_reverse, :]
all_da = all_da_sig.loc[tax_reverse, :]

hm_groups = ['cur_msd_soc', 'cur_msd_soc']
hm_axes = [abun_ax, prev_ax]
hm_maps = ['plasma', 'Blues']
fts = [ft_relabun, ft_prev]
mi, ma = min(md['cur_msd_soc']), max(md['cur_msd_soc'])
interval = (ma-mi)/16
intervals = []
prev = mi
for c in range(17):
  if c == 0: continue
  intervals.append([prev, mi+(c*interval)])
  prev = mi+(c*interval)

for g in range(len(hm_groups)):
  plt.sca(hm_axes[g])
  ft = fts[g].copy(deep=True)
  rename_sample = {}
  for col in ft.columns:
    st = md.loc[col, hm_groups[g]]
    for i in range(len(intervals)):
      if intervals[i][0] <= st < intervals[i][1]:
        this_group = i
        break
    rename_sample[col] = this_group
  ft = ft.rename(columns=rename_sample)
  ft = ft.groupby(by=ft.columns, axis=1).mean()
  ft_norm = ft.copy(deep=True).transpose()
  if g == 0:
    ft_norm = ft_norm.divide(ft_norm.max(axis=0), axis=1).transpose()
  else:
    ft_norm = ft_norm.transpose()
  ha = hm_axes[g].pcolor(ft_norm, edgecolor='k', cmap=hm_maps[g])
  mid = np.mean([max(ft_norm.max(axis=1).values), min(ft_norm.min(axis=1).values)])
  for r in range(len(ft_norm.index.values)):
    for c in range(len(ft_norm.columns)):
      norm_val = ft_norm.iloc[r, c]
      val = ft.iloc[r, c]
      if norm_val < mid:
        if g == 0: col = 'w'
        else: col = 'k'
      else:
        if g == 0: col = 'k'
        else: col = 'w'
      if val >= 10: val = int(val)
      elif val > 1: val = round(val, 1)
      else: val = round(val, 2)
      if g > 1: fs = 8
      else: fs = 8
      tx = hm_axes[g].text(c+0.5, r+0.5, str(val), va='center', ha='center', color=col, fontsize=fs)
  plt.sca(hm_axes[g])
  if g == 1: yt = hm_axes[g].set_yticks([])
  else: 
    taxa_names = []
    for name in ft_relabun.index.values:
      if '_[' in name: taxa_name = name.replace('g__', ' ').replace('_[', ' [')
      elif 'g__' not in name: taxa_name = name
      else: taxa_name = name.replace('g__', ' $')+'$'
      taxa_names.append(taxa_name)
    yt = plt.yticks([a+0.5 for a in range(len(ft_relabun.index.values))], taxa_names)
  xticks = [x+0.5 for x in range(15)]
  xticks_plot, means = [], []
  for x in range(len(xticks)):
    if x % 2 == 0: 
      xticks_plot.append(xticks[x])
      means.append(round(np.mean(intervals[x]), 3))
  xt = hm_axes[g].set_xlabel('Social deprivation score', fontweight='bold')
  xt = plt.xticks(xticks_plot, means)

axes = [maaslin_ax, maaslin_prev_ax]
names = ['maaslin_coef_abun', 'maaslin_coef_prev']
qvals = ['maaslin_qval_abun', 'maaslin_qval_prev']
min_max = []
for n in range(len(names)):
  vals = all_da[names[n]].values
  vals = [abs(v) for v in vals]
  m = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=-max(vals), vmax=max(vals)), cmap=cm.RdBu_r)
  min_max.append(m)

for t in range(len(all_da.index.values)):
  tax = all_da.index.values[t]
  for l in range(len(names)):
    this_sig = all_da.loc[tax, qvals[l]]
    if this_sig <= 0.1:
      sig = True
    else:
      sig = False
    if sig:
      val = all_da.loc[tax, names[l]]
      ba = axes[l].barh(t, 1, height=1, left=0, color=min_max[l].to_rgba(val), alpha=0.5, edgecolor='k')
      tx = axes[l].text(0.5, t, str(round(val, 2)), color='k', ha='center', va='center')
    else:
      ba = axes[l].barh(t, 1, height=1, left=0, color='gray', alpha=0.5, edgecolor='k')

for ax in axes:
  plt.sca(ax)
  yt = plt.yticks([]), plt.xticks([])
  yl = plt.ylim([-0.5, t+0.5]), plt.xlim([0, 1])
  
pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_ordination_pca.csv', index_col=0, header=0)
prop_explain = [0.6386125734929017, 0.3023029246310683, 0.05908450187603021]
#pcoa plot
count = 0
all_soc = md.loc[:, 'cur_msd_soc']
m = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=min(all_soc), vmax=max(all_soc)), cmap=cm.spring)
colors_plot = [m.to_rgba(soc) for soc in all_soc]
sc = pcoa.scatter(pca.loc[md.index.values, 'PC1'], pca.loc[md.index.values, 'PC2'], marker='o', color=colors_plot, alpha=0.2)
sc = pc_x.scatter(pca.loc[md.index.values, 'PC1'], all_soc, marker='o', color='gray', alpha=0.2)
sc = pc_y.scatter(all_soc, pca.loc[md.index.values, 'PC2'], marker='o', color='gray', alpha=0.2)

plt.sca(pcoa)
ti = plt.title('Beta diversity: phylogenetic-RPCA', fontweight='bold')
xt = plt.xticks([])
al = plt.ylabel('PC2 ('+str(round(prop_explain[1]*100, 2))+'%)', fontweight='bold')
ax_colbar = inset_axes(pcoa, width="30%", height="8%", loc='upper left')
plt.sca(ax_colbar)
cb = mpl.colorbar.ColorbarBase(ax_colbar, cmap=mpl.cm.spring, norm=mpl.colors.Normalize(vmin=min(all_soc), vmax=max(all_soc)), orientation='horizontal')
xl = plt.xlabel('Social deprivation score', fontsize=8)

plt.sca(pc_x)
al = plt.ylabel('Social deprivation score', fontweight='bold'), plt.xlabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)', fontweight='bold')
soc_means = {}
pca_vals = pca.loc[md.index.values, 'PC1'].values
for a in range(len(all_soc)):
  if round(pca_vals[a], 3) in soc_means:
    soc_means[round(pca_vals[a], 3)].append(all_soc[a])
  else:
    soc_means[round(pca_vals[a], 3)] = [all_soc[a]]
pcv_plot, mean_soc = [], []
for pcv in soc_means:
  pcv_plot.append(pcv)
  mean_soc.append(np.mean(soc_means[pcv]))

order = np.argsort(pcv_plot)
pcv_plot_ordered = [pcv_plot[i] for i in order]
mean_soc_ordered = [mean_soc[i] for i in order]

fitted_poly = Polynomial.fit(pca.loc[md.index.values, 'PC1'], all_soc, deg=4)
w = fitted_poly(pcv_plot_ordered)

# w = lowess(mean_soc_ordered, pcv_plot_ordered, frac=0.35, return_sorted=False)
li = plt.plot(pcv_plot_ordered, w, 'r-')
# li = plt.plot(np.unique(pca.loc[md.index.values, 'PC1']), np.poly1d(np.polyfit(pca.loc[md.index.values, 'PC1'], all_soc, 1))(np.unique(pca.loc[md.index.values, 'PC1'])), 'k--')
corr, p = spearmanr(pca.loc[md.index.values, 'PC1'], all_soc)
string = "Spearman's:\nR="+str(round(corr,3))+', $p$='+str(round(p,3))
tx = pc_x.text(0.98, 0.98, string, ha='right', va='top', transform=pc_x.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

plt.sca(pc_y)
al = plt.xlabel('Social deprivation score', fontweight='bold'), plt.yticks([])
# li = plt.plot(np.unique(all_soc), np.poly1d(np.polyfit(all_soc, pca.loc[md.index.values, 'PC2'], 1))(np.unique(all_soc)), 'k--')
soc_means = {}
pca_vals = pca.loc[md.index.values, 'PC2'].values
for a in range(len(all_soc)):
  if round(all_soc[a], 3) in soc_means:
    soc_means[round(all_soc[a], 3)].append(pca_vals[a])
  else:
    soc_means[round(all_soc[a], 3)] = [pca_vals[a]]
soc_plot, mean_pcv = [], []
for soc in soc_means:
  soc_plot.append(soc)
  mean_pcv.append(np.mean(soc_means[soc]))

order = np.argsort(soc_plot)
soc_plot_ordered = [soc_plot[i] for i in order]
mean_pcv_ordered = [mean_pcv[i] for i in order]

fitted_poly = Polynomial.fit(all_soc, pca.loc[md.index.values, 'PC2'], deg=4)
w = fitted_poly(soc_plot_ordered)

# w = lowess(mean_pcv_ordered, soc_plot_ordered, frac=0.35, return_sorted=False)
li = plt.plot(soc_plot_ordered, w, 'r-')
corr, p = spearmanr(all_soc, pca.loc[md.index.values, 'PC2'])
string = "Spearman's:\nR="+str(round(corr,3))+', $p$='+str(round(p,3))
tx = pc_y.text(0.98, 0.98, string, ha='right', va='top', transform=pc_y.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

perm_stats = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)
p = round(perm_stats.loc['cur_msd_soc', 'Univariate p'], 3)
if p < 0.001: p = '<0.001'
string_perm = 'PERMANOVA\nUnivariate:\n$R^{2}$='+str(round(perm_stats.loc['cur_msd_soc', 'Univariate R2'], 4))+', $p$='+str(p)+'\n\n'
p = round(perm_stats.loc['cur_msd_soc', 'Deprivation p'], 3)
if p < 0.001: p = '<0.001'
string_perm += 'Multivariate:\n$R^{2}$='+str(round(perm_stats.loc['cur_msd_soc', 'Deprivation R2'], 4))+', $p$='+str(p)
tx = pc_y.text(0.5, -0.15, string_perm, ha='center', va='top', transform=pc_y.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

alpha_metrics = ['chao1', 'faith_pd', 'observed_otus', 'shannon', 'simpson_e', 'simpson']
alpha_metric_name = ['Chao1 richness', "Faith's phylogenetic diversity", "Observed taxa", "Shannon diversity", "Simpson's evenness", "Simpson's index of diversity"]
alpha_axes = [alpha_1, alpha_2, alpha_3, alpha_4, alpha_5, alpha_6]
for a in range(len(alpha_metrics)):
  plt.sca(alpha_axes[a])
  alp = pd.read_csv(folder+'files/alpha_diversity/alpha_'+alpha_metrics[a]+'.csv', index_col=0, header=0)
  alp_stats = pd.read_csv(folder+'files/alpha_stats/'+alpha_metrics[a]+'_summary.csv', index_col=0, header=0)
  sc = alpha_axes[a].scatter(all_soc, alp.loc[md.index.values, 'Mean'], marker='o', color='gray', alpha=0.2)
  # li = plt.plot(np.unique(all_soc), np.poly1d(np.polyfit(all_soc, alp.loc[md.index.values, 'Mean'], 1))(np.unique(all_soc)), 'k--')
  soc_means = {}
  alp_vals = alp.loc[md.index.values, 'Mean']
  for ag in range(len(all_soc)):
    if round(all_soc[ag], 3) in soc_means:
      soc_means[round(all_soc[ag], 3)].append(alp_vals[ag])
    else:
      soc_means[round(all_soc[ag], 3)] = [alp_vals[ag]]
  soc_plot, mean_alp = [], []
  for soc in soc_means:
    soc_plot.append(soc)
    mean_alp.append(np.mean(soc_means[soc]))
  order = np.argsort(soc_plot)
  soc_plot_ordered = [soc_plot[i] for i in order]
  mean_alp_ordered = [mean_alp[i] for i in order]
  
  fitted_poly = Polynomial.fit(all_soc, alp.loc[md.index.values, 'Mean'], deg=4)
  w = fitted_poly(soc_plot_ordered)
  
  # w = lowess(mean_alp_ordered, soc_plot_ordered, frac=0.35, return_sorted=False)
  li = plt.plot(soc_plot_ordered, w, 'r-')
  corr, p = spearmanr(all_soc, alp.loc[md.index.values, 'Mean'])
  anov_p = round(alp_stats.loc['cur_msd_soc', 'Univariate p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string = 'Univariate: F='+str(round(alp_stats.loc['cur_msd_soc', 'Univariate F'], 2))+', $p$='+str(anov_p)+'\n'
  anov_p = round(alp_stats.loc['cur_msd_soc', 'Deprivation p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string += 'Multivariate: F='+str(round(alp_stats.loc['cur_msd_soc', 'Deprivation F'], 2))+', $p$='+str(anov_p)+'\n'
  string += "Spearman's: R="+str(round(corr,3))+', $p$='+str(round(p,3))
  if alpha_metrics[a] != 'simpson' and alpha_metrics[a] != 'shannon':
    tx = alpha_axes[a].text(0.96, 0.96, string, ha='right', va='top', transform=alpha_axes[a].transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))
  else:
    tx = alpha_axes[a].text(0.96, 0.04, string, ha='right', va='bottom', transform=alpha_axes[a].transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))
  yt = plt.ylabel(alpha_metric_name[a], fontweight='bold')
  if a in [2, 5]:
    xt = plt.xlabel('Social deprivation score', fontweight='bold')

plt.savefig(folder+'figures/social_deprivation_overall_plot.png', dpi=600, bbox_inches='tight')
```

## Material deprivation

```{python}
fig = plt.figure(figsize=(20,28))

pcoa = plt.subplot2grid((12,9),(0,0), rowspan=3, colspan=3)
pc_x = plt.subplot2grid((12,9),(3,0), colspan=3)
pc_y = plt.subplot2grid((12,9),(0,3), rowspan=3)

ax_alp_lab = plt.subplot2grid((36,27),(0,14), rowspan=4, colspan=13, frameon=False)
ti = ax_alp_lab.set_title('Alpha diversity', fontweight='bold')

alpha_1 = plt.subplot2grid((36,27),(0,14), rowspan=4, colspan=6)
alpha_2 = plt.subplot2grid((36,27),(4,14), rowspan=4, colspan=6)
alpha_3 = plt.subplot2grid((36,27),(8,14), rowspan=4, colspan=6)
alpha_4 = plt.subplot2grid((36,27),(0,21), rowspan=4, colspan=6)
alpha_5 = plt.subplot2grid((36,27),(4,21), rowspan=4, colspan=6)
alpha_6 = plt.subplot2grid((36,27),(8,21), rowspan=4, colspan=6)

abun_ax = plt.subplot2grid((72,54), (30,0), rowspan=30, colspan=22)
prev_ax = plt.subplot2grid((72,54), (30,23), rowspan=30, colspan=22)
#abun_labels = plt.subplot2grid((72,54), (29,0), rowspan=1, colspan=22)
#prev_labels = plt.subplot2grid((72,54), (29,23), rowspan=1, colspan=22)
maaslin_ax = plt.subplot2grid((72,54), (30,46), rowspan=30, colspan=4)
maaslin_prev_ax = plt.subplot2grid((72,54), (30,50), rowspan=30, colspan=4)
maaslin_labels = plt.subplot2grid((72,54), (29,46), rowspan=1, colspan=4)
maaslin_prev_labels = plt.subplot2grid((72,54), (29,50), rowspan=1, colspan=4)

ax_rem = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels, ax_alp_lab]
ax_lab = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels]
for ax in ax_rem:
  xt = ax.set_xticks([]), ax.set_yticks([])
labels_colors = [[], [], [[1], colors_age, ['Abundance'], ['k'], ''], [[1], colors_age, ['Prevalence'], ['k'], '']]
for l in range(len(ax_lab)):
  if labels_colors[l] == []: continue
  locs, colors, names, font_col = labels_colors[l][0], labels_colors[l][1], labels_colors[l][2], labels_colors[l][3]
  ba = ax_lab[l].bar(locs, [1 for c in locs], color='w', width=1, edgecolor='k')
  tx = [ax_lab[l].text(locs[t], 0.5, names[t], ha='center', va='center', color=font_col[t], fontsize=10) for t in range(len(locs))]
  li = ax_lab[l].set_xlim([locs[0]-0.5, locs[-1]+0.5]), ax_lab[l].set_ylim([0, 1])
  ti = ax_lab[l].set_title(labels_colors[l][4], fontweight='bold')

ti = maaslin_labels.set_title(' Differential abundance', fontweight='bold', loc='left')
ti = abun_ax.set_title('Relative abundance (%)', fontweight='bold')
ti = prev_ax.set_title('Prevalence', fontweight='bold')

ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
md = md.loc[:, ['cur_msd_mat']].dropna(axis=0)
ft = ft.loc[:, md.index.values]

tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
rename_tax = {}
for row in tax.index.values:
  rename_tax[row] = tax.loc[row, 'Genus']

ft = ft.rename(index=rename_tax)
ft_prev = ft.copy(deep=True)
ft_prev[ft_prev > 0] = 1
ft_relabun = ft.copy(deep=True)
ft_relabun = ft_relabun.divide(ft_relabun.sum(axis=0), axis=1).multiply(100)
ft_relabun['Mean'] = ft_relabun.mean(axis=1)
ft_relabun = ft_relabun.sort_values(by=['Mean'], ascending=False)
ft_relabun.drop('Mean', axis=1, inplace=True)

all_da_sig = pd.read_csv(folder+'differential_abundance/cur_msd_mat_maaslin.csv', index_col=0, header=0)

#get taxa to plot
all_sig_tax = all_da_sig[all_da_sig['maaslin_qval_abun'] <= 0.1]
most_abun_tax = ft_relabun.head(20)
all_tax_keeping = list(all_sig_tax.index.values)+list(most_abun_tax.index.values)
all_tax_keeping = list(set(all_tax_keeping))
tax_keeping_order = [row for row in ft_relabun.index.values if row in all_tax_keeping]

ft_relabun = ft_relabun.loc[tax_keeping_order, :]
tax_reverse = list(ft_relabun.index.values)
tax_reverse.reverse()
ft_relabun = ft_relabun.loc[tax_reverse, :]
ft_prev = ft_prev.loc[tax_reverse, :]
all_da = all_da_sig.loc[tax_reverse, :]

hm_groups = ['cur_msd_mat', 'cur_msd_mat']
hm_axes = [abun_ax, prev_ax]
hm_maps = ['plasma', 'Blues']
fts = [ft_relabun, ft_prev]
mi, ma = min(md['cur_msd_mat']), max(md['cur_msd_mat'])
interval = (ma-mi)/16
intervals = []
prev = mi
for c in range(17):
  if c == 0: continue
  intervals.append([prev, mi+(c*interval)])
  prev = mi+(c*interval)

for g in range(len(hm_groups)):
  plt.sca(hm_axes[g])
  ft = fts[g].copy(deep=True)
  rename_sample = {}
  for col in ft.columns:
    st = md.loc[col, hm_groups[g]]
    for i in range(len(intervals)):
      if intervals[i][0] <= st < intervals[i][1]:
        this_group = i
        break
    rename_sample[col] = this_group
  ft = ft.rename(columns=rename_sample)
  ft = ft.groupby(by=ft.columns, axis=1).mean()
  ft_norm = ft.copy(deep=True).transpose()
  if g == 0:
    ft_norm = ft_norm.divide(ft_norm.max(axis=0), axis=1).transpose()
  else:
    ft_norm = ft_norm.transpose()
  ha = hm_axes[g].pcolor(ft_norm, edgecolor='k', cmap=hm_maps[g])
  mid = np.mean([max(ft_norm.max(axis=1).values), min(ft_norm.min(axis=1).values)])
  for r in range(len(ft_norm.index.values)):
    for c in range(len(ft_norm.columns)):
      norm_val = ft_norm.iloc[r, c]
      val = ft.iloc[r, c]
      if norm_val < mid:
        if g == 0: col = 'w'
        else: col = 'k'
      else:
        if g == 0: col = 'k'
        else: col = 'w'
      if val >= 10: val = int(val)
      elif val > 1: val = round(val, 1)
      else: val = round(val, 2)
      if g > 1: fs = 8
      else: fs = 8
      tx = hm_axes[g].text(c+0.5, r+0.5, str(val), va='center', ha='center', color=col, fontsize=fs)
  plt.sca(hm_axes[g])
  if g == 1: yt = hm_axes[g].set_yticks([])
  else: 
    taxa_names = []
    for name in ft_relabun.index.values:
      if '_[' in name: taxa_name = name.replace('g__', ' ').replace('_[', ' [')
      elif 'g__' not in name: taxa_name = name
      else: taxa_name = name.replace('g__', ' $')+'$'
      taxa_names.append(taxa_name)
    yt = plt.yticks([a+0.5 for a in range(len(ft_relabun.index.values))], taxa_names)
  xticks = [x+0.5 for x in range(15)]
  xticks_plot, means = [], []
  for x in range(len(xticks)):
    if x % 2 == 0: 
      xticks_plot.append(xticks[x])
      means.append(round(np.mean(intervals[x]), 3))
  xt = hm_axes[g].set_xlabel('Material deprivation score', fontweight='bold')
  xt = plt.xticks(xticks_plot, means)

axes = [maaslin_ax, maaslin_prev_ax]
names = ['maaslin_coef_abun', 'maaslin_coef_prev']
qvals = ['maaslin_qval_abun', 'maaslin_qval_prev']
min_max = []
for n in range(len(names)):
  vals = all_da[names[n]].values
  vals = [abs(v) for v in vals]
  m = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=-max(vals), vmax=max(vals)), cmap=cm.RdBu_r)
  min_max.append(m)

for t in range(len(all_da.index.values)):
  tax = all_da.index.values[t]
  for l in range(len(names)):
    this_sig = all_da.loc[tax, qvals[l]]
    if this_sig <= 0.1:
      sig = True
    else:
      sig = False
    if sig:
      val = all_da.loc[tax, names[l]]
      ba = axes[l].barh(t, 1, height=1, left=0, color=min_max[l].to_rgba(val), alpha=0.5, edgecolor='k')
      tx = axes[l].text(0.5, t, str(round(val, 2)), color='k', ha='center', va='center')
    else:
      ba = axes[l].barh(t, 1, height=1, left=0, color='gray', alpha=0.5, edgecolor='k')

for ax in axes:
  plt.sca(ax)
  yt = plt.yticks([]), plt.xticks([])
  yl = plt.ylim([-0.5, t+0.5]), plt.xlim([0, 1])
  
pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_ordination_pca.csv', index_col=0, header=0)
prop_explain = [0.6386125734929017, 0.3023029246310683, 0.05908450187603021]
#pcoa plot
count = 0
all_mat = md.loc[:, 'cur_msd_mat']
m = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=min(all_mat), vmax=max(all_mat)), cmap=cm.autumn)
colors_plot = [m.to_rgba(mat) for mat in all_mat]
sc = pcoa.scatter(pca.loc[md.index.values, 'PC1'], pca.loc[md.index.values, 'PC2'], marker='o', color=colors_plot, alpha=0.2)
sc = pc_x.scatter(pca.loc[md.index.values, 'PC1'], all_mat, marker='o', color='gray', alpha=0.2)
sc = pc_y.scatter(all_mat, pca.loc[md.index.values, 'PC2'], marker='o', color='gray', alpha=0.2)

plt.sca(pcoa)
ti = plt.title('Beta diversity: phylogenetic-RPCA', fontweight='bold')
xt = plt.xticks([])
al = plt.ylabel('PC2 ('+str(round(prop_explain[1]*100, 2))+'%)', fontweight='bold')
ax_colbar = inset_axes(pcoa, width="30%", height="8%", loc='upper left')
plt.sca(ax_colbar)
cb = mpl.colorbar.ColorbarBase(ax_colbar, cmap=mpl.cm.autumn, norm=mpl.colors.Normalize(vmin=min(all_mat), vmax=max(all_mat)), orientation='horizontal')
xl = plt.xlabel('Material deprivation score', fontsize=8)

plt.sca(pc_x)
al = plt.ylabel('Material deprivation score', fontweight='bold'), plt.xlabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)', fontweight='bold')
mat_means = {}
pca_vals = pca.loc[md.index.values, 'PC1'].values
for a in range(len(all_mat)):
  if round(pca_vals[a], 3) in mat_means:
    mat_means[round(pca_vals[a], 3)].append(all_mat[a])
  else:
    mat_means[round(pca_vals[a], 3)] = [all_mat[a]]
pcv_plot, mean_mat = [], []
for pcv in mat_means:
  pcv_plot.append(pcv)
  mean_mat.append(np.mean(mat_means[pcv]))

order = np.argsort(pcv_plot)
pcv_plot_ordered = [pcv_plot[i] for i in order]
mean_mat_ordered = [mean_mat[i] for i in order]

fitted_poly = Polynomial.fit(pca.loc[md.index.values, 'PC1'], all_mat, deg=4)
w = fitted_poly(pcv_plot_ordered)

# w = lowess(mean_mat_ordered, pcv_plot_ordered, frac=0.35, return_sorted=False)
li = plt.plot(pcv_plot_ordered, w, 'r-')
corr, p = spearmanr(pca.loc[md.index.values, 'PC1'], all_mat)
string = "Spearman's:\nR="+str(round(corr,3))+', $p$='+str(round(p,3))
tx = pc_x.text(0.98, 0.98, string, ha='right', va='top', transform=pc_x.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

plt.sca(pc_y)
al = plt.xlabel('Material deprivation score', fontweight='bold'), plt.yticks([])
# li = plt.plot(np.unique(all_soc), np.poly1d(np.polyfit(all_soc, pca.loc[md.index.values, 'PC2'], 1))(np.unique(all_soc)), 'k--')
mat_means = {}
pca_vals = pca.loc[md.index.values, 'PC2'].values
for a in range(len(all_mat)):
  if round(all_mat[a], 3) in mat_means:
    mat_means[round(all_mat[a], 3)].append(pca_vals[a])
  else:
    mat_means[round(all_mat[a], 3)] = [pca_vals[a]]
mat_plot, mean_pcv = [], []
for mat in mat_means:
  mat_plot.append(mat)
  mean_pcv.append(np.mean(mat_means[mat]))

order = np.argsort(mat_plot)
mat_plot_ordered = [mat_plot[i] for i in order]
mean_pcv_ordered = [mean_pcv[i] for i in order]

fitted_poly = Polynomial.fit(all_mat, pca.loc[md.index.values, 'PC2'], deg=4)
w = fitted_poly(mat_plot_ordered)

# w = lowess(mean_pcv_ordered, mat_plot_ordered, frac=0.35, return_sorted=False)
li = plt.plot(mat_plot_ordered, w, 'r-')
corr, p = spearmanr(all_mat, pca.loc[md.index.values, 'PC2'])
string = "Spearman's:\nR="+str(round(corr,3))+', $p$='+str(round(p,3))
tx = pc_y.text(0.98, 0.98, string, ha='right', va='top', transform=pc_y.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

perm_stats = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)
p = round(perm_stats.loc['cur_msd_mat', 'Univariate p'], 3)
if p < 0.001: p = '<0.001'
string_perm = 'PERMANOVA\nUnivariate:\n$R^{2}$='+str(round(perm_stats.loc['cur_msd_mat', 'Univariate R2'], 4))+', $p$='+str(p)+'\n\n'
p = round(perm_stats.loc['cur_msd_mat', 'Deprivation p'], 3)
if p < 0.001: p = '<0.001'
string_perm += 'Multivariate:\n$R^{2}$='+str(round(perm_stats.loc['cur_msd_mat', 'Deprivation R2'], 4))+', $p$='+str(p)
tx = pc_y.text(0.5, -0.15, string_perm, ha='center', va='top', transform=pc_y.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

alpha_metrics = ['chao1', 'faith_pd', 'observed_otus', 'shannon', 'simpson_e', 'simpson']
alpha_metric_name = ['Chao1 richness', "Faith's phylogenetic diversity", "Observed taxa", "Shannon diversity", "Simpson's evenness", "Simpson's index of diversity"]
alpha_axes = [alpha_1, alpha_2, alpha_3, alpha_4, alpha_5, alpha_6]
for a in range(len(alpha_metrics)):
  plt.sca(alpha_axes[a])
  alp = pd.read_csv(folder+'files/alpha_diversity/alpha_'+alpha_metrics[a]+'.csv', index_col=0, header=0)
  alp_stats = pd.read_csv(folder+'files/alpha_stats/'+alpha_metrics[a]+'_summary.csv', index_col=0, header=0)
  sc = alpha_axes[a].scatter(all_mat, alp.loc[md.index.values, 'Mean'], marker='o', color='gray', alpha=0.2)
  # li = plt.plot(np.unique(all_soc), np.poly1d(np.polyfit(all_soc, alp.loc[md.index.values, 'Mean'], 1))(np.unique(all_soc)), 'k--')
  mat_means = {}
  alp_vals = alp.loc[md.index.values, 'Mean']
  for ag in range(len(all_mat)):
    if round(all_mat[ag], 3) in mat_means:
      mat_means[round(all_mat[ag], 3)].append(alp_vals[ag])
    else:
      mat_means[round(all_mat[ag], 3)] = [alp_vals[ag]]
  mat_plot, mean_alp = [], []
  for mat in mat_means:
    mat_plot.append(mat)
    mean_alp.append(np.mean(mat_means[mat]))
  order = np.argsort(mat_plot)
  mat_plot_ordered = [mat_plot[i] for i in order]
  mean_alp_ordered = [mean_alp[i] for i in order]
  
  fitted_poly = Polynomial.fit(all_mat, alp.loc[md.index.values, 'Mean'], deg=4)
  w = fitted_poly(mat_plot_ordered)
  
  # w = lowess(mean_alp_ordered, mat_plot_ordered, frac=0.35, return_sorted=False)
  li = plt.plot(mat_plot_ordered, w, 'r-')
  corr, p = spearmanr(all_mat, alp.loc[md.index.values, 'Mean'])
  anov_p = round(alp_stats.loc['cur_msd_mat', 'Univariate p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string = 'Univariate: F='+str(round(alp_stats.loc['cur_msd_mat', 'Univariate F'], 2))+', $p$='+str(anov_p)+'\n'
  anov_p = round(alp_stats.loc['cur_msd_mat', 'Deprivation p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string += 'Multivariate: F='+str(round(alp_stats.loc['cur_msd_mat', 'Deprivation F'], 2))+', $p$='+str(anov_p)+'\n'
  string += "Spearman's: R="+str(round(corr,3))+', $p$='+str(round(p,3))
  if alpha_metrics[a] != 'simpson' and alpha_metrics[a] != 'shannon':
    tx = alpha_axes[a].text(0.96, 0.96, string, ha='right', va='top', transform=alpha_axes[a].transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))
  else:
    tx = alpha_axes[a].text(0.96, 0.04, string, ha='right', va='bottom', transform=alpha_axes[a].transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))
  yt = plt.ylabel(alpha_metric_name[a], fontweight='bold')
  if a in [2, 5]:
    xt = plt.xlabel('Material deprivation score', fontweight='bold')



plt.savefig(folder+'figures/material_deprivation_overall_plot.png', dpi=600, bbox_inches='tight')
```

# Diet data

## Summary of answers to diet questions

```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants_full_diet.csv', index_col=0, header=0)
metrics = ['dsq2','dsq4','dsq5','dsq6','dsq7','dsq8','dsq9','dsq10','dsq11','dsq12','dsq13','dsq14','dsq15','dsq16','dsq17','dsq18','dsq19','dsq20','dsq21','dsq22','dsq23']
metrics.reverse()

rename_diet_vars = {'strict_diet':'Strict diet', 'dsq2':'Probiotics/prebiotics/supplements', 'dsq4':'Whole grains', 'dsq5':'Refined grains', 'dsq6':'Dairy milk', 'dsq7':'Dairy yoghurt', 'dsq8':'Dairy cheese', 'dsq9':'Non-dairy milk/yoghurt/cheese', 'dsq10':'Soda/sugary drinks', 'dsq11':'Fruit juices', 'dsq12':'Coffee or tea', 'dsq13':'Fruit', 'dsq14':'Vegetables', 'dsq15':'Beans/legumes', 'dsq16':'Red meat', 'dsq17':'Processed meat', 'dsq18':'Poultry', 'dsq19':'Fish/seafood', 'dsq20':'Eggs', 'dsq21':'Tofu/soy', 'dsq22':'Desserts/sweets', 'dsq23':'Salty snacks'}
group_names = ['Never', 'Once per\nmonth', '2-3 times\nper month', 'Once per\nweek', 'Twice per\nweek', '3-4 times\nper week', '5-6 times\nper week', 'Once per\nday', '>2 times\nper day']
group_names_dict = {0.0:'Never', 1.0:'Once per\nmonth', 2.0:'2-3 times\nper month', 3.0:'Once per\nweek', 4.0:'Twice per\nweek', 5.0:'3-4 times\nper week', 6.0:'5-6 times\nper week', 7.0:'Once per\nday', 8.0:'>2 times\nper day'}

# participants = []
# for metric in metrics:
#   md_red = md[md[metric].notnull()]
#   participants.extend(list(md_red.index.values))
# 
# #group = 'South Asian'
# 
# participants = list(set(participants))
# md_red = md.loc[participants, :]
# #md_red = md_red[md_red['ethnicity'] == group]
# md = md_red

title = 'Frequency of consumption\n(Number of participants)'

colors = ['#6886af', '#d7adbe', '#ab94b0', '#116594', '#242d62', '#585387', '#82465c', '#c56477'] # '#adb7dc', '#b6c6db'
colors = ['#ff595e', '#ff924c', '#ffca3a', '#c5ca30', '#8ac926', '#52a675', '#1982c4', '#4267ac', '#6a4c93', '#d677b8']

fig = plt.figure(figsize=(18,20))
ax_metadata = plt.subplot2grid((20,14),(0,0), colspan=7, rowspan=10)
ax_freq = plt.subplot2grid((20,14),(0,7), colspan=3, rowspan=10)
ax_freq_2 = plt.subplot2grid((20,14),(0,10), colspan=3, rowspan=10)

metric_names = []
for metric in metrics:
  for key in rename_diet_vars:
    if key == metric:
      metric = metric.replace('dsq', 'Q')+': '+metric.replace(key, rename_diet_vars[key])
  metric_names.append(metric)

plt.sca(ax_metadata)
m = mpl.cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=0, vmax=100), cmap='GnBu')
for r in range(len(metrics)):
  vals = list(md[md[metrics[r]].notnull()][metrics[r]].values)
  metric_names[r] = metric_names[r]+' ($n$='+str(len(vals))+')'
  counts = []
  for v in set(vals):
    counts.append(vals.count(v))
  counts_perc = [(c/max(counts))*100 for c in counts]
  colors = [m.to_rgba(c) for c in counts_perc]
  ba = ax_metadata.barh([r for a in range(len(counts))], width=[1 for a in range(len(counts))], left=[a for a in range(len(counts))], height=1, color=colors, edgecolor='k')
  for c in range(len(counts)):
    if counts_perc[c] < 80: fc = 'k'
    else: fc = 'w'
    tx = ax_metadata.text(c+0.5, r, str(counts[c]), color=fc, ha='center', va='center')

yl = plt.yticks([x for x in range(len(metrics))], metric_names)
yl = plt.xticks([c+0.5 for c in range(len(counts))], group_names), plt.xlim([0, len(counts)]), plt.ylim([-0.5, r+0.5])
ti = plt.title(title, fontweight='bold')

groups = ['East Asian', 'South Asian', 'White']
m = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=0, vmax=8), cmap=cm.RdPu)
locs = {'East Asian':0, 'South Asian':1, 'White':2}

for ethnicity in groups:
  md_group = md[md['ethnicity'] == ethnicity]
  for r in range(len(metrics)):
    vals = list(md_group[metrics[r]].values)
    freq = stats.mode(vals)[0]
    ba = ax_freq.barh([r], width=[1], left=[locs[ethnicity]], height=1, color=m.to_rgba(freq), edgecolor='k')
    if freq > 4: fc = 'w'
    else: fc = 'k'
    tx = ax_freq.text(locs[ethnicity]+0.5, r, group_names_dict[freq], ha='center', va='center', color=fc)

plt.sca(ax_freq)
yl = plt.xticks([c+0.5 for c in range(len(groups))], [g.replace(' ', '\n') for g in groups], fontweight='bold'), plt.xlim([0, 3]), plt.ylim([-0.5, r+0.5])
yt = plt.yticks([])
tt = ax_freq.xaxis.tick_top()
ti = plt.title('Most common answer', fontweight='bold')

for ethnicity in groups:
  md_group = md[md['ethnicity'] == ethnicity]
  for r in range(len(metrics)):
    vals = list(md_group[metrics[r]].values)
    freq = np.median(vals)
    ba = ax_freq_2.barh([r], width=[1], left=[locs[ethnicity]], height=1, color=m.to_rgba(freq), edgecolor='k')
    if freq > 4: fc = 'w'
    else: fc = 'k'
    tx = ax_freq_2.text(locs[ethnicity]+0.5, r, group_names_dict[freq], ha='center', va='center', color=fc)

plt.sca(ax_freq_2)
yl = plt.xticks([c+0.5 for c in range(len(groups))], [g.replace(' ', '\n') for g in groups], fontweight='bold'), plt.xlim([0, 3]), plt.ylim([-0.5, r+0.5])
yt = plt.yticks([])
tt = ax_freq_2.xaxis.tick_top()
ti = plt.title('Median answer', fontweight='bold')

ax_stat_p = plt.subplot2grid((20,56),(0,52), colspan=1, rowspan=10, frameon=False)
ax_stat = plt.subplot2grid((20,56),(0,54), colspan=2, rowspan=10)
stats_diet = pd.read_csv(folder+'files/alpha_stats/diet_summary.csv', index_col=0, header=0)
f_vals = stats_diet.loc['ethnicity', [col for col in stats_diet.columns if ' F' in col]].values

m = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=min(f_vals), vmax=200), cmap=cm.inferno)

for r in range(len(metrics)):
  if stats_diet.loc['ethnicity', metrics[r]+' p'] <= 0.05:
    st = ax_stat_p.scatter(0.5, r, marker='*', color='k')
  f = stats_diet.loc['ethnicity', metrics[r]+' F']
  ba = ax_stat.barh([r], width=[1], left=[0], height=1, color=m.to_rgba(f), edgecolor='k')
  if f < 100: color='w'
  else: color='k'
  if f < 10: fv = ax_stat.text(0.5, r, str(round(f, 1)), ha='center', va='center', color=color)
  else: fv = ax_stat.text(0.5, r, str(int(f)), ha='center', va='center', color=color)
    

plt.sca(ax_stat_p)
yl = plt.ylim([-0.5, r+0.5]), plt.yticks([]), plt.xticks([])

plt.sca(ax_stat)
yl = plt.ylim([-0.5, r+0.5]), plt.yticks([]), plt.xticks([])
ti = plt.title('ANOVA\nF statistic', fontweight='bold')

plt.savefig(folder+'figures/diet_metadata_overall_most_common_median.png', dpi=600, bbox_inches='tight')
```

## PERMANOVA and correlation with alpha/beta diversity

```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants_full_diet.csv', index_col=0, header=0)
metrics = ['dsq2','dsq4','dsq5','dsq6','dsq7','dsq8','dsq9','dsq10','dsq11','dsq12','dsq13','dsq14','dsq15','dsq16','dsq17','dsq18','dsq19','dsq20','dsq21','dsq22','dsq23','HEFI', 'diet_richness_weekly', 'strict_diet']
permanova = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)

rename_diet_vars = {'strict_diet':'Strict diet', 'dsq2':'Probiotics/prebiotics/supplements', 'dsq4':'Whole grains', 'dsq5':'Refined grains', 'dsq6':'Dairy milk', 'dsq7':'Dairy yoghurt', 'dsq8':'Dairy cheese', 'dsq9':'Non-dairy milk/yoghurt/cheese', 'dsq10':'Soda/sugary drinks', 'dsq11':'Fruit juices', 'dsq12':'Coffee or tea', 'dsq13':'Fruit', 'dsq14':'Vegetables', 'dsq15':'Beans/legumes', 'dsq16':'Red meat', 'dsq17':'Processed meat', 'dsq18':'Poultry', 'dsq19':'Fish/seafood', 'dsq20':'Eggs', 'dsq21':'Tofu/soy', 'dsq22':'Desserts/sweets', 'dsq23':'Salty snacks','HEFI':'Healthy Eating Index', 'diet_richness_weekly':'Diet variety score (weekly)'}

permanova_red = permanova.loc[metrics, :]
permanova_red = permanova_red.sort_values(by='Univariate R2', ascending=True)

fig = plt.figure(figsize=(20,10))
ax_permanova = plt.subplot2grid((20,19),(0,0), colspan=3, rowspan=20)
ax_correlations_beta = plt.subplot2grid((20,19),(0,3), colspan=3, rowspan=20)
ax_alpha_stats = plt.subplot2grid((20,19),(0,6), colspan=3, rowspan=20)
ax_correlations_alpha = plt.subplot2grid((20,19),(0,9), colspan=6, rowspan=20)

plt.sca(ax_permanova)
labels = []
for l in range(len(permanova_red.index.values)):
  label = permanova_red.index.values[l]
  r2, p = permanova_red.loc[label, 'Univariate R2'], permanova_red.loc[label, 'Univariate p']
  if p <= 0.05: bar_col = '#008B90'
  else: bar_col = 'w'
  ba = ax_permanova.barh(l+0.45, width=r2, height=0.4, color=bar_col, edgecolor='#008B90')
  if r2 >= 0.004: tx = ax_permanova.text(r2/2, l+0.45, str(round(r2, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova.text(r2+0.0001, l+0.45, str(round(r2, 4)), color='k', ha='left', va='center')
  
  r2_mul, p_mul = permanova_red.loc[label, 'Diet R2'], permanova_red.loc[label, 'Diet p']
  if p_mul <= 0.05: bar_col_mul = '#bb8fce'
  else: bar_col_mul = 'w'
  ba = ax_permanova.barh(l, width=r2_mul, height=0.4, color=bar_col_mul, edgecolor='#bb8fce')
  if r2_mul >= 0.004: tx = ax_permanova.text(r2_mul/2, l, str(round(r2_mul, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova.text(r2_mul+0.0001, l, str(round(r2_mul, 4)), color='k', ha='left', va='center')
  
  new_label = label
  for orig in rename_diet_vars:
    if label == orig:
      new_label = new_label.replace(orig, rename_diet_vars[orig])
  labels.append(new_label)

yl = plt.yticks([x+0.25 for x in range(permanova_red.shape[0])], labels), plt.ylim([-0.25, permanova_red.shape[0]-0.25])
ti = plt.title('A', fontweight='bold', loc='left'), plt.xlabel('PERMANOVA R$^{2}$', fontweight='bold'), plt.title('Contribution to\nvariation', fontweight='bold')

colors_r2, names_r2 = ['#008B90', '#bb8fce'], ['Univariate', 'Multivariate']
handles_r2 = [Line2D([0], [0], marker='s', color='w', label=names_r2[r], markerfacecolor=colors_r2[r], markersize=12) for r in range(len(names_r2))]
colors_r2_sig, names_r2_sig = ['k', 'w'], ['PERMANOVA $p$0.05', 'Not significant']
handles_r2_sig = [Line2D([0], [0], marker='s', color='w', label=names_r2_sig[r], markerfacecolor=colors_r2_sig[r], markeredgecolor='k', markersize=12) for r in range(len(names_r2_sig))]
leg = ax_permanova.legend(handles=handles_r2+handles_r2_sig, loc='upper right', bbox_to_anchor=(-0.11,0))

alpha_metrics = ['faith_pd', 'simpson_e', 'simpson']#['chao1', 'observed_otus', 'faith_pd', 'simpson_e', 'simpson', 'shannon']
alpha_metrics = ['chao1', 'observed_otus', 'faith_pd', 'simpson_e', 'simpson', 'shannon']
for r in range(len(permanova_red.index.values)):
  row = permanova_red.index.values[r]
  this_alpha = []
  this_alpha_2 = []
  for metric in alpha_metrics:
    alpha_stats = pd.read_csv(folder+'files/alpha_stats/'+metric+'_summary.csv', index_col=0, header=0)
    this_alpha.append(alpha_stats.loc[row, 'Univariate p'])
    this_alpha_2.append(alpha_stats.loc[row, 'Diet p'])
  this_alpha = ['#008B90' if a <= 0.05 else 'w' for a in this_alpha]
  this_alpha_2 = ['#bb8fce' if a <= 0.05 else 'w' for a in this_alpha_2]
  for a in [0, 1, 2, 3, 4, 5]:
    pl = ax_alpha_stats.fill([a, a, a+1], [r, r+1, r+1], color=this_alpha[a], edgecolor='k')
    pl = ax_alpha_stats.fill([a, a+1, a+1], [r, r, r+1], color=this_alpha_2[a], edgecolor='k')

plt.sca(ax_alpha_stats)
yl = plt.yticks([]), plt.xticks([0.5, 1.5, 2.5, 3.5, 4.5, 5.5], ["Ch.", "Obs.", "FPD", "SE", "SI", "Sh."]), plt.xlim([0, 6]), plt.ylim([0, permanova_red.shape[0]])
ti = plt.title('C', fontweight='bold', loc='left'), plt.title('Alpha div.\nstats', fontweight='bold')

for r in range(len(permanova_red.index.values)):
  #if r > 1: continue
  #if permanova_red.index.values[r] == 'HEFI': continue
  md_var = md[md[permanova_red.index.values[r]].notnull()]
  md_var = md_var.loc[[sam for sam in md_var.index.values if sam in pca.index.values], :]
  #all_xvals, yvals = [[], [], [], [], [], [], ], []
  this_group_pc1, this_group_pc2, this_group_pc3 = pca.loc[md_var.index.values, 'PC1'], pca.loc[md_var.index.values, 'PC2'], pca.loc[md_var.index.values, 'PC3']
  all_plotting = [this_group_pc1, this_group_pc2, this_group_pc3]
  for m in range(len(alpha_metrics)):
    alpha = pd.read_csv(folder+'files/alpha_diversity/alpha_'+alpha_metrics[m]+'.csv', index_col=0, header=0).loc[md_var.index.values, 'Mean']
    all_plotting.append(alpha)
  correlations, pvals = [], []
  xvals = md_var.loc[:, permanova_red.index.values[r]].values
  for plot in all_plotting:
    corr, p = spearmanr(xvals, plot.values)
    correlations.append(corr)
    pvals.append(p)
  m = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=-0.2, vmax=0.2), cmap='RdBu_r')
  m2 = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=0, vmax=0.2), cmap='YlGn')
  correlations_color = [m.to_rgba(corr) for corr in correlations]
  correlations_color_2 = [m2.to_rgba(abs(corr)) for corr in correlations]
  left = [a for a in range(len(correlations))]
  for l in range(len(left)):
    if l > 2: left[l] += 0.5
  ba = ax_correlations_beta.barh([r for a in range(len(correlations))][:3], width=[1 for a in range(len(correlations))][:3], left=left[:3], height=1, color=correlations_color_2[:3], edgecolor='k')
  ba = ax_correlations_alpha.barh([r for a in range(len(correlations))][3:], width=[1 for a in range(len(correlations))][3:], left=left[3:], height=1, color=correlations_color[3:], edgecolor='k')
  for c in range(len(correlations)):
    if abs(correlations[c]) > 0.1: fc = 'w'
    else: fc = 'k'
    if c < 3:
      tx = ax_correlations_beta.text(left[c]+0.5, r, str(round(correlations[c], 3)), color=fc, ha='center', va='center')
    else:
      tx = ax_correlations_alpha.text(left[c]+0.5, r, str(round(correlations[c], 3)), color=fc, ha='center', va='center')

plt.sca(ax_correlations_beta)
xt = plt.xticks([l+0.5 for l in left][:3], ['PC1 ('+str(round(prop_explain[0]*100, 2))+'%)', 'PC2 ('+str(round(prop_explain[1]*100, 2))+'%)', 'PC3 ('+str(round(prop_explain[2]*100, 2))+'%)'], rotation=90), plt.ylim([-0.5, permanova_red.shape[0]-0.5]), plt.xlim([left[0], left[2]+1]), plt.yticks([])
ti = plt.title('B', loc='left', fontweight='bold'), plt.title("Spearman's\ncorrelations with\nbeta diversity", fontweight='bold')

plt.sca(ax_correlations_alpha)
xt = plt.xticks([l+0.5 for l in left][3:], ['Chao 1 richness', 'Number of ASVs', "Faith's PD", "Simpson's evenness", "Simpson's index", "Shannon diversity"], rotation=90), plt.ylim([-0.5, permanova_red.shape[0]-0.5]), plt.xlim([left[3], left[-1]+1]), plt.yticks([])
ti = plt.title('D', loc='left', fontweight='bold'), plt.title("Spearman's correlations with alpha diversity", fontweight='bold')

plt.savefig(folder+'figures/diet_permanova_correlation.png', dpi=600, bbox_inches='tight')
```

## Correlation

```{python}
metrics = ['HEFI','diet_richness_weekly','dsq2','dsq4','dsq5','dsq6','dsq7','dsq8','dsq9','dsq10','dsq11','dsq12','dsq13','dsq14','dsq15','dsq16','dsq17','dsq18','dsq19','dsq20','dsq21','dsq22','dsq23']

rename_diet_vars = {'strict_diet':'Strict diet', 'diet_richness_weekly':'Diet variety score (weekly)', 'dsq2':'Probiotics/prebiotics/supplements', 'dsq4':'Whole grains', 'dsq5':'Refined grains', 'dsq6':'Dairy milk', 'dsq7':'Dairy yoghurt', 'dsq8':'Dairy cheese', 'dsq9':'Non-dairy milk/yoghurt/cheese', 'dsq10':'Soda/sugary drinks', 'dsq11':'Fruit juices', 'dsq12':'Coffee or tea', 'dsq13':'Fruit', 'dsq14':'Vegetables', 'dsq15':'Beans/legumes', 'dsq16':'Red meat', 'dsq17':'Processed meat', 'dsq18':'Poultry', 'dsq19':'Fish/seafood', 'dsq20':'Eggs', 'dsq21':'Tofu/soy', 'dsq22':'Desserts/sweets', 'dsq23':'Salty snacks','HEFI':'HEFI'}

fig = plt.figure(figsize=(22,16.5))
corr_ax = plt.subplot2grid((44,90),(1,0), rowspan=20, colspan=45)

ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants_full_diet.csv', index_col=0, header=0)
ft = ft.loc[:, md.index.values]
tax_df = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)

ft_relabun = ft.copy(deep=True)
ft_relabun = ft_relabun.divide(ft_relabun.sum(axis=0), axis=1).multiply(100)
ft_relabun['Mean'] = ft_relabun.mean(axis=1)
ft_relabun = ft_relabun.sort_values(by=['Mean'], ascending=False)
ft_relabun.drop('Mean', axis=1, inplace=True)

ft_relabun = ft_relabun.head(20)
tax_reverse = list(ft_relabun.index.values)
tax_reverse.reverse()
ft_relabun = ft_relabun.loc[tax_reverse, :]

all_correlations, all_pvals = [], []
for tax in ft_relabun.index.values:
  this_tax_correlation, this_tax_pval = [], []
  for metric in metrics:
    sample_vals, tax_vals = [], []
    for sample in md.index.values:
      md_val = md.loc[sample, metric]
      if not math.isnan(md_val):
        sample_vals.append(md_val)
        tax_vals.append(ft_relabun.loc[tax, sample])
    corr, p = spearmanr(sample_vals, tax_vals)
    ap = this_tax_correlation.append(corr), this_tax_pval.append(p)
  ap = all_correlations.append(this_tax_correlation), all_pvals.append(this_tax_pval)

all_correlations = pd.DataFrame(all_correlations, index=ft_relabun.index.values, columns=metrics)
all_pvals = pd.DataFrame(all_pvals, index=ft_relabun.index.values, columns=metrics)

ha = corr_ax.pcolor(all_correlations, edgecolor='k', cmap='RdBu_r', vmin=-0.14, vmax=0.14)
tax_plot = []
for row in ft_relabun.index.values:
  tax_plot.append(tax_df.loc[row, 'Genus'])

yl = plt.yticks([a+0.5 for a in range(len(ft_relabun.index.values))], tax_plot)
xt = plt.xticks([a+0.5 for a in range(len(metrics))], [rename_diet_vars[m] for m in metrics], rotation=90)
tt = corr_ax.xaxis.tick_top()

mid = 0.1
for r in range(len(all_correlations.index.values)):
  for c in range(len(all_correlations.columns)):
    pval = all_pvals.iloc[r, c]
    val = all_correlations.iloc[r, c]
    if abs(val) >= mid: col = 'w'
    else: col = 'k'
    if abs(val) >= 0.01: val = round(val, 2)
    else: val = round(val, 3)
    if pval <= 0.05: tx = corr_ax.text(c+0.5, r+0.5, str(val), ha='center', va='center', color=col, fontsize=8, fontweight='bold')
    else: tx = corr_ax.text(c+0.5, r+0.5, str(val), ha='center', va='center', color=col, fontsize=6)

plt.savefig(folder+'figures/diet_correlation.png', dpi=600, bbox_inches='tight')
```

## Differential abundance

```{python}
metrics = ['HEFI','diet_richness_weekly','dsq4','dsq5','dsq6','dsq7','dsq8','dsq10','dsq11','dsq13','dsq14','dsq15','dsq16','dsq17','dsq18','dsq19','dsq20','dsq21','dsq22','dsq23']

rename_diet_vars = {'strict_diet':'Strict diet', 'diet_richness_weekly':'Diet variety\nscore (weekly)', 'dsq2':'Probiotics/prebiotics/\nsupplements', 'dsq4':'Whole grains', 'dsq5':'Refined grains', 'dsq6':'Dairy milk', 'dsq7':'Dairy yoghurt', 'dsq8':'Dairy cheese', 'dsq9':'Non-dairy milk/\nyoghurt/cheese', 'dsq10':'Soda/sugary drinks', 'dsq11':'Fruit juices', 'dsq12':'Coffee or tea', 'dsq13':'Fruit', 'dsq14':'Vegetables', 'dsq15':'Beans/legumes', 'dsq16':'Red meat', 'dsq17':'Processed meat', 'dsq18':'Poultry', 'dsq19':'Fish/seafood', 'dsq20':'Eggs', 'dsq21':'Tofu/soy', 'dsq22':'Desserts/sweets', 'dsq23':'Salty snacks','HEFI':'HEFI'}

fig = plt.figure(figsize=(22,20))
dendro_ax = plt.subplot2grid((44,90),(0,4), rowspan=4, colspan=45, frameon=False)
corr_ax = plt.subplot2grid((44,90),(9,4), rowspan=20, colspan=45)
abun_ax = plt.subplot2grid((44,90),(9,0), rowspan=20, colspan=2, frameon=False)
prev_ax = plt.subplot2grid((44,90),(9,2), rowspan=20, colspan=2)

ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants_full_diet.csv', index_col=0, header=0)
ft = ft.loc[:, md.index.values]
tax_df = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)

tax_rename = {}
for row in ft.index.values:
  tax_rename[row] = tax_df.loc[row, 'Genus']
  
for tax in tax_rename:
  if tax_rename[tax] == 'Unclassified f__Comamonadaceae': print(tax)
  
ft = ft.rename(index=tax_rename)
ft = ft.divide(ft.sum(axis=0), axis=1).multiply(100)
ft['Mean'] = ft.mean(axis=1)
# ft = ft[ft['Mean'] >= 0.01]

ft_prev = ft.copy(deep=True)
ft_prev[ft_prev > 0] = 1
ft_prev['Prevalence'] = ft_prev.sum(axis=1)/ft.shape[1]
# ft_prev = ft_prev[ft_prev['Prevalence'] >= 0.05]

ft['Prevalence'] = ft_prev.loc[ft.index.values, 'Prevalence']

taxa = []
all_coefficients, all_qvals = [], []
for metric in metrics:
  da = pd.read_csv(folder+'differential_abundance/'+metric+'_maaslin.csv', index_col=0, header=0)
  sig_da = da[da['maaslin_qval_abun'] <= 0.1]
  sig_da_prev = []
  # for tax in sig_da.index.values:
  #   if tax in ft_prev.index.values and tax in ft.index.values:
  #     sig_da_prev.append(tax)
  sig_da_prev = list(sig_da.index.values)
  taxa.extend(sig_da_prev)
  all_coefficients.append(da.loc[:, ['maaslin_coef_abun']].rename(columns={'maaslin_coef_abun':metric}))
  all_qvals.append(da.loc[:, ['maaslin_qval_abun']].rename(columns={'maaslin_qval_abun':metric}))
  
taxa = list(set(taxa))
all_coefficients = pd.concat(all_coefficients)
all_coefficients = all_coefficients.groupby(by=all_coefficients.index, axis=0).sum()
all_coefficients = all_coefficients.loc[taxa, :]

all_coefficients_abs = all_coefficients.copy(deep=True).abs()
all_coefficients_abs['Mean'] = all_coefficients_abs.mean(axis=1)
all_coefficients_abs = all_coefficients_abs.sort_values(by=['Mean'], ascending=True)

all_coefficients = all_coefficients.loc[all_coefficients_abs.index.values, :]

ft = ft.loc[all_coefficients.index.values, :]
ft = ft.sort_values(by=['Mean', 'Prevalence'], ascending=True)
all_coefficients = all_coefficients.loc[ft.index.values, :]

all_qvals = pd.concat(all_qvals)
all_qvals = all_qvals.groupby(by=all_qvals.index, axis=0).sum()
all_qvals = all_qvals.loc[all_coefficients.index.values, :]

X = all_coefficients.transpose().iloc[0:].values
similarities = np.nan_to_num(distance.cdist(X, X, 'braycurtis'))
dist = pd.DataFrame(similarities, columns=all_coefficients.columns, index=all_coefficients.columns)
dist.columns, dist.index = all_coefficients.columns, all_coefficients.columns
plt.sca(dendro_ax)
Z = ssd.squareform(dist)
Z = hierarchy.linkage(Z, "ward")
mpl.rcParams['lines.linewidth'] = 2
hierarchy.set_link_color_palette(['k'])
dn = hierarchy.dendrogram(Z, above_threshold_color='k', orientation='top')
sample_order = [all_coefficients.columns[int(l.get_text())] for l in list(dendro_ax.get_xticklabels())]
# sample_plot = [rename_diet_vars[m].replace('\n', '                               \n')+'                               ' for m in sample_order]
# ti = plt.xticks(list(dendro_ax.get_xticks()), sample_plot, rotation=90, va='center'), plt.yticks([])
sample_plot = [rename_diet_vars[m] for m in sample_order]
ti = plt.xticks(list(dendro_ax.get_xticks()), sample_plot, rotation=90), plt.yticks([])

all_coefficients = all_coefficients.loc[:, sample_order]
all_qvals = all_qvals.loc[:, sample_order]

plt.sca(corr_ax)
ha = corr_ax.pcolor(all_coefficients, edgecolor='k', cmap='RdBu_r', vmin=-0.3, vmax=0.3)
yl = plt.yticks([]), plt.xticks([])
# xt = plt.xticks([a+0.5 for a in range(len(metrics))], [rename_diet_vars[m] for m in metrics], rotation=90)
# tt = corr_ax.xaxis.tick_top()

mid = 0.15
for r in range(len(all_coefficients.index.values)):
  for c in range(len(all_coefficients.columns)):
    pval = all_qvals.iloc[r, c]
    val = all_coefficients.iloc[r, c]
    if abs(val) >= mid: col = 'w'
    else: col = 'k'
    if abs(val) >= 0.01: val = round(val, 2)
    else: val = round(val, 3)
    if pval <= 0.1: tx = corr_ax.text(c+0.5, r+0.5, str(val), ha='center', va='center', color=col, fontsize=8, fontweight='bold')
    else: tx = corr_ax.text(c+0.5, r+0.5, str(val), ha='center', va='center', color=col, fontsize=6)

plt.sca(abun_ax)
for r in range(len(all_coefficients.index.values)):
  tax = all_coefficients.index.values[r]
  mean_val = ft.loc[tax, 'Mean']
  sc = abun_ax.scatter(0.5, r+0.5, color='k', s=12*mean_val)
  
tax_print = list(all_coefficients.index.values)
tax_print.reverse()
print(ft.loc[tax_print, ['Mean', 'Prevalence']])
  
sp_names = []
for tax in all_coefficients.index.values:
  this_tax = str(tax)
  if 'g__' in this_tax:
    if '_[' in this_tax:
      this_tax = this_tax.replace('g__', '$').replace('_[', '$ [')
    else:
      this_tax = this_tax.replace('g__', '$')+'$'
  sp_names.append(this_tax)

yl = plt.yticks([a+0.5 for a in range(len(all_coefficients.index.values))], sp_names), plt.xticks([])
yl = plt.ylim([0, r+1]), plt.xlim([0, 1])
abun_ax.tick_params(axis=u'both', which=u'both',length=0)

plt.sca(prev_ax)
ha = prev_ax.pcolor(ft.loc[:, ['Prevalence']], edgecolor='k', cmap='Blues', vmin=0, vmax=1)
yl = plt.yticks([]), plt.xticks([])

mid = 0.5
for r in range(len(all_coefficients.index.values)):
  val = ft.loc[all_coefficients.index.values[r], 'Prevalence']
  if abs(val) >= mid: col = 'w'
  else: col = 'k'
  tx = prev_ax.text(0.5, r+0.5, str(round(val, 2)), ha='center', va='center', color=col, fontsize=8, fontweight='bold')

plt.savefig(folder+'figures/diet_differential_abundance.png', dpi=600, bbox_inches='tight')
```

## Antibiotics plot

```{python}
fig = plt.figure(figsize=(20,28))

pcoa = plt.subplot2grid((12,9),(0,0), rowspan=3, colspan=3)
pc_x = plt.subplot2grid((12,9),(3,0), colspan=3)
pc_y = plt.subplot2grid((12,9),(0,3), rowspan=3)

ax_alp_lab = plt.subplot2grid((36,28),(0,14), rowspan=4, colspan=14, frameon=False)
ti = ax_alp_lab.set_title('Alpha diversity', fontweight='bold')

alpha_1 = plt.subplot2grid((36,28),(0,14), rowspan=6, colspan=4)
alpha_2 = plt.subplot2grid((36,28),(6,14), rowspan=6, colspan=4)
alpha_3 = plt.subplot2grid((36,28),(0,19), rowspan=6, colspan=4)
alpha_4 = plt.subplot2grid((36,28),(6,19), rowspan=6, colspan=4)
alpha_5 = plt.subplot2grid((36,28),(0,24), rowspan=6, colspan=4)
alpha_6 = plt.subplot2grid((36,28),(6,24), rowspan=6, colspan=4)

abun_ax = plt.subplot2grid((72,54), (30,0), rowspan=30, colspan=10)
prev_ax = plt.subplot2grid((72,54), (30,11), rowspan=30, colspan=10)
abun_labels = plt.subplot2grid((72,54), (29,0), rowspan=1, colspan=10)
prev_labels = plt.subplot2grid((72,54), (29,11), rowspan=1, colspan=10)
maaslin_ax = plt.subplot2grid((72,54), (30,23), rowspan=30, colspan=4)
maaslin_prev_ax = plt.subplot2grid((72,54), (30,27), rowspan=30, colspan=4)
maaslin_labels = plt.subplot2grid((72,54), (29,23), rowspan=1, colspan=4)
maaslin_prev_labels = plt.subplot2grid((72,54), (29,27), rowspan=1, colspan=4)

sens_with_ab = plt.subplot2grid((72,54), (30,41), rowspan=30, colspan=6)
sens_no_ab = plt.subplot2grid((72,54), (30,48), rowspan=30, colspan=6, sharex=sens_with_ab)
sens_labels = plt.subplot2grid((72,54), (28,41), rowspan=1, colspan=13, frameon=False)

ax_rem = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels, ax_alp_lab, sens_labels]
ax_lab = [abun_labels, prev_labels, maaslin_labels, maaslin_prev_labels]
for ax in ax_rem:
  xt = ax.set_xticks([]), ax.set_yticks([])
labels_colors = [[[1, 2], colors_antibiotics, ['No', 'In the last month'], ['w', 'k'], 'Relative abundance (%)'], [[1, 2], colors_antibiotics, ['No', 'In the last month'], ['w', 'k'], 'Prevalence'], [[1], colors_age, ['Abundance'], ['k'], ''], [[1], colors_age, ['Prevalence'], ['k'], '']]#, [[1], 'no_colors', ['$n$=2970'], ['k'], 'With\nantibiotic use'], [[1], 'no_colors', ['$n$=2770'], ['k'], 'Without\nantibiotic use']]
for l in range(len(ax_lab)):
  if labels_colors[l] == []: continue
  locs, colors, names, font_col = labels_colors[l][0], labels_colors[l][1], labels_colors[l][2], labels_colors[l][3]
  if l < 2: ba = ax_lab[l].bar(locs, [1 for c in locs], color=[colors[c] for c in names], width=1, edgecolor='k')
  else: ba = ax_lab[l].bar(locs, [1 for c in locs], color='w', width=1, edgecolor='k')
  #else: ba = ax_lab[l].bar(locs, [1 for c in locs], color='w', width=1, edgecolor='k')
  tx = [ax_lab[l].text(locs[t], 0.5, names[t], ha='center', va='center', color=font_col[t], fontsize=10) for t in range(len(locs))]
  li = ax_lab[l].set_xlim([locs[0]-0.5, locs[-1]+0.5]), ax_lab[l].set_ylim([0, 1])
  ti = ax_lab[l].set_title(labels_colors[l][4], fontweight='bold')

ti = maaslin_labels.set_title(' Differential abundance', fontweight='bold', loc='left')
ti = sens_labels.set_title('Sensitivity analysis', fontweight='bold')
ti = sens_with_ab.set_title('With antibiotic\nuse ($n$=2594)', fontweight='bold')
ti = sens_no_ab.set_title('Without antibiotic\nuse ($n$=2426)', fontweight='bold')

ft = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
md = pd.read_csv(folder+'files/metadata_microbiome_participants_full_diet.csv', index_col=0, header=0)
ft = ft.loc[:, md.index.values]

tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
rename_tax = {}
for row in tax.index.values:
  rename_tax[row] = tax.loc[row, 'Genus']

ft = ft.rename(index=rename_tax)
ft_prev = ft.copy(deep=True)
ft_prev[ft_prev > 0] = 1
ft_relabun = ft.copy(deep=True)
ft_relabun = ft_relabun.divide(ft_relabun.sum(axis=0), axis=1).multiply(100)
ft_relabun['Mean'] = ft_relabun.mean(axis=1)
ft_relabun = ft_relabun.sort_values(by=['Mean'], ascending=False)
ft_relabun.drop('Mean', axis=1, inplace=True)

all_da_sig = pd.read_csv(folder+'differential_abundance/antibiotics_maaslin.csv', index_col=0, header=0)

#get taxa to plot
all_sig_tax = all_da_sig[all_da_sig['maaslin_qval_abun'] <= 0.1]
most_abun_tax = ft_relabun.head(20)
all_tax_keeping = list(all_sig_tax.index.values)+list(most_abun_tax.index.values)
all_tax_keeping = list(set(all_tax_keeping))
tax_keeping_order = [row for row in ft_relabun.index.values if row in all_tax_keeping]

ft_relabun = ft_relabun.loc[tax_keeping_order, :]
tax_reverse = list(ft_relabun.index.values)
tax_reverse.reverse()
ft_relabun = ft_relabun.loc[tax_reverse, :]
ft_prev = ft_prev.loc[tax_reverse, :]
all_da = all_da_sig.loc[tax_reverse, :]

hm_groups = ['antibiotics', 'antibiotics']
hm_axes = [abun_ax, prev_ax]
hm_maps = ['viridis', 'Blues']
fts = [ft_relabun, ft_prev]
for g in range(len(hm_groups)):
  ft = fts[g].copy(deep=True)
  rename_sample = {}
  for col in ft.columns:
    st = md.loc[col, hm_groups[g]]
    rename_sample[col] = st
  ft = ft.rename(columns=rename_sample)
  ft = ft.groupby(by=ft.columns, axis=1).mean()
  ft = ft.loc[:, ['no', 'in_the_last_month']]
  ft_norm = ft.copy(deep=True).transpose()
  if g == 0:
    ft_norm = ft_norm.divide(ft_norm.max(axis=0), axis=1).transpose()
  else:
    ft_norm = ft_norm.transpose()
  ha = hm_axes[g].pcolor(ft_norm, edgecolor='k', cmap=hm_maps[g])
  mid = np.mean([max(ft_norm.max(axis=1).values), min(ft_norm.min(axis=1).values)])
  for r in range(len(ft_norm.index.values)):
    for c in range(len(ft_norm.columns)):
      norm_val = ft_norm.iloc[r, c]
      val = ft.iloc[r, c]
      if norm_val < mid:
        if g == 0: col = 'w'
        else: col = 'k'
      else:
        if g == 0: col = 'k'
        else: col = 'w'
      if val >= 10: val = round(val, 1)
      elif val > 1: val = round(val, 2)
      elif val > 0.0001: val = round(val, 4)
      else: val = round(val, 6)
      if g > 1: fs = 10
      else: fs = 10
      tx = hm_axes[g].text(c+0.5, r+0.5, str(val), va='center', ha='center', color=col, fontsize=fs)
  plt.sca(hm_axes[g])
  if g == 1: yt = hm_axes[g].set_yticks([])
  else:
    taxa_names = []
    for name in ft_relabun.index.values:
      if '_[' in name: taxa_name = name.replace('g__', ' ').replace('_[', ' [')
      elif 'g__' not in name: taxa_name = name
      else: taxa_name = name.replace('g__', ' $')+'$'
      taxa_names.append(taxa_name)
    yt = plt.yticks([a+0.5 for a in range(len(ft_relabun.index.values))], taxa_names)
  xt = hm_axes[g].set_xticks([])

axes = [maaslin_ax, maaslin_prev_ax]
names = ['maaslin_coef_abun', 'maaslin_coef_prev']
qvals = ['maaslin_qval_abun', 'maaslin_qval_prev']

for t in range(len(all_da.index.values)):
  tax = all_da.index.values[t]
  for l in range(len(names)):
    this_sig = all_da.loc[tax, qvals[l]]
    if this_sig <= 0.1:
      sig = True
    else:
      sig = False
    if sig:
      val = all_da.loc[tax, names[l]]
      ba = axes[l].barh(t, 1, height=1, left=0, color='#e67e22', alpha=0.5, edgecolor='k')
      sc = axes[l].scatter(0.5, t, marker='*', color='k')
    else:
      ba = axes[l].barh(t, 1, height=1, left=0, color='gray', alpha=0.5, edgecolor='k')

for ax in axes:
  plt.sca(ax)
  yt = plt.yticks([]), plt.xticks([])
  yl = plt.ylim([-0.5, t+0.5]), plt.xlim([0, 1])

pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_ordination_pca.csv', index_col=0, header=0)
prop_explain = [0.6386125734929017, 0.3023029246310683, 0.05908450187603021]
#pcoa plot
count = 0
all_ab = md.loc[:, 'antibiotics']
colors_plot = [colors_antibiotics[g] for g in all_ab]
sc = pcoa.scatter(pca.loc[md.index.values, 'PC1'], pca.loc[md.index.values, 'PC2'], marker='o', color=colors_plot, alpha=0.4)

groups_plotting_pc1, groups_plotting_pc2 = [], []
x_ab = {'no':1, 'in_the_last_month':2}
for ab in ['no', 'in_the_last_month']:
  participants = md[md['antibiotics'] == ab].index.values
  group_plotting_pc1 = pca.loc[participants, 'PC1']
  group_plotting_pc2 = pca.loc[participants, 'PC2']
  groups, axes = [group_plotting_pc1, group_plotting_pc2], [pc_x, pc_y]
  for g in range(len(groups)):
    if g == 0:
      box = axes[g].boxplot(groups[g], positions=[x_ab[ab]], patch_artist=True, vert=False, showfliers=False, widths=0.3)
      vp = axes[g].violinplot(groups[g], points=500, positions=[x_ab[ab]], showmeans=False, showextrema=False, showmedians=False, vert=False, side='high', widths=0.6)
      sc = axes[g].scatter(groups[g], np.random.normal(x_ab[ab]-0.3, scale=0.04, size=len(groups[g])), marker='o', color=colors_antibiotics[ab], alpha=0.05)
    else:
      box = axes[g].boxplot(groups[g], positions=[x_ab[ab]], patch_artist=True, vert=True, showfliers=False, widths=0.3)
      vp = axes[g].violinplot(groups[g], points=500, positions=[x_ab[ab]], showmeans=False, showextrema=False, showmedians=False, vert=True, side='low', widths=0.6)
      sc = axes[g].scatter(np.random.normal(x_ab[ab]+0.3, scale=0.04, size=len(groups[g])), groups[g], marker='o', color=colors_antibiotics[ab], alpha=0.05)
    for item in ['whiskers', 'medians', 'caps']: bi = plt.setp(box[item], color='k')
    for patch, color in zip(box['boxes'], [colors_antibiotics[ab]]):
      patch.set_facecolor(color)
      patch.set_alpha(0.4)
    for idx, b in enumerate(vp['bodies']):
      b.set_color(colors_antibiotics[ab])
      b.set_alpha(0.4)

plt.sca(pcoa)
ti = plt.title('Beta diversity: phylogenetic-RPCA', fontweight='bold')
xt = plt.xticks([])
al = plt.ylabel('PC2 ('+str(round(prop_explain[1]*100, 2))+'%)', fontweight='bold')
handles_ab = [Line2D([0], [0], marker='s', color='w', label=ab.replace('no', 'No').replace('in_the_last_month', 'In the last month'), markerfacecolor=colors_antibiotics[ab], markersize=12) for ab in ['no', 'in_the_last_month']]
leg = pcoa.legend(handles=handles_ab, loc='lower right')

plt.sca(pc_x)
al = plt.xlabel('PC1 ('+str(round(prop_explain[0]*100, 2))+'%)', fontweight='bold')
yt = plt.yticks([1, 2], ['No', 'In the\nlast month'])

plt.sca(pc_y)
yt = plt.xticks([1, 2], ['No', 'In the\nlast month'], rotation=90), plt.yticks([])

stats = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)
p = round(stats.loc['antibiotics', 'Univariate p'], 3)
if p < 0.001: p = '<0.001'
string_perm = 'PERMANOVA\nUnivariate:\n$R^{2}$='+str(round(stats.loc['antibiotics', 'Univariate R2'], 4))+', $p$='+str(p)+'\n\n'
p = round(stats.loc['antibiotics', 'Diet p'], 3)
if p < 0.001: p = '<0.001'
string_perm += 'Multivariate:\n$R^{2}$='+str(round(stats.loc['antibiotics', 'Diet R2'], 4))+', $p$='+str(p)
tx = pc_y.text(0.5, -0.25, string_perm, ha='center', va='top', transform=pc_y.transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))

alpha_metrics = ['chao1', 'faith_pd', 'observed_otus', 'shannon', 'simpson_e', 'simpson']
alpha_metric_name = ['Chao1 richness', "Faith's phylogenetic diversity", "Observed taxa", "Shannon diversity", "Simpson's evenness", "Simpson's index of diversity"]
alpha_axes = [alpha_1, alpha_2, alpha_3, alpha_4, alpha_5, alpha_6]
for a in range(len(alpha_metrics)):
  plt.sca(alpha_axes[a])
  alp = pd.read_csv(folder+'files/alpha_diversity/alpha_'+alpha_metrics[a]+'.csv', index_col=0, header=0)
  stats = pd.read_csv(folder+'files/alpha_stats/'+alpha_metrics[a]+'_summary.csv', index_col=0, header=0)
  for ab in ['no', 'in_the_last_month']:
    participants = md[md['antibiotics'] == ab].index.values
    group_plotting = alp.loc[participants, 'Mean']
    box = alpha_axes[a].boxplot(group_plotting, positions=[x_ab[ab]], patch_artist=True, vert=True, showfliers=False, widths=0.3)
    vp = alpha_axes[a].violinplot(group_plotting, points=500, positions=[x_ab[ab]], showmeans=False, showextrema=False, showmedians=False, vert=True, side='low', widths=0.6)
    sc = alpha_axes[a].scatter(np.random.normal(x_ab[ab]+0.3, scale=0.04, size=len(group_plotting)), group_plotting, marker='o', color=colors_antibiotics[ab], alpha=0.05)
    for item in ['whiskers', 'medians', 'caps']: bi = plt.setp(box[item], color='k')
    for patch, color in zip(box['boxes'], [colors_antibiotics[ab]]):
      patch.set_facecolor(color)
      patch.set_alpha(0.4)
    for idx, b in enumerate(vp['bodies']):
      b.set_color(colors_antibiotics[ab])
      b.set_alpha(0.4)
  anov_p = round(stats.loc['antibiotics', 'Univariate p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string = 'Uni: F='+str(round(stats.loc['antibiotics', 'Univariate F'], 2))+', $p$='+str(anov_p)+'\n'
  anov_p = round(stats.loc['antibiotics', 'Diet p'], 3)
  if anov_p < 0.001: anov_p = '<0.001'
  string += 'Multi: F='+str(round(stats.loc['antibiotics', 'Diet F'], 2))+', $p$='+str(anov_p)
  tx = alpha_axes[a].text(0.96, 0.04, string, ha='right', va='bottom', transform=alpha_axes[a].transAxes, bbox=dict(boxstyle='round', facecolor='white', alpha=0.7))
  yt = plt.ylabel(alpha_metric_name[a], fontweight='bold')
  if a in [1, 3, 5]:
    xt = plt.xticks([1, 2], ['No', 'In the\nlast month'], rotation=90)
    
plotting_ax = [sens_with_ab, sens_no_ab]
perm_vals = ['All', 'No antibiotics']
vars_order = ['dsq23', 'dsq2', 'dsq8', 'dsq5', 'dsq15', 'dsq17', 'dsq21', 'dsq9', 'dsq20', 'dsq4', 'dsq14', 'HEFI', 'dsq13', 'dsq16', 'physical_mental_condition', 'dsq12', 'diet_richness_weekly', 'dsq7', 'dsq11', 'dsq18', 'dsq19', 'strict_diet', 'dsq10', 'dsq22', 'dsq6', 'ethnicity', 'gender', 'age', 'antibiotics', 'cur_msd_soc', 'cur_msd_mat', 'cur_gta', 'cur_ior', 'cur_gmn_mean', 'cur_pm25_mean']

rename = {'gender':'Gender', 'ethnicity':'Ethnicity', 'antibiotics':'Antibiotics', 'cur_msd_mat':'Current material deprivation', 'cur_msd_soc':'Current social deprivation', 'physical_mental_condition':'Physical/mental condition', 'age':'Age', 'diet_richness_weekly':'Diet variety score (weekly)', 'strict_diet':'Strict diet', 'dsq2':'Probiotics/prebiotics/supplements', 'dsq4':'Whole grains', 'dsq5':'Refined grains', 'dsq6':'Dairy milk', 'dsq7':'Dairy yoghurt', 'dsq8':'Dairy cheese', 'dsq9':'Non-dairy milk/yoghurt/cheese', 'dsq10':'Soda/sugary drinks', 'dsq11':'Fruit juices', 'dsq12':'Coffee or tea', 'dsq13':'Fruit', 'dsq14':'Vegetables', 'dsq15':'Beans/legumes', 'dsq16':'Red meat', 'dsq17':'Processed meat', 'dsq18':'Poultry', 'dsq19':'Fish/seafood', 'dsq20':'Eggs', 'dsq21':'Tofu/soy', 'dsq22':'Desserts/sweets', 'dsq23':'Salty snacks', 'HEFI':'HEFI', 'cur_gta':'Current GTA', 'cur_gmn_mean':'Current greenspace', 'cur_pm25_mean':'Current PM$_{2.5}$', 'cur_ior':'Current index of rurality'}

perm_stats = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)
perm_stats = perm_stats.loc[vars_order, :].sort_values(by='All R2', ascending=True)
vars_order = list(perm_stats.index.values)
vars_order.remove('age')
vars_order.remove('gender')
vars_order.remove('ethnicity')
vars_order.remove('physical_mental_condition')
vars_order.remove('antibiotics')
vars_order = vars_order+['physical_mental_condition', 'gender', 'ethnicity', 'age', 'antibiotics']

var_names = []
for var in vars_order:
  got_it = False
  for rn in rename:
    if var == rn:
      var_names.append(rename[rn])
      got_it = True

for a in range(len(plotting_ax)):
  for v in range(len(vars_order)):
    if a == 1 and vars_order[v] == 'antibiotics': continue
    r2, p = perm_stats.loc[vars_order[v], perm_vals[a]+' R2'], perm_stats.loc[vars_order[v], perm_vals[a]+' p']
    if p <= 0.05: bar_col = '#bb8fce'
    else: bar_col = 'w'
    ba = plotting_ax[a].barh(v, width=r2, height=0.8, color=bar_col, edgecolor='#bb8fce')

plt.sca(sens_with_ab)
yt = plt.yticks([v for v in range(len(vars_order))], var_names), plt.xlabel('PERMANOVA R$^{2}$'), plt.ylim([-0.5, 34.5]), plt.semilogx()

plt.sca(sens_no_ab)
yt = plt.yticks([v for v in range(len(vars_order))], []), plt.xlabel('PERMANOVA R$^{2}$'), plt.ylim([-0.5, 34.5]), plt.semilogx()

colors_r2_sig, names_r2_sig = ['#bb8fce', 'w'], ['$p$0.05', 'Not significant']
handles_r2_sig = [Line2D([0], [0], marker='s', color='w', label=names_r2_sig[r], markerfacecolor=colors_r2_sig[r], markeredgecolor='#bb8fce', markersize=12) for r in range(len(names_r2_sig))]
leg = sens_with_ab.legend(handles=handles_r2_sig, loc='lower right', bbox_to_anchor=(-0.1,1.01))

plt.savefig(folder+'figures/antibiotics_overall_plot.png', dpi=600, bbox_inches='tight')
```

## Uploading samples to ENA

Get list of which file was used for each participant:
```{python}
import pandas as pd
import os

ft = pd.read_csv(exports+'feature-table_w_tax.txt', index_col=0, header=1, sep='\t').drop('taxonomy', axis=1)
samples = list(ft.columns)
sample_redo = [s for s in samples if '-redo' in s]

ft_sums = ft.sum(axis=0)
drop = []
for s in sample_redo:
  redo_sum = ft_sums[s]
  if s.split('-')[0] in samples:
    original_sum = ft_sums[s.split('-')[0]]
    if redo_sum > original_sum:
      drop.append(s.split('-')[0])
    else:
      drop.append(s)
  else:
    continue

ft_reduced = ft.copy(deep=True).drop(drop, axis=1)

with open(exports+'best_samples_list.txt', 'w') as f:
  for sample in ft_reduced.columns:
    f.write(sample+'\n')
```

Make fastq sample file:
```{python}
#VULCAN
#cd SickKids_SfS
#mkdir samples_for_upload
import pandas as pd
import os
import hashlib

#best_samples_list.txt
#fastq2_template_1761314415065.tsv

template = pd.read_csv('fastq2_template_1761314415065.tsv', sep='\t', header=1, index_col=3)
best_samples = []

for row in open('best_samples_list.txt', 'r'):
  best_samples.append(row.replace('\n', ''))
  
all_fastq_r1 = [f for f in os.listdir('raw_data') if 'R1' in f]
all_fastq_dict = {}

for fq in all_fastq_r1:
  all_fastq_dict[fq.split('_')[0]] = [fq, fq.replace('_R1', '_R2')]
  
count = 0
for row in template.index.values:
  for samp in best_samples:
    if row in samp:
      template.loc[row, 'forward_file_name'] = all_fastq_dict[samp][0]
      template.loc[row, 'reverse_file_name'] = all_fastq_dict[samp][1]
      os.system('cp raw_data/'+all_fastq_dict[samp][0]+' samples_for_upload/')
      os.system('cp raw_data/'+all_fastq_dict[samp][1]+' samples_for_upload/')
      md5_fwd = hashlib.md5(open('raw_data/'+all_fastq_dict[samp][0],'rb').read()).hexdigest()
      md5_rev = hashlib.md5(open('raw_data/'+all_fastq_dict[samp][1],'rb').read()).hexdigest()
      template.loc[row, 'forward_file_md5'] = md5_fwd
      template.loc[row, 'reverse_file_md5'] = md5_rev
      print(count, row, samp)
      count += 1
      
template.to_csv('fastq2_template_1761314415065_mod.tsv')
      
```

## Consistency of microbiome

Initial idea of looking at beta diversity distances:
```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_distance.csv', index_col=0, header=0)

ages = list(md['age'].values)
#percentiles = [np.percentile(ages, 10), np.percentile(ages, 20), np.percentile(ages, 30), np.percentile(ages, 40), np.percentile(ages, 50), np.percentile(ages, 60), np.percentile(ages, 70), np.percentile(ages, 80), np.percentile(ages, 90)]
percentiles = [np.percentile(ages, 25), np.percentile(ages, 50), np.percentile(ages, 75)]

def adjacent_values(vals, q1, q3):
    upper_adjacent_value = q3 + (q3 - q1) * 1.5
    lower_adjacent_value = q1 - (q3 - q1) * 1.5
    return lower_adjacent_value, upper_adjacent_value

distances = []
for a in range(len(percentiles)+1):
  distances.append([])

for a in range(len(pca.index.values)):
  for b in range(len(pca.index.values)):
    if b > a:
      age1, age2 = md.loc[pca.index.values[a], 'age'], md.loc[pca.index.values[b], 'age']
      age_group1, age_group2 = -1, -1
      for p in range(len(percentiles)):
        if age1 <= percentiles[p]:
          age_group1 = p
          break
      for p in range(len(percentiles)):
        if age2 <= percentiles[p]:
          age_group2 = p
          break
      if age_group1 == -1: age_group1 = len(distances)-1
      if age_group2 == -1: age_group2 = len(distances)-1
      if age_group1 == age_group2:
        distances[age_group1].append(pca.loc[pca.index.values[a], pca.index.values[b]])

md_adults = pd.read_csv(folder_atpath+'FrailtyParticipants_metadata.csv', index_col=0, header=0)
pca_adults = pd.read_csv(folder_atpath+'phylo_rpca/distance-matrix.tsv', index_col=0, header=0, sep='\t')

md_adults.index = md_adults.index.map(str)
pca_adults.index = pca_adults.index.map(str)
pca_adults.columns = pca_adults.columns.map(str)

ages_adults = list(md_adults['AGE'].values)
percentiles_adults = [np.percentile(ages_adults, 25), np.percentile(ages_adults, 50), np.percentile(ages_adults, 75)]

for a in range(len(percentiles_adults)+1):
  distances.append([])
  
for a in range(len(pca_adults.index.values)):
  for b in range(len(pca_adults.index.values)):
    if b > a:
      if pca_adults.index.values[a] not in md_adults.index.values or pca_adults.index.values[b] not in md_adults.index.values: continue
      age1, age2 = md_adults.loc[pca_adults.index.values[a], 'AGE'], md_adults.loc[pca_adults.index.values[b], 'AGE']
      age_group1, age_group2 = -1, -1
      for p in range(len(percentiles_adults)):
        if age1 <= percentiles_adults[p]:
          age_group1 = p
          break
      for p in range(len(percentiles_adults)):
        if age2 <= percentiles_adults[p]:
          age_group2 = p
          break
      if age_group1 == -1: age_group1 = len(percentiles_adults)
      if age_group2 == -1: age_group2 = len(percentiles_adults)
      if age_group1 == age_group2:
        distances[age_group1+4].append(pca_adults.loc[pca_adults.index.values[a], pca_adults.index.values[b]])

plt.close()
plt.figure(figsize=(12,7))
ax = plt.subplot(111)

for d in range(len(distances)):
  sc = ax.scatter(np.random.normal(d, scale=0.1, size=len(distances[d])), distances[d], color='k', marker='o', alpha=0.005)
  violin = plt.violinplot(distances[d], positions=[d], showmeans=False, showmedians=False, showextrema=False)
  for pc in violin['bodies']:
    pc.set_facecolor('r')
    pc.set_edgecolor('r')
  quartile1, medians, quartile3 = np.percentile(distances[d], [25, 50, 75])
  whiskers = adjacent_values(medians, quartile1, quartile3)
  sc = ax.scatter(d, medians, marker='o', color='white', s=30, zorder=3)
  sc = ax.vlines(d, quartile1, quartile3, color='gray', linestyle='-', lw=5)
  sc = ax.vlines(d, min(whiskers), max(whiskers), color='gray', linestyle='-', lw=1)
  tx = ax.text(d, max(distances[d])+0.2, str(round(np.mean(distances[d]), 3)), ha='center', va='center',   bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8))

f_statistic, p_value = stats.f_oneway(distances[0], distances[1], distances[2], distances[3], distances[4], distances[5], distances[6], distances[7])
tukeys = stats.tukey_hsd(distances[0], distances[1], distances[2], distances[3], distances[4], distances[5], distances[6], distances[7])
print(tukeys)
#tx = ax.text(0.95, 0.98, r'ANOVA F='+str(round(f_statistic, 3))+', $p$<0.001\n'+"All Tukey's HSD $p$<0.001", ha='right', va='top',   bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8), transform=ax.transAxes)
tx = ax.text(0.95, 0.98, r'ANOVA F='+str(round(f_statistic, 3))+', $p$<0.001', ha='right', va='top',   bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8), transform=ax.transAxes)


xticknames =  []
for d in range(len(distances)):
  perc, e, cohort = percentiles, d, 'Spit for Science'
  if d > 3: 
    perc, e, cohort = percentiles_adults, d-4, 'Atlantic PATH'
  if e < len(perc):
    xticknames.append(cohort+'\n'+str(round(perc[e], 2)))
  else:
    xticknames.append(cohort+'\n>'+str(round(perc[-1], 2)))
    
print(xticknames)

xt = plt.xticks([a for a in range(len(xticknames))], xticknames)
yl = plt.ylabel('Phylogenetic-RPCA distance', fontweight='bold'), plt.xlabel('Age quartile (years)', fontweight='bold'), plt.ylim([-1.01, 7.01])

#plt.show()
plt.savefig(folder+'figures/beta_diversity_consistency_with_adults.png', dpi=600, bbox_inches='tight')
```

Look at participants of the same age/within one year of eachother and see if there is a pattern:
```{python}
# md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
# pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_distance.csv', index_col=0, header=0)
# md_adults = pd.read_csv(folder_atpath+'FrailtyParticipants_metadata.csv', index_col=0, header=0)
# pca_adults = pd.read_csv(folder_atpath+'phylo_rpca/distance-matrix.tsv', index_col=0, header=0, sep='\t')
# 
# md_adults.index = md_adults.index.map(str)
# pca_adults.index = pca_adults.index.map(str)
# pca_adults.columns = pca_adults.columns.map(str)
# 
# all_ages_kids, all_distances_kids = [], []
# 
# for a in range(len(pca.index.values)):
#   for b in range(len(pca.index.values)):
#     if b > a:
#       age1, age2 = md.loc[pca.index.values[a], 'age'], md.loc[pca.index.values[b], 'age']
#       if abs(age1-age2) <= 1:
#         all_ages_kids.append(np.mean([age1, age2]))
#         all_distances_kids.append(pca.loc[pca.index.values[a], pca.index.values[b]])
#         
# all_ages_adults, all_distances_adults = [], []
# 
# for a in range(len(pca_adults.index.values)):
#   for b in range(len(pca_adults.index.values)):
#     if b > a:
#       if pca_adults.index.values[a] not in md_adults.index.values or pca_adults.index.values[b] not in md_adults.index.values: continue
#       age1, age2 = md_adults.loc[pca_adults.index.values[a], 'AGE'], md_adults.loc[pca_adults.index.values[b], 'AGE']
#       if abs(age1-age2) <= 1:
#         all_ages_adults.append(np.mean([age1, age2]))
#         all_distances_adults.append(pca_adults.loc[pca_adults.index.values[a], pca_adults.index.values[b]])

plt.close()
fig = plt.figure(figsize=(14,7))
ax = plt.subplot(111)

sc = ax.scatter(all_ages_kids, all_distances_kids, marker='o', color='k', alpha=0.05)
sc = ax.scatter(all_ages_adults, all_distances_adults, marker='o', color='k', alpha=0.05)

fitted_poly = Polynomial.fit(all_ages_kids, all_distances_kids, deg=1)
unique_vals = sorted(list(set(all_ages_kids)))
w = fitted_poly(unique_vals)
li = ax.plot(unique_vals, w, color='r', linestyle='--', lw=3)
corr_kids, p_kids = spearmanr(all_ages_kids, all_distances_kids)
print(corr_kids, p_kids)

fitted_poly = Polynomial.fit(all_ages_adults, all_distances_adults, deg=1)
unique_vals = sorted(list(set(all_ages_adults)))
w = fitted_poly(unique_vals)
li = ax.plot(unique_vals, w, color='r', linestyle='--', lw=3)
corr_adults, p_adults = spearmanr(all_ages_adults, all_distances_adults)
print(corr_adults, p_adults)

tx = ax.text(0.98, 0.98, r"Children/adolescents: Spearman's R$^2$="+str(round(corr_kids, 3))+', $p$=0.001'+"\nAdults: Spearman's R$^2$="+str(round(corr_adults, 3))+', $p$='+str(round(p_adults, 3)), ha='right', va='top', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8), transform=ax.transAxes)

print(np.mean(all_distances_kids), np.mean(all_distances_adults))

f_statistic, p_value = stats.f_oneway(all_distances_kids,all_distances_adults)
print(f_statistic, p_value)

plt.xlabel('Mean age (years)', fontweight='bold')
plt.ylabel('Phylogenetic-RPCA distance', fontweight='bold')

plt.savefig(folder+'figures/beta_diversity_distances_within_one_year.png', dpi=600, bbox_inches='tight')

```

Rare ASVs:
```{python}
# ft_adults = pd.read_csv(folder_atpath+'exports/feature-table_min_2000.txt', index_col=0, header=0, sep='\t')
# ft_kids = pd.read_csv(folder+'files/feature-table_min2000_with_metadata.csv', index_col=0, header=0)
# md_kids = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
# md_adults = pd.read_csv(folder_atpath+'FrailtyParticipants_metadata.csv', index_col=0, header=0)
# 
# md_adults.index = md_adults.index.map(str)
# ft_adults.index = ft_adults.index.map(str)
# 
# keeping_adults = []
# for row in md_adults.index.values:
#   if row in ft_adults.columns:
#     keeping_adults.append(row)
#     
# ft_adults = ft_adults.loc[:, keeping_adults]
# md_adults = md_adults.loc[keeping_adults, :]
# 
# ft_adults = ft_adults.divide(ft_adults.sum(axis=0), axis=1).multiply(100)
# ft_kids = ft_kids.divide(ft_kids.sum(axis=0), axis=1).multiply(100)
# 
# prev_adults = ft_adults.copy(deep=True)
# prev_kids = ft_kids.copy(deep=True)
# prev_adults[prev_adults > 1] = 1
# prev_kids[prev_kids > 1] = 1
# 
# prev_adults['Prevalence'] = prev_adults.sum(axis=1)/prev_adults.shape[1]
# prev_kids['Prevalence'] = prev_kids.sum(axis=1)/prev_kids.shape[1]
# 
# prev_adults = prev_adults[prev_adults['Prevalence'] <= 0.1]
# prev_kids = prev_kids[prev_kids['Prevalence'] <= 0.1]
# 
# prev_adults = prev_adults.drop('Prevalence', axis=1)
# prev_kids = prev_kids.drop('Prevalence', axis=1)
# 
# sums_adults = prev_adults.sum(axis=0)
# sums_kids = prev_kids.sum(axis=0)
# 
# ft_adults = ft_adults.loc[prev_adults.index.values, :]
# ft_kids = ft_kids.loc[prev_kids.index.values, :]
# 
# sums_adults_relabun = ft_adults.sum(axis=0)
# sums_kids_relabun = ft_kids.sum(axis=0)
# 
# print(np.mean(sums_adults), np.mean(sums_kids))
# print(np.mean(sums_adults_relabun), np.mean(sums_kids_relabun))

# md = pd.read_csv(folder+'files/metadata_microbiome_participants.csv', index_col=0, header=0)
# pca = pd.read_csv(folder+'files/beta_diversity/phylo_rpca_distance.csv', index_col=0, header=0)
# md_adults = pd.read_csv(folder_atpath+'FrailtyParticipants_metadata.csv', index_col=0, header=0)
# pca_adults = pd.read_csv(folder_atpath+'phylo_rpca/distance-matrix.tsv', index_col=0, header=0, sep='\t')
# 
# md_adults.index = md_adults.index.map(str)
# pca_adults.index = pca_adults.index.map(str)
# pca_adults.columns = pca_adults.columns.map(str)
# 
# all_ages_kids, all_distances_kids = [], []
# 
# for a in range(len(pca.index.values)):
#   for b in range(len(pca.index.values)):
#     if b > a:
#       age1, age2 = md.loc[pca.index.values[a], 'age'], md.loc[pca.index.values[b], 'age']
#       if abs(age1-age2) <= 1:
#         all_ages_kids.append(np.mean([age1, age2]))
#         all_distances_kids.append(pca.loc[pca.index.values[a], pca.index.values[b]])
#         
# all_ages_adults, all_distances_adults = [], []
# 
# for a in range(len(pca_adults.index.values)):
#   for b in range(len(pca_adults.index.values)):
#     if b > a:
#       if pca_adults.index.values[a] not in md_adults.index.values or pca_adults.index.values[b] not in md_adults.index.values: continue
#       age1, age2 = md_adults.loc[pca_adults.index.values[a], 'AGE'], md_adults.loc[pca_adults.index.values[b], 'AGE']
#       if abs(age1-age2) <= 1:
#         all_ages_adults.append(np.mean([age1, age2]))
#         all_distances_adults.append(pca_adults.loc[pca_adults.index.values[a], pca_adults.index.values[b]])

plt.close()
fig = plt.figure(figsize=(15,15))
ax1 = plt.subplot2grid((3,4),(0,0))
ax2 = plt.subplot2grid((3,4),(0,1), colspan=3)
ax3 = plt.subplot2grid((3,4),(1,0))
ax4 = plt.subplot2grid((3,4),(1,1), colspan=3)
ax5 = plt.subplot2grid((3,4),(2,0))
ax6 = plt.subplot2grid((3,4),(2,1), colspan=3)

axes = [ax1, ax1, ax3, ax3, ax5, ax5]
values = [all_distances_kids, all_distances_adults, list(sums_kids.values), list(sums_adults.values), list(sums_kids_relabun.values), list(sums_adults_relabun.values)]
locs = [0, 1, 0, 1, 0, 1]

for v in range(len(values)):
  plt.sca(axes[v])
  sc = axes[v].scatter(np.random.normal(locs[v], scale=0.1, size=len(values[v])), values[v], marker='o', color='k', alpha=0.01)
  violin = plt.violinplot([values[v]], positions=[locs[v]], showmeans=False, showmedians=False, showextrema=False)
  for pc in violin['bodies']:
    pc.set_facecolor('r')
    pc.set_edgecolor('r')
  quartile1, medians, quartile3 = np.percentile(values[v], [25, 50, 75])
  whiskers = adjacent_values(medians, quartile1, quartile3)
  sc = axes[v].scatter(locs[v], medians, marker='o', color='white', s=30, zorder=3)
  sc = axes[v].vlines(locs[v], quartile1, quartile3, color='gray', linestyle='-', lw=5)
  sc = axes[v].vlines(locs[v], min(whiskers), max(whiskers), color='gray', linestyle='-', lw=1)
  tx = axes[v].text(locs[v], quartile3+quartile1+1, str(round(np.mean(values[v]), 3)), ha='center', va='bottom',   bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8))

plt.sca(ax1)
f_statistic, p_value = stats.f_oneway(all_distances_kids,all_distances_adults)
tx = ax1.text(0.98, 0.98, 'ANOVA F='+str(round(f_statistic, 2))+', $p$0.001', ha='right', va='top', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8), transform=ax1.transAxes)
yl = plt.ylabel('Phylogenetic-RPCA distance', fontweight='bold')
xt = plt.xticks([0, 1], ['Children/\nadolescents', 'Adults'])

plt.sca(ax3)
f_statistic, p_value = stats.f_oneway(sums_kids.values, sums_adults.values)
tx = ax3.text(0.98, 0.98, 'ANOVA F='+str(round(f_statistic, 2))+', $p$0.001', ha='right', va='top', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8), transform=ax3.transAxes)
yl = plt.ylabel('Number of rare ASVs\n(10% prevalence)', fontweight='bold')
xt = plt.xticks([0, 1], ['Children/\nadolescents', 'Adults'])

plt.sca(ax5)
f_statistic, p_value = stats.f_oneway(sums_kids_relabun.values, sums_adults_relabun.values)
tx = ax5.text(0.98, 0.98, 'ANOVA F='+str(round(f_statistic, 2))+', $p$0.001', ha='right', va='top', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8), transform=ax5.transAxes)
yl = plt.ylabel('Relative abundance (%) of rare ASVs\n(10% prevalence)', fontweight='bold')
xt = plt.xticks([0, 1], ['Children/\nadolescents', 'Adults'])

axes = [ax2, ax4, ax6]
values = [[all_distances_kids, all_distances_adults], [list(sums_kids.values), list(sums_adults.values)], [list(sums_kids_relabun.values), list(sums_adults_relabun.values)]]
ages = [[all_ages_kids, all_ages_adults], [md_kids.loc[sums_kids.index.values, :]['age'].values, md_adults.loc[sums_adults.index.values, :]['AGE'].values], [md_kids.loc[sums_kids.index.values, :]['age'].values, md_adults.loc[sums_adults.index.values, :]['AGE'].values]]

for v in range(len(values)):
  correlations, pvals = [], []
  for m in range(len(ages[v])):
    sc = axes[v].scatter(ages[v][m], values[v][m], marker='o', color='k', alpha=0.01)
    fitted_poly = Polynomial.fit(ages[v][m], values[v][m], deg=1)
    unique_vals = sorted(list(set(ages[v][m])))
    w = fitted_poly(unique_vals)
    li = axes[v].plot(unique_vals, w, color='r', linestyle='--', lw=3)
    corr, p = spearmanr(ages[v][m], values[v][m])
    correlations.append(corr), pvals.append(p)
  tx = axes[v].text(0.98, 0.98, r"Children/adolescents: Spearman's R$^2$="+str(round(correlations[0], 3))+', $p$0.001'+"\nAdults: Spearman's R$^2$="+str(round(correlations[1], 3))+', $p$<0.001', ha='right', va='top', bbox=dict(boxstyle='round,pad=0.1', facecolor='white', alpha=0.8), transform=axes[v].transAxes)
  
plt.sca(ax2)
yt = plt.yticks([])
xt = plt.xlabel('Mean age (years)', fontweight='bold')

plt.sca(ax4)
yt = plt.yticks([])
xt = plt.xlabel('Age (years)', fontweight='bold')

plt.sca(ax6)
yt = plt.yticks([])
xt = plt.xlabel('Age (years)', fontweight='bold')

ti = ax1.set_title('A', loc='left', fontweight='bold')
ti = ax2.set_title('B', loc='left', fontweight='bold')
ti = ax3.set_title('C', loc='left', fontweight='bold')
ti = ax4.set_title('D', loc='left', fontweight='bold')
ti = ax5.set_title('E', loc='left', fontweight='bold')
ti = ax6.set_title('F', loc='left', fontweight='bold')

plt.savefig(folder+'figures/children_adults_consistency.png', dpi=600, bbox_inches='tight')
```

## Environmental variables

```{python}
env_variables = ['cur_gta', 'birth_gta', 'sch_gta', 'cur_rural', 'birth_rural', 'sch_rural', 'cur_gmn_max', 'cur_gmn_mean', 'cur_amn_max', 'cur_amn_mean', 'cur_pm25_mean', 'cur_omarg_hh' ,'cur_omarg_mat' , 'cur_omarg_labour', 'cur_omarg_race', 'birth_gmn_max', 'birth_gmn_mean', 'birth_amn_max', 'birth_amn_mean', 'birth_pm25_mean', 'birth_msd_mat', 'birth_msd_soc', 'birth_omarg_hh', 'birth_omarg_mat', 'birth_omarg_labour', 'birth_omarg_race', 'utero_gmn_max', 'utero_gmn_mean', 'utero_amn_max', 'utero_amn_mean', 'utero_pm25_mean', 'utero_msd_mat', 'utero_msd_soc', 'utero_omarg_hh', 'utero_omarg_mat', 'utero_omarg_labour', 'utero_omarg_race', 'sch_gmn_max', 'sch_gmn_mean', 'sch_amn_max', 'sch_amn_mean', 'sch_pm25_mean', 'sch_msd_mat', 'sch_msd_soc', 'sch_omarg_hh', 'sch_omarg_mat', 'sch_omarg_labour', 'sch_omarg_race', 'cur_ior', 'sch_ior', 'birth_ior', 'utero_ior', 'cur_msd_mat', 'cur_msd_soc', 'cur_no2_mean']

env_variables = ['gta', 'rural', 'ior', 'gmn_max', 'amn_max', 'amn_mean', 'no2_mean', 'pm25_mean', 'omarg_hh', 'omarg_mat', 'omarg_labour', 'omarg_race', 'msd_mat', 'msd_soc']
times = ['cur', 'birth', 'utero', 'sch']
titles = ['Current', 'Birth', 'Utero', 'School']
env_rename = ['GTA (T/F)', 'Rural (T/F)', 'Index of Rurality', 'Greenspace - Growing Season Max', 'Greenspace - Annual Max of means', 'Greenspace - Annual Mean of means ', 'NO$_{2}$ Mean', 'PM2.5 Mean', 'ON-MARG - Households & Dwellings', 'ON-MARG Material Deprivation', 'ON-MARG - Age and Labour Force', 'ON-MARG Racialized and Newcomer populations', 'Material Deprivation', 'Social Deprivation']

fig = plt.figure(figsize=(12,8))
axes = [plt.subplot(141), plt.subplot(142), plt.subplot(143), plt.subplot(144)]

for a in range(len(env_variables)):
  for b in range(len(times)):
    try:
      stats_df = pd.read_csv(folder+'files/beta_stats/permanova_univariate_'+times[b]+'_'+env_variables[a]+'.csv', index_col=0, header=0)
      pval, r2 = stats_df.loc['md_red[, variable]', 'Pr(>F)'], stats_df.loc['md_red[, variable]', 'R2']
      if pval <= 0.05: bar_col = '#008B90'
      else: bar_col = 'w'
      ba = axes[b].barh(a, width=r2, height=0.8, color=bar_col, edgecolor='#008B90')
      #ba = ax_permanova_1.barh(l+0.45, width=r2, height=0.4, color=bar_col, edgecolor='#008B90')
    except:
      tx = axes[b].text(0, a, 'NA', ha='left', va='center')

for b in range(len(axes)):
  plt.sca(axes[b])
  if b == 0:
    yt = plt.yticks([a for a in range(len(env_rename))], env_rename)
  else:
    yt = plt.yticks([a for a in range(len(env_rename))], [])
  xt = plt.xlabel ('Contribution to variation (R$^{2}$)')
  ti = plt.title(titles[b], fontweight='bold')
  li = plt.ylim([-0.5, len(env_rename)-0.5])
  xl = plt.xlim([0, 0.0065])

plt.savefig(folder+'figures/environmental_contribution_variation.png', dpi=600, bbox_inches='tight')
```

## Marginalisation and environmental variables contribution to variation

```{python}
md = pd.read_csv(folder+'files/metadata_microbiome_participants_s2pheno.csv', index_col=0, header=0)
all_metrics = ["gender", "age", "ethnicity", "physical_mental_condition", "cur_msd_soc", "cur_msd_mat", "houseincome", "parent2", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "cur_omarg_hh", "cur_omarg_mat", "cur_omarg_labour", "cur_omarg_race", "sch_msd_soc", "sch_msd_mat", "sch_gta", "sch_ior", "sch_gmn_mean", "sch_pm25_mean", "utero_msd_soc", "utero_msd_mat", "utero_gta", "utero_ior", "utero_gmn_mean", "utero_pm25_mean"]
metrics1 = ["cur_msd_soc", "cur_msd_mat", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean"]
metrics2 = ["cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "cur_omarg_hh", "cur_omarg_mat", "cur_omarg_labour", "cur_omarg_race"]
metrics3 = ["cur_msd_soc", "cur_msd_mat", "cur_gta", "cur_ior", "cur_gmn_mean", "cur_pm25_mean", "sch_msd_soc", "sch_msd_mat", "sch_gta", "sch_ior", "sch_gmn_mean", "sch_pm25_mean", "utero_msd_soc", "utero_msd_mat", "utero_gta", "utero_ior", "utero_gmn_mean", "utero_pm25_mean"]
# metrics, save_name, stats_name, h, da_name = metrics1, 'marg_env_permanova_correlation.png', 'Environment', 10, 'maaslin3_env_marg_summary.csv'
# metrics, save_name, stats_name, h, da_name = metrics2, 'marg_env_omarg_permanova_correlation.png', 'Environment OMARG', 14, 'maaslin3_env_omarg_summary.csv'
metrics, save_name, stats_name, h, da_name = metrics3, 'marg_env_all_permanova_correlation.png', 'Environment all', 18, 'maaslin3_env_all_summary.csv'
permanova = pd.read_csv(folder+'files/beta_stats/permanova_summary.csv', index_col=0, header=0)

rename_vars = {'gender':'Gender', 'age':'Age', 'ethnicity':'Ethnicity', 'physical_mental_condition':'Diagnosed condition', 'msd_soc':'social deprivation', 'msd_mat':'material deprivation', 'houseincome':'Household income', 'parent2':'Second parent/caregiver', 'gta':'GTA', 'gmn_mean':'greenspace', 'pm25_mean':'PM$_{2.5}$', 'omarg_hh':'ON-Marg household & dwellings', 'omarg_mat':'ON-Marg material resources', 'omarg_labour':'OM-Marg age & labour', 'omarg_race':'ON-Marg racialised & newcomer populations', 'cur':'Current', 'sch':'School', 'utero':'In-utero', 'ior':'index of rurality'}

for metric in all_metrics:
  if 'cur' in metric or 'sch' in metric or 'utero' in metric:
    tm = metric.split('_', 1)
    if 'omarg' in metric:
      rename_vars[metric] = rename_vars[tm[1]]
    else:
      rename_vars[metric] = rename_vars[tm[0]]+' '+rename_vars[tm[1]]
      #rename_vars[metric] = rename_vars[tm[1]][0].capitalize()+rename_vars[tm[1]][1:]

permanova_red = permanova.loc[metrics, :]
permanova_red = permanova_red.sort_values(by='Univariate R2', ascending=True)

fig = plt.figure(figsize=(20,h))
ax_permanova = plt.subplot2grid((20,19),(0,0), colspan=3, rowspan=8)
ax_correlations_beta = plt.subplot2grid((20,19),(0,3), colspan=3, rowspan=8)
ax_alpha_stats = plt.subplot2grid((20,19),(0,6), colspan=3, rowspan=8)
ax_correlations_alpha = plt.subplot2grid((20,19),(0,9), colspan=6, rowspan=8)
ax_da = plt.subplot2grid((20,19),(11,0), colspan=15, rowspan=11)
# ax_da = plt.subplot2grid((20,19),(12,0), colspan=15, rowspan=11)

plt.sca(ax_permanova)

labels = []
for l in range(len(permanova_red.index.values)):
  label = permanova_red.index.values[l]
  r2, p = permanova_red.loc[label, 'Univariate R2'], permanova_red.loc[label, 'Univariate p']
  if p <= 0.05: bar_col = '#008B90'
  else: bar_col = 'w'
  ba = ax_permanova.barh(l+0.45, width=r2, height=0.4, color=bar_col, edgecolor='#008B90')
  if r2 >= 0.004: tx = ax_permanova.text(r2/2, l+0.45, str(round(r2, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova.text(r2+0.0001, l+0.45, str(round(r2, 4)), color='k', ha='left', va='center')
  
  r2_mul, p_mul = permanova_red.loc[label, stats_name+' R2'], permanova_red.loc[label, stats_name+' p']
  if p_mul <= 0.05: bar_col_mul = '#bb8fce'
  else: bar_col_mul = 'w'
  ba = ax_permanova.barh(l, width=r2_mul, height=0.4, color=bar_col_mul, edgecolor='#bb8fce')
  if r2_mul >= 0.004: tx = ax_permanova.text(r2_mul/2, l, str(round(r2_mul, 4)), color='w', ha='center', va='center')
  else: tx = ax_permanova.text(r2_mul+0.0001, l, str(round(r2_mul, 4)), color='k', ha='left', va='center')
  
  new_label = label
  for orig in rename_vars:
    if label == orig:
      new_label = new_label.replace(orig, rename_vars[orig])
  labels.append(new_label)

yl = plt.yticks([x+0.25 for x in range(permanova_red.shape[0])], labels), plt.ylim([-0.25, permanova_red.shape[0]-0.25])
ti = plt.title('A', fontweight='bold', loc='left'), plt.xlabel('PERMANOVA R$^{2}$', fontweight='bold'), plt.title('Contribution to\nvariation', fontweight='bold')

colors_r2, names_r2 = ['#008B90', '#bb8fce'], ['Univariate', 'Multivariate']
handles_r2 = [Line2D([0], [0], marker='s', color='w', label=names_r2[r], markerfacecolor=colors_r2[r], markersize=12) for r in range(len(names_r2))]
colors_r2_sig, names_r2_sig = ['k', 'w'], ['PERMANOVA $p$0.05', 'Not significant']
handles_r2_sig = [Line2D([0], [0], marker='s', color='w', label=names_r2_sig[r], markerfacecolor=colors_r2_sig[r], markeredgecolor='k', markersize=12) for r in range(len(names_r2_sig))]
leg = ax_permanova.legend(handles=handles_r2+handles_r2_sig, loc='upper right', bbox_to_anchor=(-0.11,0))

alpha_metrics = ['faith_pd', 'simpson_e', 'simpson']#['chao1', 'observed_otus', 'faith_pd', 'simpson_e', 'simpson', 'shannon']
alpha_metrics = ['chao1', 'observed_otus', 'faith_pd', 'simpson_e', 'simpson', 'shannon']
for r in range(len(permanova_red.index.values)):
  row = permanova_red.index.values[r]
  this_alpha = []
  this_alpha_2 = []
  for metric in alpha_metrics:
    alpha_stats = pd.read_csv(folder+'files/alpha_stats/'+metric+'_summary.csv', index_col=0, header=0)
    this_alpha.append(alpha_stats.loc[row, 'Univariate p'])
    this_alpha_2.append(alpha_stats.loc[row, stats_name+' p'])
  this_alpha = ['#008B90' if a <= 0.05 else 'w' for a in this_alpha]
  this_alpha_2 = ['#bb8fce' if a <= 0.05 else 'w' for a in this_alpha_2]
  for a in [0, 1, 2, 3, 4, 5]:
    pl = ax_alpha_stats.fill([a, a, a+1], [r, r+1, r+1], color=this_alpha[a], edgecolor='k')
    pl = ax_alpha_stats.fill([a, a+1, a+1], [r, r, r+1], color=this_alpha_2[a], edgecolor='k')

plt.sca(ax_alpha_stats)
yl = plt.yticks([]), plt.xticks([0.5, 1.5, 2.5, 3.5, 4.5, 5.5], ["Ch.", "Obs.", "FPD", "SE", "SI", "Sh."]), plt.xlim([0, 6]), plt.ylim([0, permanova_red.shape[0]])
ti = plt.title('C', fontweight='bold', loc='left'), plt.title('Alpha div.\nstats', fontweight='bold')

for r in range(len(permanova_red.index.values)):
  #if r > 1: continue
  #if permanova_red.index.values[r] == 'HEFI': continue
  md_var = md[md[permanova_red.index.values[r]].notnull()]
  md_var = md_var.loc[[sam for sam in md_var.index.values if sam in pca.index.values], :]
  #all_xvals, yvals = [[], [], [], [], [], [], ], []
  this_group_pc1, this_group_pc2, this_group_pc3 = pca.loc[md_var.index.values, 'PC1'], pca.loc[md_var.index.values, 'PC2'], pca.loc[md_var.index.values, 'PC3']
  all_plotting = [this_group_pc1, this_group_pc2, this_group_pc3]
  for m in range(len(alpha_metrics)):
    alpha = pd.read_csv(folder+'files/alpha_diversity/alpha_'+alpha_metrics[m]+'.csv', index_col=0, header=0).loc[md_var.index.values, 'Mean']
    all_plotting.append(alpha)
  correlations, pvals = [], []
  xvals = md_var.loc[:, permanova_red.index.values[r]].values
  for plot in all_plotting:
    corr, p = spearmanr(xvals, plot.values)
    correlations.append(corr)
    pvals.append(p)
  m = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=-0.2, vmax=0.2), cmap='RdBu_r')
  m2 = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=0, vmax=0.2), cmap='YlGn')
  correlations_color = [m.to_rgba(corr) for corr in correlations]
  correlations_color_2 = [m2.to_rgba(abs(corr)) for corr in correlations]
  left = [a for a in range(len(correlations))]
  for l in range(len(left)):
    if l > 2: left[l] += 0.5
  ba = ax_correlations_beta.barh([r for a in range(len(correlations))][:3], width=[1 for a in range(len(correlations))][:3], left=left[:3], height=1, color=correlations_color_2[:3], edgecolor='k')
  ba = ax_correlations_alpha.barh([r for a in range(len(correlations))][3:], width=[1 for a in range(len(correlations))][3:], left=left[3:], height=1, color=correlations_color[3:], edgecolor='k')
  for c in range(len(correlations)):
    if abs(correlations[c]) > 0.1: fc = 'w'
    else: fc = 'k'
    if c < 3:
      tx = ax_correlations_beta.text(left[c]+0.5, r, str(round(correlations[c], 3)), color=fc, ha='center', va='center')
    else:
      tx = ax_correlations_alpha.text(left[c]+0.5, r, str(round(correlations[c], 3)), color=fc, ha='center', va='center')

plt.sca(ax_correlations_beta)
xt = plt.xticks([l+0.5 for l in left][:3], ['PC1 ('+str(round(prop_explain[0]*100, 2))+'%)', 'PC2 ('+str(round(prop_explain[1]*100, 2))+'%)', 'PC3 ('+str(round(prop_explain[2]*100, 2))+'%)'], rotation=90), plt.ylim([-0.5, permanova_red.shape[0]-0.5]), plt.xlim([left[0], left[2]+1]), plt.yticks([])
ti = plt.title('B', loc='left', fontweight='bold'), plt.title("Spearman's\ncorrelations with\nbeta diversity", fontweight='bold')

plt.sca(ax_correlations_alpha)
xt = plt.xticks([l+0.5 for l in left][3:], ['Chao 1 richness', 'Number of ASVs', "Faith's PD", "Simpson's evenness", "Simpson's index", "Shannon diversity"], rotation=90), plt.ylim([-0.5, permanova_red.shape[0]-0.5]), plt.xlim([left[3], left[-1]+1]), plt.yticks([])
ti = plt.title('D', loc='left', fontweight='bold'), plt.title("Spearman's correlations with alpha diversity", fontweight='bold')

da_df = pd.read_csv(folder+'differential_abundance/'+da_name, index_col=0, header=0)
coef_only = da_df.loc[:, [m+' coef' for m in metrics]]
coef_only['Mean'] = coef_only.mean(axis=1)
coef_only = coef_only.sort_values(by=['Mean'], ascending=True)
da_df = da_df.loc[coef_only.index.values, :]
pval_only = da_df.loc[coef_only.index.values, [m+' qval' for m in metrics]]

da_df = da_df.transpose()
coef_only = coef_only.transpose()
pval_only = pval_only.transpose()

rename_genus = {}
for col in da_df.columns:
  if 'g__' in col:
    genus = col.replace('g__', '')
    if '_' in genus:
      rename_genus[col] = genus.replace('_', ' ')
    else:
      rename_genus[col] = '$'+genus+'$'
  else:
    rename_genus[col] = col.split('__')[0]+'__'+col.split('__')[1].replace('_', ' ')

ax_da.pcolor(da_df.loc[[m+' coef' for m in metrics], :], edgecolor='k', cmap='RdBu_r', vmin=-0.5, vmax=0.5)
plt.sca(ax_da)
yt = plt.yticks([a+0.5 for a in range(len(metrics))], [rename_vars[m] for m in metrics])
xt = plt.xticks([b+0.5 for b in range(len(da_df.columns))], [rename_genus[g] for g in da_df.columns], rotation=90)
for r in range(len(metrics)):
  for c in range(len(da_df.columns)):
    num, qval = coef_only.iloc[r, c], pval_only.iloc[r, c]
    if abs(num) > 0.25: color='w'
    else: color='k'
    if qval <= 0.1:
      tx = ax_da.text(c+0.5, r+0.5, str(round(num, 2)), color=color, fontweight='bold', ha='center', va='center')
    else:
      tx = ax_da.text(c+0.5, r+0.5, str(round(num, 2)), color=color, ha='center', va='center', fontsize=8)

ti = plt.title('E', loc='left', fontweight='bold'), plt.title("MaAsLin 3 coefficients for significantly differentially abundant genera", fontweight='bold')

plt.savefig(folder+'figures/'+save_name, dpi=600, bbox_inches='tight')
plt.close()
```

## Genotyping and association of genetic variants with oral microbiome

```{python}
files = ['candidateLoci_withMissing_EAS.txt', 'candidateLoci_withMissing_EUR.txt', 'candidateLoci_withMissing_SAS.txt']
files_pcs = ['EAS_micro.pcs', 'EUR_micro.pcs', 'SAS_micro.pcs']
md = pd.read_csv(folder+'files/metadata_microbiome_participants_s2pheno.csv', index_col=0, header=0)

for f in range(len(files)):
  fi = files[f]
  df = pd.read_csv(folder+'genotyping/'+fi, index_col=2, header=0, sep='\t').drop(['CHROM', 'POS', 'REF', 'ALT'], axis=1).transpose()
  for col in df.columns:
    for row in df.index.values:
      try:
        df.loc[row, col] = float(df.loc[row, col])
        df.loc[row, col+'_rounded'] = round(df.loc[row, col])
      except:
        df.loc[row, col] = ''
        df.loc[row, col+'_rounded'] = ''
  if files_pcs[f] != '':
    pcs = pd.read_csv(folder+'genotyping/'+files_pcs[f], index_col=0, header=None, sep='\t').drop(1, axis=1)
    rename = {}
    count = 1
    for col in pcs.columns:
      rename[col] = 'PC'+str(count)
      count += 1
    pcs = pcs.rename(columns=rename)
    for col in pcs.columns:
      df[col] = pcs.loc[df.index.values, col].values
  for col in ['family_id', 'gender', 'age', 'physical_mental_condition']:
    df[col] = md.loc[df.index.values, col].values
  df.to_csv(folder+'genotyping/'+fi.replace('.txt', '.csv'))

```

Vulcan:
```{python}
#vulcan
#conda activate r-phyloseq
#cd SickKids_SfS/analysis_2025
library(vegan)

#EAS
dm = read.csv("files/beta_diversity/phylo_rpca_distance.csv")
dm_df = as.data.frame(dm)
rownames(dm_df) = dm_df[,1]
dm_df = dm_df[,2:4813]

md = read.csv('files/candidateLoci_withMissing_EAS.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

eas_variables = c("rs13129697_rounded", "rs3749751_rounded", "rs2519093_rounded", "rs12260868_rounded")
variables = eas_variables

md$gender = as.character(md$gender)
md$family_id = as.character(md$family_id)

for (v in 1:length(variables)) {
  print(variables[v])
  variable = variables[v]
  # md[,variables[v]] = as.character(md[,variables[v]])
  md_red = md[!is.na(md[,variables[v]]),]
  dm_df_red = dm_df[rownames(md_red), rownames(md_red)]
  this_permanova <- adonis2(dm_df_red ~ md_red[,variable] + md_red$PC1 + md_red$PC2 + md_red$PC3 + md_red$PC4 + md_red$gender + md_red$age + md_red$physical_mental_condition, dm_df_red, parallel=48, by="margin", permutations=999, na.action=na.exclude, strata=md_red$family_id)
  print(this_permanova)
  write.csv(this_permanova, paste("beta_stats_genotyping/permanova_EAS_", variable, "_continuous.csv", sep=""))
}

# permanova_basic_added_margin <- adonis2(dm_df ~ md$rs13129697_rounded * md$rs3749751_rounded * md$rs2519093_rounded * md$rs12260868_rounded, data=dm_df, parallel=48, by="terms", permutations=999, na.action=na.exclude)
# permanova_basic_added_margin
# write.csv(permanova_basic_added_margin, 'beta_stats_genotyping/permanova_EAS_interaction.csv')

#SAS
dm = read.csv("files/beta_diversity/phylo_rpca_distance.csv")
dm_df = as.data.frame(dm)
rownames(dm_df) = dm_df[,1]
dm_df = dm_df[,2:4813]

md = read.csv('files/candidateLoci_withMissing_SAS.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

md$gender = as.character(md$gender)
md$family_id = as.character(md$family_id)

sas_variables = c("rs13129697_rounded", "rs5743618_rounded", "rs3749751_rounded", "rs2519093_rounded", "rs12260868_rounded", "rs17559023_rounded", "rs601338_rounded")
variables = sas_variables

for (v in 1:length(variables)) {
  print(variables[v])
  variable = variables[v]
  # md[,variables[v]] = as.character(md[,variables[v]])
  md_red = md[!is.na(md[,variables[v]]),]
  dm_df_red = dm_df[rownames(md_red), rownames(md_red)]
  this_permanova <- adonis2(dm_df_red ~ md_red[,variable] + md_red$PC1 + md_red$PC2 + md_red$PC3 + md_red$PC4 + md_red$gender + md_red$age + md_red$physical_mental_condition, dm_df_red, parallel=48, by="margin", permutations=999, na.action=na.exclude, strata=md_red$family_id)
  print(this_permanova)
  write.csv(this_permanova, paste("beta_stats_genotyping/permanova_SAS_", variable, "_continuous.csv", sep=""))
}

# permanova_basic_added_margin <- adonis2(dm_df ~ md$rs13129697_rounded * md$rs5743618_rounded * md$rs3749751_rounded * md$rs2519093_rounded * md$rs12260868_rounded * md$rs17559023_rounded * md$rs601338_rounded, data=dm_df, parallel=48, by="terms", permutations=999, na.action=na.exclude)
# permanova_basic_added_margin
# write.csv(permanova_basic_added_margin, 'beta_stats_genotyping/permanova_SAS_interaction.csv')

#EUR
dm = read.csv("files/beta_diversity/phylo_rpca_distance.csv")
dm_df = as.data.frame(dm)
rownames(dm_df) = dm_df[,1]
dm_df = dm_df[,2:4813]

md = read.csv('files/candidateLoci_withMissing_EUR.csv')
rownames(md) = md[,1]

new_list <- c()
for (i in 1:length(rownames(md))) {
  if (rownames(md)[i] %in% rownames(dm_df)) {
    new_list = c(rownames(md)[i], new_list)
  }
}

dm_df = dm_df[new_list, new_list]
md = md[new_list,]

md$gender = as.character(md$gender)
md$family_id = as.character(md$family_id)

eur_variables = c("rs13129697_rounded", "rs5743618_rounded", "rs3749751_rounded", "rs2519093_rounded", "rs12260868_rounded", "rs17559023_rounded", "rs601338_rounded")
variables = eur_variables

for (v in 1:length(variables)) {
  print(variables[v])
  variable = variables[v]
  # md[,variables[v]] = as.character(md[,variables[v]])
  md_red = md[!is.na(md[,variables[v]]),]
  dm_df_red = dm_df[rownames(md_red), rownames(md_red)]
  this_permanova <- adonis2(dm_df_red ~ md_red[,variable] + md_red$PC1 + md_red$PC2 + md_red$PC3 + md_red$PC4 + md_red$gender + md_red$age + md_red$physical_mental_condition, dm_df_red, parallel=48, by="margin", permutations=999, na.action=na.exclude, strata=md_red$family_id)
  print(this_permanova)
  write.csv(this_permanova, paste("beta_stats_genotyping/permanova_EUR_", variable, "_continuous.csv", sep=""))
}

# permanova_basic_added_margin <- adonis2(dm_df ~ md$rs13129697_rounded * md$rs5743618_rounded * md$rs3749751_rounded * md$rs2519093_rounded * md$rs12260868_rounded * md$rs17559023_rounded * md$rs601338_rounded, data=dm_df, parallel=48, by="terms", permutations=999, na.action=na.exclude)
# permanova_basic_added_margin
# write.csv(permanova_basic_added_margin, 'beta_stats_genotyping/permanova_EUR_interaction.csv')
```

Prepare files for stats:
```{python}
metrics = ['chao1','faith_pd','observed_otus','shannon','simpson','simpson_e']
files = ['candidateLoci_withMissing_EAS.csv', 'candidateLoci_withMissing_EUR.csv', 'candidateLoci_withMissing_SAS.csv']

for metric in metrics:
  alpha = pd.read_csv(folder+'files/alpha_diversity/alpha_'+metric+'.csv', index_col=0, header=0).loc[:, ['Mean']].rename(columns={'Mean':'Diversity'})
  for f in range(len(files)):
    fi = files[f]
    md = pd.read_csv(folder+'genotyping/'+fi, index_col=0, header=0)
    alpha_red = alpha.loc[md.index.values, :]
    md['Diversity'] = alpha.loc[md.index.values, 'Diversity']
    md.to_csv(folder+'intermediate/stats_'+metric+'_'+fi)

```

R stats tests:
```{R}
metrics = c('chao1','faith_pd','observed_otus','shannon','simpson','simpson_e')
variables_all = c("rs13129697_rounded", "rs5743618_rounded", "rs3749751_rounded", "rs2519093_rounded", "rs12260868_rounded", "rs17559023_rounded", "rs601338_rounded")
variables_eas = c("rs13129697_rounded", "rs3749751_rounded", "rs2519093_rounded", "rs12260868_rounded")
ancestry = c("SAS", "EUR", "EAS")

for (i in 1:length(metrics)) {
  print(metrics[i])
  for (j in 1:length(ancestry)) {
    print(ancestry[j])
    table = read.csv(paste(py$folder, "intermediate/stats_", metrics[i], "_candidateLoci_withMissing_", ancestry[j], ".csv", sep=""))
    if (ancestry[j] == "EAS") {
      variables = variables_eas
    } else {
      variables = variables_all
    }
    table$gender = as.character(table$gender)
    table$family_id = as.character(table$family_id)
    for (v in 1:length(variables)) {
      variable = variables[v]
      print(variable)
      table_clean = na.omit(table[,c(variable, 'PC1', 'PC2', 'PC3', 'PC4', 'gender', 'age', 'physical_mental_condition', 'family_id', 'Diversity')])
      # table[,variables[v]] = as.character(table[,variables[v]])
      formula <- as.formula(paste("Diversity ~", variable, "+ PC1 + PC2 + PC3 + PC4 + gender + age + physical_mental_condition + Error(family_id)"))
      mod = aov(formula, data=table_clean, na.action=na.exclude)
      tidy_aov_df <- tidy(mod)
    write.csv(tidy_aov_df, file=paste(py$folder, "alpha_stats_genotyping/", metrics[i], "_", ancestry[j], "_", variable, "_continuous.csv", sep=""), row.names = TRUE)
    }
  }
}
```

Collate beta diversity:
```{python}
loci = ["rs13129697", "rs5743618", "rs3749751", "rs2519093", "rs12260868", "rs17559023", "rs601338"]
ancestry = ['EAS', 'SAS', 'EUR']
cat_cont = ['continuous']

first = True

for cat in cat_cont:
  for anc in ancestry:
    for lo in loci:
      try:
        fi = pd.read_csv(folder+'beta_stats_genotyping/permanova_'+anc+'_'+lo+'_rounded_'+cat+'.csv', index_col=0, header=0)
      except:
        continue
      r2, p = fi.loc['md_red[, variable]', 'R2'], fi.loc['md_red[, variable]', 'Pr(>F)']
      if first:
        df = pd.DataFrame([[r2, p]], index=[lo], columns=[anc+' R2 '+cat, anc+' p '+cat])
        first = False
      else:
        df.loc[lo, [anc+' R2 '+cat, anc+' p '+cat]] = [r2, p]

df.to_csv(folder+'beta_stats_genotyping/beta_overall_summary.csv') 
```

Collate alpha diversity:
```{python}
loci = ["rs13129697", "rs5743618", "rs3749751", "rs2519093", "rs12260868", "rs17559023", "rs601338"]
ancestry = ['EAS', 'SAS', 'EUR']
cat_cont = ['continuous']
metrics = ['chao1','faith_pd','observed_otus','shannon','simpson','simpson_e']

first = True

for metric in metrics:
  for cat in cat_cont:
    for anc in ancestry:
      for lo in loci:
        try:
          fi = pd.read_csv(folder+'alpha_stats_genotyping/'+metric+'_'+anc+'_'+lo+'_rounded_'+cat+'.csv', index_col=0, header=0)
          fi = fi[fi['stratum'] == 'family_id']
          fi = fi.set_index('term')
        except:
          continue
        f, p = fi.loc[lo+'_rounded', 'statistic'], fi.loc[lo+'_rounded', 'p.value']
        if first:
          df = pd.DataFrame([[f, p]], index=[lo], columns=[metric+' '+anc+' F '+cat, metric+' '+anc+' p '+cat])
          first = False
        else:
          df.loc[lo, [metric+' '+anc+' F '+cat, metric+' '+anc+' p '+cat]] = [f, p]

df = df.loc[loci, :]
df.to_csv(folder+'alpha_stats_genotyping/alpha_overall_summary.csv') 
```

Differential abundance tests:
```{R, eval=FALSE}
#conda activate r-4.4.1 # - Maaslin3
library(maaslin3)

ft = read.csv("files/feature_table_genus.csv", header= TRUE, row.names = 1, stringsAsFactors = FALSE)
variables_all = c("rs13129697_rounded", "rs5743618_rounded", "rs3749751_rounded", "rs2519093_rounded", "rs12260868_rounded", "rs17559023_rounded", "rs601338_rounded")
variables_eas = c("rs13129697_rounded", "rs3749751_rounded", "rs2519093_rounded", "rs12260868_rounded")
ancestry = c("SAS", "EUR", "EAS")
sample_sums = colSums(ft)

set.seed(1)

for (j in 1:length(ancestry)) {
    print(ancestry[j])
    md = read.csv(paste('files/candidateLoci_withMissing_', ancestry[j], '.csv', sep=""))
    rownames(md) = md[,1]
    ft_red = ft[,rownames(md)]
    sample_sums = colSums(ft_red)
    md$read_depth = sample_sums
    md$gender <- factor(md$gender,
                 levels = c(1, 2, 3),
                 labels = c("Male", "Female", "Other"))
    md$physical_mental_condition <- relevel(as.factor(md$physical_mental_condition), ref = "no_reported_condition")
    md$family_id = as.character(md$family_id)
    if (ancestry[j] == "EAS") {
      variables = variables_eas
    } else {
      variables = variables_all
    }
    for (v in 1:length(variables)) {
      print(v)
      md_red = md[!is.na(md[,variables[v]]),]
      group = variables[v]
      fit_out <- maaslin3(input_data = ft_red,
                    input_metadata = md_red,
                    output = paste('differential_abundance_genotype/maaslin3_', ancestry[j], "_", variables[v], sep=""),
                    formula = paste('~ ', group, '+ group(gender) + age + physical_mental_condition + PC1 + PC2 + PC3 + PC4 + read_depth', sep=""),
                    strata_effects = 'family_id',
                    normalization = 'TSS',
                    transform = 'LOG',
                    augment = TRUE,
                    standardize = TRUE,
                    max_significance = 0.1,
                    median_comparison_abundance = TRUE,
                    median_comparison_prevalence = FALSE,
                    max_pngs = 10,
                    cores = 48)
    }
}

```

Significant taxa:
```{python}
variables_all = ["rs13129697_rounded", "rs5743618_rounded", "rs3749751_rounded", "rs2519093_rounded", "rs12260868_rounded", "rs17559023_rounded", "rs601338_rounded"]
ancestry = ["SAS", "EUR", "EAS"]

tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
genus = {}
for row in tax.index.values:
  genus[row] = tax.loc[row, 'Genus']

all_sig = []

for anc in ancestry:
  for variable in variables_all:
    try:
      this_sig = pd.read_csv(folder+'differential_abundance_genotype/maaslin3_'+anc+'_'+variable+'/all_results.tsv', index_col=0, header=0, sep='\t')
    except:
      continue
    this_sig = this_sig[this_sig['metadata'] == variable]
    this_sig = this_sig[this_sig['model'] == 'abundance']
    this_sig = this_sig[this_sig['qval_individual'] <= 0.1]
    for row in this_sig.index.values:
      all_sig.append(row)
      
all_sig = list(set(all_sig))

start = True
for variable in variables_all:
  for anc in ancestry:
    try:
      all_res = pd.read_csv(folder+'differential_abundance_genotype/maaslin3_'+anc+'_'+variable+'/all_results.tsv', index_col=0, header=0, sep='\t')
    except:
      continue
    all_res = all_res[all_res['metadata'] == variable]
    all_res = all_res[all_res['model'] == 'abundance']
    keeping = []
    for tax in all_sig:
      if tax in all_res.index.values:
        keeping.append(tax)
    if start:
      start = False
      all_df = all_res.copy(deep=True).loc[keeping, ['coef', 'qval_individual']].rename(columns={'coef':anc+' '+variable+' coef', 'qval_individual':anc+' '+variable+' q'})
    else:
      for tax in keeping:
        all_df.loc[tax, anc+' '+variable+' coef'] = all_res.loc[tax, 'coef']
        all_df.loc[tax, anc+' '+variable+' q'] = all_res.loc[tax, 'qval_individual']
        
all_df = all_df.rename(index=genus)
all_df.to_csv(folder+'differential_abundance_genotype/maaslin3_genotype_summary.csv')
        
```

Genotype summary plot:
```{python}
variables_all = ["rs13129697", "rs5743618", "rs3749751", "rs2519093", "rs12260868", "rs17559023", "rs601338"]
variables_eas = ["rs13129697", "rs3749751", "rs2519093", "rs12260868"]
ancestry = ['EAS', 'SAS', 'EUR']
alpha_metrics = ['shannon', 'simpson', 'simpson_e', 'faith_pd', 'observed_otus', 'chao1']
alpha_rename = {'shannon':"Shannon diversity", 'simpson':"Simpson's index", 'simpson_e':"Simpson's evenness", 'faith_pd':"Faith's PD", 'observed_otus':"Number of ASVs", 'chao1':'Chao1 richness'}

names = {'rs13129697':'SLC2A9\n(rs13129697)', 'rs5743618':'TLR1\n(rs5743618)', 'rs3749751':'PITX1\n(rs3749751)', 'rs2519093':'ABO\n(rs2519093)', 'rs12260868':'PPP1R3C/HECTD2\n(rs12260868)', 'rs17559023':'POLI/RAB27B\n(rs17559023)', 'rs601338':'FUT2\n(rs601338)'}

alpha = pd.read_csv(folder+'alpha_stats_genotyping/alpha_overall_summary.csv', index_col=0, header=0)
beta = pd.read_csv(folder+'beta_stats_genotyping/beta_overall_summary.csv', index_col=0, header=0)
diff_abun = pd.read_csv(folder+'differential_abundance_genotype/maaslin3_genotype_summary.csv', index_col=0, header=0)

ft_genus = pd.read_csv(folder+'files/feature_table_genus.csv', index_col=0, header=0)
tax = pd.read_csv(folder+'files/taxonomy.csv', index_col=0, header=0)
genus = {}
for row in tax.index.values:
  genus[row] = tax.loc[row, 'Genus']

ft_genus = ft_genus.rename(index=genus)
ft_genus = ft_genus.divide(ft_genus.sum(axis=0), axis=1).multiply(100)
ft_genus['Mean'] = ft_genus.mean(axis=1)
ft_genus = ft_genus.loc[diff_abun.index.values, ['Mean']]
ft_genus = ft_genus.sort_values(by=['Mean'], ascending=True)

diff_abun = diff_abun.loc[ft_genus.index.values, :]

rename_tax = {}
for row in diff_abun.index.values:
  if 'g__' in row:
    tax = row.replace('g__', '')
    if '_' in tax:
      tax = tax.replace('_', ' ')
    else:
      tax = '$'+tax+'$'
    rename_tax[row] = tax
  else:
    rename_tax[row] = row

fig = plt.figure(figsize=(18,15))

m_beta = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=0, vmax=0.001), cmap=cm.PuBuGn)
m_alp = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=0, vmax=0.2), cmap=cm.YlOrRd)
m_tax = cm.ScalarMappable(norm=mpl.colors.Normalize(vmin=-1, vmax=1), cmap=cm.RdBu_r)

s=0
for var in variables_all:
  if var in variables_eas: width=3
  else: width=2
  ax_beta = plt.subplot2grid((22,18),(0,s), colspan=width)
  ax_alpha = plt.subplot2grid((22,18),(1,s), colspan=width, rowspan=6)
  ax_da = plt.subplot2grid((22,18),(7,s), colspan=width, rowspan=2)
  s += width
  ti = ax_beta.set_title(names[var], fontweight='bold')
  for a in range(len(ancestry)):
    anc = ancestry[a]
    if anc == 'EAS' and var not in variables_eas: continue
    r2, p = beta.loc[var, anc+' R2 continuous'], beta.loc[var, anc+' p continuous']
    if p <= 0.05:
      ba = ax_beta.barh(0, height=1, width=1, left=a, color=m_beta.to_rgba(r2), edgecolor='k')
      if r2 <= 0.0005: tx = ax_beta.text(a+0.5, 0, str(round(r2, 4)), color='k', ha='center', va='center')
      else: tx = ax_beta.text(a+0.5, 0, str(round(r2, 4)), color='w', ha='center', va='center')
    else:
      ba = ax_beta.barh(0, height=1, width=1, left=a, color='gray', edgecolor='k')
      tx = ax_beta.text(a+0.5, 0, str(round(r2, 4)), color='k', ha='center', va='center')
    genotyping = pd.read_csv(folder+'genotyping/candidateLoci_withMissing_'+anc+'.csv', index_col=0, header=0)
    genotyping = genotyping.loc[:, [var+'_rounded']]
    genotyping = genotyping.dropna()
    for m in range(len(alpha_metrics)):
      metric = alpha_metrics[m]
      alp_vals = pd.read_csv(folder+'files/alpha_diversity/alpha_'+metric+'.csv', index_col=0, header=0).loc[genotyping.index.values, ['Mean']]
      f, p = alpha.loc[var, metric+' '+anc+' F continuous'], alpha.loc[var, metric+' '+anc+' p continuous']
      corr, p = spearmanr(alp_vals['Mean'], genotyping[var+'_rounded'])
      if p <= 0.05:
        ba = ax_alpha.barh(m, height=1, width=1, left=a, color=m_alp.to_rgba(corr), edgecolor='k')
        tx = ax_alpha.text(a+0.5, m, str(round(corr, 3)), color='k', ha='center', va='center')
      else:
        ba = ax_alpha.barh(m, height=1, width=1, left=a, color='gray', edgecolor='k')
        tx = ax_alpha.text(a+0.5, m, str(round(corr, 3)), color='k', ha='center', va='center')
    t = 0
    for tax in diff_abun.index.values:
      coef, q = diff_abun.loc[tax, anc+' '+var+'_rounded coef'], diff_abun.loc[tax, anc+' '+var+'_rounded q']
      if math.isnan(coef): 
        ba = ax_da.barh(t, height=1, width=1, left=a, color='w', edgecolor='k')
        tx = ax_da.text(a+0.5, t, 'NA', color='k', ha='center', va='center')
        t += 1
        continue
      if q <= 0.1:
        ba = ax_da.barh(t, height=1, width=1, left=a, color=m_tax.to_rgba(coef), edgecolor='k')
        if abs(coef) < 0.5: tx = ax_da.text(a+0.5, t, str(round(coef, 3)), color='k', ha='center', va='center')
        else: tx = ax_da.text(a+0.5, t, str(round(coef, 3)), color='w', ha='center', va='center')
      else:
        ba = ax_da.barh(t, height=1, width=1, left=a, color='gray', edgecolor='k')
        tx = ax_da.text(a+0.5, t, str(round(coef, 3)), color='k', ha='center', va='center')
      t += 1
  if width == 3:
    xloc, xname = [0.5, 1.5, 2.5], ['East Asian', 'South Asian', 'European']
  else:
    xloc, xname = [1.5, 2.5], ['South Asian', 'European']
  plt.sca(ax_beta)
  xt = plt.xticks(xloc, xname, rotation=90)
  tt = ax_beta.xaxis.tick_top()
  if var == variables_all[0]: yt = plt.yticks([0], ['Phylogenetic-RPCA R$^{2}$'], fontweight='bold')
  else: yt = plt.yticks([])
  xl = plt.xlim([xloc[0]-0.5, xloc[-1]+0.5]), plt.ylim([-0.5, 0.5])
  plt.sca(ax_alpha)
  xt = plt.xticks([])
  if var == variables_all[0]: 
    yt = plt.yticks([0, 1, 2, 3, 4, 5], [alpha_rename[met] for met in alpha_metrics])
    yl = plt.ylabel('Alpha diversity correlations', fontweight='bold')
  else: yt = plt.yticks([])
  xl = plt.xlim([xloc[0]-0.5, xloc[-1]+0.5]), plt.ylim([-0.5, 5.5])
  plt.sca(ax_da)
  xt = plt.xticks([])
  if var == variables_all[0]: 
    yt = plt.yticks([x for x in range(len(diff_abun.index.values))], [rename_tax[tax] for tax in diff_abun.index.values])
    yl = plt.ylabel('MaAsLin 3\ncoefficients', fontweight='bold')
  else: yt = plt.yticks([])
  xl = plt.xlim([xloc[0]-0.5, xloc[-1]+0.5]), plt.ylim([-0.5, len(diff_abun.index.values)-0.5])
  

plt.savefig(folder+'figures/genotyping_associations.png', bbox_inches='tight', dpi=600)
plt.close()
```
